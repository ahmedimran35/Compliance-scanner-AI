import axios from 'axios';
import { JSDOM } from 'jsdom';

interface ScanOptions {
  gdpr: boolean;
  accessibility: boolean;
  security: boolean;
  performance: boolean;
  seo: boolean;
  customRules: string[];
}

interface ScanResult {
  gdpr: {
    hasCookieBanner: boolean;
    hasPrivacyPolicy: boolean;
    hasTermsOfService: boolean;
    hasDataProcessingNotice: boolean;
    hasCookiePolicy: boolean;
    hasDataRetentionPolicy: boolean;
    hasUserConsentMechanism: boolean;
    hasDataPortability: boolean;
    hasRightToErasure: boolean;
    hasDataMinimization: boolean;
    hasPurposeLimitation: boolean;
    hasLawfulBasis: boolean;
    score: number;
    issues: string[];
    recommendations: string[];
    complianceLevel: 'compliant' | 'partially-compliant' | 'non-compliant';
  };
  accessibility: {
    hasAltText: boolean;
    hasProperHeadings: boolean;
    hasContrastRatio: boolean;
    hasKeyboardNavigation: boolean;
    hasScreenReaderSupport: boolean;
    hasFocusIndicators: boolean;
    hasSkipLinks: boolean;
    hasARIALabels: boolean;
    hasSemanticHTML: boolean;
    hasFormLabels: boolean;
    hasLanguageDeclaration: boolean;
    hasErrorHandling: boolean;
    score: number;
    issues: string[];
    recommendations: string[];
    wcagLevel: 'A' | 'AA' | 'AAA' | 'non-compliant';
  };
  security: {
    hasHTTPS: boolean;
    hasSecurityHeaders: boolean;
    hasCSP: boolean;
    hasHSTS: boolean;
    hasXFrameOptions: boolean;
    hasXContentTypeOptions: boolean;
    hasReferrerPolicy: boolean;
    hasPermissionsPolicy: boolean;
    hasSecureCookies: boolean;
    hasCSRFProtection: boolean;
    hasInputValidation: boolean;
    hasOutputEncoding: boolean;
    hasSessionManagement: boolean;
    hasErrorHandling: boolean;
    score: number;
    issues: string[];
    recommendations: string[];
    securityLevel: 'high' | 'medium' | 'low' | 'critical';
  };
  performance: {
    loadTime: number;
    pageSize: number;
    imageOptimization: boolean;
    minification: boolean;
    compression: boolean;
    caching: boolean;
    cdnUsage: boolean;
    renderBlockingResources: number;
    unusedCSS: number;
    unusedJS: number;
    firstContentfulPaint: number;
    largestContentfulPaint: number;
    cumulativeLayoutShift: number;
    firstInputDelay: number;
    score: number;
    issues: string[];
    recommendations: string[];
    performanceGrade: 'A' | 'B' | 'C' | 'D' | 'F';
  };
  seo: {
    hasMetaTitle: boolean;
    hasMetaDescription: boolean;
    hasOpenGraph: boolean;
    hasTwitterCard: boolean;
    hasStructuredData: boolean;
    hasSitemap: boolean;
    hasRobotsTxt: boolean;
    hasCanonicalUrl: boolean;
    hasInternalLinking: boolean;
    hasHeadingStructure: boolean;
    hasImageOptimization: boolean;
    hasMobileOptimization: boolean;
    hasPageSpeed: boolean;
    hasSSL: boolean;
    score: number;
    issues: string[];
    recommendations: string[];
    seoScore: number;
  };
  overall: {
    score: number;
    grade: 'A' | 'B' | 'C' | 'D' | 'F';
    totalIssues: number;
    recommendations: string[];
    priorityIssues: string[];
    complianceStatus: 'excellent' | 'good' | 'fair' | 'poor' | 'critical';
  };
  scanDuration: number;
  technicalDetails: {
    serverInfo: string;
    technologies: string[];
    frameworks: string[];
    cms: string | null;
    hosting: string | null;
  };
}

export class WebsiteScanner {
  private url: string;
  private html: string = '';
  private dom!: JSDOM;
  private responseHeaders: any = {};
  private loadTime: number = 0;
  private pageSize: number = 0;
  private serverInfo: string = '';
  private technologies: string[] = [];
  private frameworks: string[] = [];
  private cms: string | null = null;
  private hosting: string | null = null;

  constructor(url: string) {
    this.url = url;
  }

  async scan(options: ScanOptions = {
    gdpr: true,
    accessibility: true,
    security: true,
    performance: false,
    seo: false,
    customRules: []
  }): Promise<ScanResult> {
    try {
      const startTime = Date.now();
      
      console.log(`Starting scan for ${this.url} with options:`, options);
      
      await this.fetchContent();
      this.parseHTML();
      this.detectTechnologies(); // Add this line to detect technologies

      const results: any = {};

      // Debug: Log what we're about to scan
      console.log('Starting scan with options:', options);
      console.log('HTML content length:', this.html.length);
      console.log('DOM parsed successfully:', !!this.dom);

      // Perform scans based on options
      if (options.gdpr) {
        console.log('Performing GDPR scan...');
        results.gdpr = this.checkGDPR();
      }

      if (options.accessibility) {
        console.log('Performing accessibility checks...');
        results.accessibility = this.checkAccessibility();
      }

      if (options.security) {
        console.log('Performing security checks...');
        results.security = this.checkSecurity();
      }

      if (options.performance) {
        console.log('Performing performance checks...');
        results.performance = this.checkPerformance();
      }

      if (options.seo) {
        console.log('Performing SEO checks...');
        results.seo = this.checkSEO();
      }

      const totalScanDuration = Date.now() - startTime;
      
      // Calculate overall score
      const overall = this.calculateOverall(results, options);
      
      // Debug: Log final technical details
      console.log('Final technical details being returned:');
      console.log('- Server Info:', this.serverInfo);
      console.log('- Technologies:', this.technologies);
      console.log('- Frameworks:', this.frameworks);
      console.log('- CMS:', this.cms);
      console.log('- Hosting:', this.hosting);
      console.log('- Total scan duration:', totalScanDuration, 'ms');

      return {
        gdpr: results.gdpr || this.getDefaultGDPR(),
        accessibility: results.accessibility || this.getDefaultAccessibility(),
        security: results.security || this.getDefaultSecurity(),
        performance: results.performance || this.getDefaultPerformance(),
        seo: results.seo || this.getDefaultSEO(),
        overall,
        scanDuration: totalScanDuration,
        technicalDetails: {
          serverInfo: this.serverInfo,
          technologies: this.technologies,
          frameworks: this.frameworks,
          cms: this.cms,
          hosting: this.hosting,
        }
      };
    } catch (error) {
      console.error('Scan error:', error);
      throw new Error(`Failed to scan website: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async fetchContent(): Promise<void> {
    try {
      const startTime = Date.now();
      
      const response = await axios.get(this.url, {
        timeout: 30000, // 30 seconds timeout
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; ComplianceScanner/1.0)',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.5',
          'Accept-Encoding': 'gzip, deflate, br',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
        },
        maxRedirects: 5,
        validateStatus: () => true, // Accept all status codes
        responseType: 'text',
        decompress: true,
      });
      
      const endTime = Date.now();
      this.loadTime = endTime - startTime;
      this.html = response.data;
      this.responseHeaders = response.headers;
      this.pageSize = Buffer.byteLength(response.data, 'utf8');
      
      // Extract server information
      this.serverInfo = response.headers['server'] || response.headers['Server'] || 'Unknown';
      
      // Detect technologies and frameworks
      this.detectTechnologies();
      
      console.log(`Fetched ${this.url}: ${this.loadTime}ms, ${this.pageSize} bytes, Server: ${this.serverInfo}`);
    } catch (error) {
      console.error(`Failed to fetch ${this.url}:`, error);
      throw new Error(`Failed to fetch website content: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private detectTechnologies(): void {
    const html = this.html.toLowerCase();
    const headers = this.responseHeaders;
    
    console.log('Detecting technologies for:', this.url);
    console.log('Server info:', this.serverInfo);
    
    // Clear previous detections
    this.technologies = [];
    this.frameworks = [];
    this.cms = null;
    this.hosting = null;
    
    // Detect server and hosting from headers
    this.detectServerAndHosting(headers);
    
    // Detect frameworks from HTML content
    this.detectFrameworks(html);
    
    // Detect CMS from HTML content
    this.detectCMS(html);
    
    // Detect technologies from HTML content and scripts
    this.detectTechnologiesFromContent(html);
    
    // Detect technologies from external scripts
    this.detectTechnologiesFromScripts();
    
    // Remove duplicates
    this.technologies = this.removeDuplicates(this.technologies);
    this.frameworks = this.removeDuplicates(this.frameworks);
    
    console.log('Detected frameworks:', this.frameworks);
    console.log('Detected CMS:', this.cms);
    console.log('Detected hosting:', this.hosting);
    console.log('Detected technologies:', this.technologies);
  }

  private removeDuplicates(array: string[]): string[] {
    return Array.from(new Set(array));
  }

  private addTechnology(tech: string): void {
    if (tech && !this.technologies.includes(tech)) {
      this.technologies.push(tech);
    }
  }

  private addFramework(framework: string): void {
    if (framework && !this.frameworks.includes(framework)) {
      this.frameworks.push(framework);
    }
  }

  private detectServerAndHosting(headers: any): void {
    // Server detection from headers
    const server = headers['server'] || headers['Server'] || '';
    const poweredBy = headers['x-powered-by'] || headers['X-Powered-By'] || '';
    const via = headers['via'] || headers['Via'] || '';
    const cfRay = headers['cf-ray'] || headers['CF-Ray'] || '';
    const xPoweredBy = headers['x-powered-by'] || headers['X-Powered-By'] || '';
    
    console.log('Raw headers for server detection:', {
      server,
      poweredBy,
      via,
      cfRay,
      xPoweredBy
    });
    
    if (server) {
      this.serverInfo = server;
      
      // Detect hosting from server header
      if (server.includes('cloudflare')) {
        this.hosting = 'Cloudflare';
        this.technologies.push('Cloudflare');
      } else if (server.includes('nginx')) {
        this.hosting = 'Nginx';
        this.technologies.push('Nginx');
      } else if (server.includes('apache')) {
        this.hosting = 'Apache';
        this.technologies.push('Apache');
      } else if (server.includes('iis')) {
        this.hosting = 'IIS';
        this.technologies.push('IIS');
      } else if (server.includes('caddy')) {
        this.hosting = 'Caddy';
        this.technologies.push('Caddy');
      } else if (server.includes('lighttpd')) {
        this.hosting = 'Lighttpd';
        this.technologies.push('Lighttpd');
      } else if (server.includes('gws')) {
        this.hosting = 'Google Web Server';
        this.technologies.push('Google Web Server');
      } else if (server.includes('sffe')) {
        this.hosting = 'Google Frontend';
        this.technologies.push('Google Frontend');
      } else if (server.includes('openresty')) {
        this.hosting = 'OpenResty';
        this.technologies.push('OpenResty');
      } else if (server.includes('litespeed')) {
        this.hosting = 'LiteSpeed';
        this.technologies.push('LiteSpeed');
      } else if (server.includes('jetty')) {
        this.hosting = 'Jetty';
        this.technologies.push('Jetty');
      } else if (server.includes('tomcat')) {
        this.hosting = 'Apache Tomcat';
        this.technologies.push('Apache Tomcat');
      } else if (server.includes('express')) {
        this.hosting = 'Express.js';
        this.technologies.push('Express.js');
      } else if (server.includes('node')) {
        this.hosting = 'Node.js';
        this.technologies.push('Node.js');
      } else if (server.includes('php')) {
        this.hosting = 'PHP';
        this.technologies.push('PHP');
      } else if (server.includes('python')) {
        this.hosting = 'Python';
        this.technologies.push('Python');
      } else if (server.includes('ruby')) {
        this.hosting = 'Ruby';
        this.technologies.push('Ruby');
      } else if (server.includes('asp.net')) {
        this.hosting = 'ASP.NET';
        this.technologies.push('ASP.NET');
      } else if (server.includes('django')) {
        this.hosting = 'Django';
        this.technologies.push('Django');
      } else if (server.includes('flask')) {
        this.hosting = 'Flask';
        this.technologies.push('Flask');
      } else if (server.includes('rails')) {
        this.hosting = 'Ruby on Rails';
        this.technologies.push('Ruby on Rails');
      } else if (server.includes('laravel')) {
        this.hosting = 'Laravel';
        this.technologies.push('Laravel');
      } else if (server.includes('wordpress')) {
        this.hosting = 'WordPress';
        this.technologies.push('WordPress');
      } else if (server.includes('drupal')) {
        this.hosting = 'Drupal';
        this.technologies.push('Drupal');
      } else if (server.includes('joomla')) {
        this.hosting = 'Joomla';
        this.technologies.push('Joomla');
      } else if (server.includes('shopify')) {
        this.hosting = 'Shopify';
        this.technologies.push('Shopify');
      } else if (server.includes('wix')) {
        this.hosting = 'Wix';
        this.technologies.push('Wix');
      } else if (server.includes('squarespace')) {
        this.hosting = 'Squarespace';
        this.technologies.push('Squarespace');
      } else if (server.includes('ghost')) {
        this.hosting = 'Ghost';
        this.technologies.push('Ghost');
      } else if (server.includes('hugo')) {
        this.hosting = 'Hugo';
        this.technologies.push('Hugo');
      } else if (server.includes('jekyll')) {
        this.hosting = 'Jekyll';
        this.technologies.push('Jekyll');
      } else if (server.includes('next')) {
        this.hosting = 'Next.js';
        this.technologies.push('Next.js');
      } else if (server.includes('nuxt')) {
        this.hosting = 'Nuxt.js';
        this.technologies.push('Nuxt.js');
      } else if (server.includes('gatsby')) {
        this.hosting = 'Gatsby';
        this.technologies.push('Gatsby');
      } else if (server.includes('vercel')) {
        this.hosting = 'Vercel';
        this.technologies.push('Vercel');
      } else if (server.includes('netlify')) {
        this.hosting = 'Netlify';
        this.technologies.push('Netlify');
      } else if (server.includes('firebase')) {
        this.hosting = 'Firebase';
        this.technologies.push('Firebase');
      } else if (server.includes('aws')) {
        this.hosting = 'AWS';
        this.technologies.push('AWS');
      } else if (server.includes('google')) {
        this.hosting = 'Google Cloud';
        this.technologies.push('Google Cloud');
      } else if (server.includes('azure')) {
        this.hosting = 'Microsoft Azure';
        this.technologies.push('Microsoft Azure');
      } else if (server.includes('heroku')) {
        this.hosting = 'Heroku';
        this.technologies.push('Heroku');
      } else if (server.includes('digitalocean')) {
        this.hosting = 'DigitalOcean';
        this.technologies.push('DigitalOcean');
      } else if (server.includes('linode')) {
        this.hosting = 'Linode';
        this.technologies.push('Linode');
      } else if (server.includes('vultr')) {
        this.hosting = 'Vultr';
        this.technologies.push('Vultr');
      } else if (server.includes('ovh')) {
        this.hosting = 'OVH';
        this.technologies.push('OVH');
      } else if (server.includes('godaddy')) {
        this.hosting = 'GoDaddy';
        this.technologies.push('GoDaddy');
      } else if (server.includes('hostgator')) {
        this.hosting = 'HostGator';
        this.technologies.push('HostGator');
      } else if (server.includes('bluehost')) {
        this.hosting = 'Bluehost';
        this.technologies.push('Bluehost');
      } else if (server.includes('dreamhost')) {
        this.hosting = 'DreamHost';
        this.technologies.push('DreamHost');
      } else if (server.includes('siteground')) {
        this.hosting = 'SiteGround';
        this.technologies.push('SiteGround');
      } else if (server.includes('a2hosting')) {
        this.hosting = 'A2 Hosting';
        this.technologies.push('A2 Hosting');
      } else if (server.includes('inmotion')) {
        this.hosting = 'InMotion Hosting';
        this.technologies.push('InMotion Hosting');
      } else if (server.includes('hostinger')) {
        this.hosting = 'Hostinger';
        this.technologies.push('Hostinger');
      } else if (server.includes('namecheap')) {
        this.hosting = 'Namecheap';
        this.technologies.push('Namecheap');
      } else if (server.includes('ionos')) {
        this.hosting = 'IONOS';
        this.technologies.push('IONOS');
      } else if (server.includes('1and1')) {
        this.hosting = '1&1 IONOS';
        this.technologies.push('1&1 IONOS');
      } else if (server.includes('webhost')) {
        this.hosting = 'WebHost';
        this.technologies.push('WebHost');
      } else if (server.includes('hostmonster')) {
        this.hosting = 'HostMonster';
        this.technologies.push('HostMonster');
      } else if (server.includes('justhost')) {
        this.hosting = 'JustHost';
        this.technologies.push('JustHost');
      } else if (server.includes('ipage')) {
        this.hosting = 'iPage';
        this.technologies.push('iPage');
      } else if (server.includes('fatcow')) {
        this.hosting = 'FatCow';
        this.technologies.push('FatCow');
      } else if (server.includes('hostpapa')) {
        this.hosting = 'HostPapa';
        this.technologies.push('HostPapa');
      } else if (server.includes('greengeeks')) {
        this.hosting = 'GreenGeeks';
        this.technologies.push('GreenGeeks');
      } else if (server.includes('webhostingpad')) {
        this.hosting = 'WebHostingPad';
        this.technologies.push('WebHostingPad');
      } else if (server.includes('arvixe')) {
        this.hosting = 'Arvixe';
        this.technologies.push('Arvixe');
      } else if (server.includes('midphase')) {
        this.hosting = 'Midphase';
        this.technologies.push('Midphase');
      } else if (server.includes('westhost')) {
        this.hosting = 'WestHost';
        this.technologies.push('WestHost');
      } else if (server.includes('powweb')) {
        this.hosting = 'PowWeb';
        this.technologies.push('PowWeb');
      } else if (server.includes('startlogic')) {
        this.hosting = 'StartLogic';
        this.technologies.push('StartLogic');
      } else if (server.includes('supergreen')) {
        this.hosting = 'SuperGreen Hosting';
        this.technologies.push('SuperGreen Hosting');
      } else if (server.includes('hostclear')) {
        this.hosting = 'HostClear';
        this.technologies.push('HostClear');
      } else if (server.includes('hostnine')) {
        this.hosting = 'HostNine';
        this.technologies.push('HostNine');
      } else if (server.includes('hostgator')) {
        this.hosting = 'HostGator';
        this.technologies.push('HostGator');
      } else if (server.includes('bluehost')) {
        this.hosting = 'Bluehost';
        this.technologies.push('Bluehost');
      } else if (server.includes('dreamhost')) {
        this.hosting = 'DreamHost';
        this.technologies.push('DreamHost');
      } else if (server.includes('siteground')) {
        this.hosting = 'SiteGround';
        this.technologies.push('SiteGround');
      } else if (server.includes('a2hosting')) {
        this.hosting = 'A2 Hosting';
        this.technologies.push('A2 Hosting');
      } else if (server.includes('inmotion')) {
        this.hosting = 'InMotion Hosting';
        this.technologies.push('InMotion Hosting');
      } else if (server.includes('hostinger')) {
        this.hosting = 'Hostinger';
        this.technologies.push('Hostinger');
      } else if (server.includes('namecheap')) {
        this.hosting = 'Namecheap';
        this.technologies.push('Namecheap');
      } else if (server.includes('ionos')) {
        this.hosting = 'IONOS';
        this.technologies.push('IONOS');
      } else if (server.includes('1and1')) {
        this.hosting = '1&1 IONOS';
        this.technologies.push('1&1 IONOS');
      } else if (server.includes('webhost')) {
        this.hosting = 'WebHost';
        this.technologies.push('WebHost');
      } else if (server.includes('hostmonster')) {
        this.hosting = 'HostMonster';
        this.technologies.push('HostMonster');
      } else if (server.includes('justhost')) {
        this.hosting = 'JustHost';
        this.technologies.push('JustHost');
      } else if (server.includes('ipage')) {
        this.hosting = 'iPage';
        this.technologies.push('iPage');
      } else if (server.includes('fatcow')) {
        this.hosting = 'FatCow';
        this.technologies.push('FatCow');
      } else if (server.includes('hostpapa')) {
        this.hosting = 'HostPapa';
        this.technologies.push('HostPapa');
      } else if (server.includes('greengeeks')) {
        this.hosting = 'GreenGeeks';
        this.technologies.push('GreenGeeks');
      } else if (server.includes('webhostingpad')) {
        this.hosting = 'WebHostingPad';
        this.technologies.push('WebHostingPad');
      } else if (server.includes('arvixe')) {
        this.hosting = 'Arvixe';
        this.technologies.push('Arvixe');
      } else if (server.includes('midphase')) {
        this.hosting = 'Midphase';
        this.technologies.push('Midphase');
      } else if (server.includes('westhost')) {
        this.hosting = 'WestHost';
        this.technologies.push('WestHost');
      } else if (server.includes('powweb')) {
        this.hosting = 'PowWeb';
        this.technologies.push('PowWeb');
      } else if (server.includes('startlogic')) {
        this.hosting = 'StartLogic';
        this.technologies.push('StartLogic');
      } else if (server.includes('supergreen')) {
        this.hosting = 'SuperGreen Hosting';
        this.technologies.push('SuperGreen Hosting');
      } else if (server.includes('hostclear')) {
        this.hosting = 'HostClear';
        this.technologies.push('HostClear');
      } else if (server.includes('hostnine')) {
        this.hosting = 'HostNine';
        this.technologies.push('HostNine');
      }
    }
    
    // Detect hosting from powered-by header
    if (poweredBy) {
      if (poweredBy.includes('PHP')) {
        this.technologies.push('PHP');
      } else if (poweredBy.includes('ASP.NET')) {
        this.technologies.push('ASP.NET');
      } else if (poweredBy.includes('Express')) {
        this.technologies.push('Express.js');
      } else if (poweredBy.includes('Node.js')) {
        this.technologies.push('Node.js');
      } else if (poweredBy.includes('Python')) {
        this.technologies.push('Python');
      } else if (poweredBy.includes('Ruby')) {
        this.technologies.push('Ruby');
      } else if (poweredBy.includes('Java')) {
        this.technologies.push('Java');
      } else if (poweredBy.includes('Go')) {
        this.technologies.push('Go');
      } else if (poweredBy.includes('Rust')) {
        this.technologies.push('Rust');
      } else if (poweredBy.includes('C++')) {
        this.technologies.push('C++');
      } else if (poweredBy.includes('C#')) {
        this.technologies.push('C#');
      } else if (poweredBy.includes('Scala')) {
        this.technologies.push('Scala');
      } else if (poweredBy.includes('Kotlin')) {
        this.technologies.push('Kotlin');
      } else if (poweredBy.includes('Swift')) {
        this.technologies.push('Swift');
      } else if (poweredBy.includes('Objective-C')) {
        this.technologies.push('Objective-C');
      } else if (poweredBy.includes('Perl')) {
        this.technologies.push('Perl');
      } else if (poweredBy.includes('Lua')) {
        this.technologies.push('Lua');
      } else if (poweredBy.includes('Haskell')) {
        this.technologies.push('Haskell');
      } else if (poweredBy.includes('Erlang')) {
        this.technologies.push('Erlang');
      } else if (poweredBy.includes('Elixir')) {
        this.technologies.push('Elixir');
      } else if (poweredBy.includes('Clojure')) {
        this.technologies.push('Clojure');
      } else if (poweredBy.includes('F#')) {
        this.technologies.push('F#');
      } else if (poweredBy.includes('OCaml')) {
        this.technologies.push('OCaml');
      } else if (poweredBy.includes('R')) {
        this.technologies.push('R');
      } else if (poweredBy.includes('MATLAB')) {
        this.technologies.push('MATLAB');
      } else if (poweredBy.includes('Julia')) {
        this.technologies.push('Julia');
      } else if (poweredBy.includes('Dart')) {
        this.technologies.push('Dart');
      } else if (poweredBy.includes('TypeScript')) {
        this.technologies.push('TypeScript');
      } else if (poweredBy.includes('CoffeeScript')) {
        this.technologies.push('CoffeeScript');
      } else if (poweredBy.includes('LiveScript')) {
        this.technologies.push('LiveScript');
      } else if (poweredBy.includes('Elm')) {
        this.technologies.push('Elm');
      } else if (poweredBy.includes('PureScript')) {
        this.technologies.push('PureScript');
      } else if (poweredBy.includes('Reason')) {
        this.technologies.push('Reason');
      } else if (poweredBy.includes('ReScript')) {
        this.technologies.push('ReScript');
      } else if (poweredBy.includes('Svelte')) {
        this.technologies.push('Svelte');
      } else if (poweredBy.includes('Alpine.js')) {
        this.technologies.push('Alpine.js');
      } else if (poweredBy.includes('Stimulus')) {
        this.technologies.push('Stimulus');
      } else if (poweredBy.includes('Hotwire')) {
        this.technologies.push('Hotwire');
      } else if (poweredBy.includes('Turbo')) {
        this.technologies.push('Turbo');
      } else if (poweredBy.includes('Strada')) {
        this.technologies.push('Strada');
      } else if (poweredBy.includes('Phoenix')) {
        this.technologies.push('Phoenix');
      } else if (poweredBy.includes('LiveView')) {
        this.technologies.push('LiveView');
      } else if (poweredBy.includes('Blazor')) {
        this.technologies.push('Blazor');
      } else if (poweredBy.includes('WebAssembly')) {
        this.technologies.push('WebAssembly');
      } else if (poweredBy.includes('WASM')) {
        this.technologies.push('WebAssembly');
      } else if (poweredBy.includes('WebGL')) {
        this.technologies.push('WebGL');
      } else if (poweredBy.includes('Canvas')) {
        this.technologies.push('Canvas');
      } else if (poweredBy.includes('SVG')) {
        this.technologies.push('SVG');
      } else if (poweredBy.includes('WebRTC')) {
        this.technologies.push('WebRTC');
      } else if (poweredBy.includes('WebSocket')) {
        this.technologies.push('WebSocket');
      } else if (poweredBy.includes('Server-Sent Events')) {
        this.technologies.push('Server-Sent Events');
      } else if (poweredBy.includes('SSE')) {
        this.technologies.push('Server-Sent Events');
      } else if (poweredBy.includes('GraphQL')) {
        this.technologies.push('GraphQL');
      } else if (poweredBy.includes('REST')) {
        this.technologies.push('REST API');
      } else if (poweredBy.includes('SOAP')) {
        this.technologies.push('SOAP');
      } else if (poweredBy.includes('gRPC')) {
        this.technologies.push('gRPC');
      } else if (poweredBy.includes('Protocol Buffers')) {
        this.technologies.push('Protocol Buffers');
      } else if (poweredBy.includes('protobuf')) {
        this.technologies.push('Protocol Buffers');
      } else if (poweredBy.includes('MessagePack')) {
        this.technologies.push('MessagePack');
      } else if (poweredBy.includes('BSON')) {
        this.technologies.push('BSON');
      } else if (poweredBy.includes('XML')) {
        this.technologies.push('XML');
      } else if (poweredBy.includes('YAML')) {
        this.technologies.push('YAML');
      } else if (poweredBy.includes('TOML')) {
        this.technologies.push('TOML');
      } else if (poweredBy.includes('INI')) {
        this.technologies.push('INI');
      } else if (poweredBy.includes('JSON')) {
        this.technologies.push('JSON');
      } else if (poweredBy.includes('CSV')) {
        this.technologies.push('CSV');
      } else if (poweredBy.includes('TSV')) {
        this.technologies.push('TSV');
      } else if (poweredBy.includes('Markdown')) {
        this.technologies.push('Markdown');
      } else if (poweredBy.includes('AsciiDoc')) {
        this.technologies.push('AsciiDoc');
      } else if (poweredBy.includes('reStructuredText')) {
        this.technologies.push('reStructuredText');
      } else if (poweredBy.includes('Textile')) {
        this.technologies.push('Textile');
      } else if (poweredBy.includes('WikiText')) {
        this.technologies.push('WikiText');
      } else if (poweredBy.includes('BBCode')) {
        this.technologies.push('BBCode');
      } else if (poweredBy.includes('HTML')) {
        this.technologies.push('HTML');
      } else if (poweredBy.includes('CSS')) {
        this.technologies.push('CSS');
      } else if (poweredBy.includes('JavaScript')) {
        this.technologies.push('JavaScript');
      } else if (poweredBy.includes('JS')) {
        this.technologies.push('JavaScript');
      } else if (poweredBy.includes('ECMAScript')) {
        this.technologies.push('ECMAScript');
      } else if (poweredBy.includes('ES6')) {
        this.technologies.push('ECMAScript 6');
      } else if (poweredBy.includes('ES2015')) {
        this.technologies.push('ECMAScript 2015');
      } else if (poweredBy.includes('ES2016')) {
        this.technologies.push('ECMAScript 2016');
      } else if (poweredBy.includes('ES2017')) {
        this.technologies.push('ECMAScript 2017');
      } else if (poweredBy.includes('ES2018')) {
        this.technologies.push('ECMAScript 2018');
      } else if (poweredBy.includes('ES2019')) {
        this.technologies.push('ECMAScript 2019');
      } else if (poweredBy.includes('ES2020')) {
        this.technologies.push('ECMAScript 2020');
      } else if (poweredBy.includes('ES2021')) {
        this.technologies.push('ECMAScript 2021');
      } else if (poweredBy.includes('ES2022')) {
        this.technologies.push('ECMAScript 2022');
      } else if (poweredBy.includes('ES2023')) {
        this.technologies.push('ECMAScript 2023');
      } else if (poweredBy.includes('ES2024')) {
        this.technologies.push('ECMAScript 2024');
      }
    }
    
    // Detect hosting from Via header
    if (via) {
      if (via.includes('cloudflare')) {
        this.hosting = 'Cloudflare';
        this.technologies.push('Cloudflare');
      } else if (via.includes('fastly')) {
        this.hosting = 'Fastly';
        this.technologies.push('Fastly');
      } else if (via.includes('akamai')) {
        this.hosting = 'Akamai';
        this.technologies.push('Akamai');
      } else if (via.includes('cloudfront')) {
        this.hosting = 'AWS CloudFront';
        this.technologies.push('AWS CloudFront');
      } else if (via.includes('google')) {
        this.hosting = 'Google Cloud';
        this.technologies.push('Google Cloud');
      } else if (via.includes('azure')) {
        this.hosting = 'Microsoft Azure';
        this.technologies.push('Microsoft Azure');
      } else if (via.includes('heroku')) {
        this.hosting = 'Heroku';
        this.technologies.push('Heroku');
      } else if (via.includes('vercel')) {
        this.hosting = 'Vercel';
        this.technologies.push('Vercel');
      } else if (via.includes('netlify')) {
        this.hosting = 'Netlify';
        this.technologies.push('Netlify');
      } else if (via.includes('firebase')) {
        this.hosting = 'Firebase';
        this.technologies.push('Firebase');
      } else if (via.includes('digitalocean')) {
        this.hosting = 'DigitalOcean';
        this.technologies.push('DigitalOcean');
      } else if (via.includes('linode')) {
        this.hosting = 'Linode';
        this.technologies.push('Linode');
      } else if (via.includes('vultr')) {
        this.hosting = 'Vultr';
        this.technologies.push('Vultr');
      } else if (via.includes('ovh')) {
        this.hosting = 'OVH';
        this.technologies.push('OVH');
      } else if (via.includes('godaddy')) {
        this.hosting = 'GoDaddy';
        this.technologies.push('GoDaddy');
      } else if (via.includes('hostgator')) {
        this.hosting = 'HostGator';
        this.technologies.push('HostGator');
      } else if (via.includes('bluehost')) {
        this.hosting = 'Bluehost';
        this.technologies.push('Bluehost');
      } else if (via.includes('dreamhost')) {
        this.hosting = 'DreamHost';
        this.technologies.push('DreamHost');
      } else if (via.includes('siteground')) {
        this.hosting = 'SiteGround';
        this.technologies.push('SiteGround');
      } else if (via.includes('a2hosting')) {
        this.hosting = 'A2 Hosting';
        this.technologies.push('A2 Hosting');
      } else if (via.includes('inmotion')) {
        this.hosting = 'InMotion Hosting';
        this.technologies.push('InMotion Hosting');
      } else if (via.includes('hostinger')) {
        this.hosting = 'Hostinger';
        this.technologies.push('Hostinger');
      } else if (via.includes('namecheap')) {
        this.hosting = 'Namecheap';
        this.technologies.push('Namecheap');
      } else if (via.includes('ionos')) {
        this.hosting = 'IONOS';
        this.technologies.push('IONOS');
      } else if (via.includes('1and1')) {
        this.hosting = '1&1 IONOS';
        this.technologies.push('1&1 IONOS');
      } else if (via.includes('webhost')) {
        this.hosting = 'WebHost';
        this.technologies.push('WebHost');
      } else if (via.includes('hostmonster')) {
        this.hosting = 'HostMonster';
        this.technologies.push('HostMonster');
      } else if (via.includes('justhost')) {
        this.hosting = 'JustHost';
        this.technologies.push('JustHost');
      } else if (via.includes('ipage')) {
        this.hosting = 'iPage';
        this.technologies.push('iPage');
      } else if (via.includes('fatcow')) {
        this.hosting = 'FatCow';
        this.technologies.push('FatCow');
      } else if (via.includes('hostpapa')) {
        this.hosting = 'HostPapa';
        this.technologies.push('HostPapa');
      } else if (via.includes('greengeeks')) {
        this.hosting = 'GreenGeeks';
        this.technologies.push('GreenGeeks');
      } else if (via.includes('webhostingpad')) {
        this.hosting = 'WebHostingPad';
        this.technologies.push('WebHostingPad');
      } else if (via.includes('arvixe')) {
        this.hosting = 'Arvixe';
        this.technologies.push('Arvixe');
      } else if (via.includes('midphase')) {
        this.hosting = 'Midphase';
        this.technologies.push('Midphase');
      } else if (via.includes('westhost')) {
        this.hosting = 'WestHost';
        this.technologies.push('WestHost');
      } else if (via.includes('powweb')) {
        this.hosting = 'PowWeb';
        this.technologies.push('PowWeb');
      } else if (via.includes('startlogic')) {
        this.hosting = 'StartLogic';
        this.technologies.push('StartLogic');
      } else if (via.includes('supergreen')) {
        this.hosting = 'SuperGreen Hosting';
        this.technologies.push('SuperGreen Hosting');
      } else if (via.includes('hostclear')) {
        this.hosting = 'HostClear';
        this.technologies.push('HostClear');
      } else if (via.includes('hostnine')) {
        this.hosting = 'HostNine';
        this.technologies.push('HostNine');
      }
    }
    
    // Detect hosting from CF-Ray header (Cloudflare specific)
    if (cfRay) {
      this.hosting = 'Cloudflare';
      this.technologies.push('Cloudflare');
    }
    
    // If no specific hosting detected, try to infer from URL
    if (!this.hosting) {
      const url = this.url.toLowerCase();
      if (url.includes('vercel.app') || url.includes('vercel.com')) {
        this.hosting = 'Vercel';
        this.technologies.push('Vercel');
      } else if (url.includes('netlify.app') || url.includes('netlify.com')) {
        this.hosting = 'Netlify';
        this.technologies.push('Netlify');
      } else if (url.includes('firebaseapp.com')) {
        this.hosting = 'Firebase';
        this.technologies.push('Firebase');
      } else if (url.includes('herokuapp.com')) {
        this.hosting = 'Heroku';
        this.technologies.push('Heroku');
      } else if (url.includes('amazonaws.com') || url.includes('aws')) {
        this.hosting = 'AWS';
        this.technologies.push('AWS');
      } else if (url.includes('googleapis.com') || url.includes('google.com')) {
        this.hosting = 'Google Cloud';
        this.technologies.push('Google Cloud');
      } else if (url.includes('azurewebsites.net') || url.includes('azure.com')) {
        this.hosting = 'Microsoft Azure';
        this.technologies.push('Microsoft Azure');
      } else if (url.includes('digitalocean.com')) {
        this.hosting = 'DigitalOcean';
        this.technologies.push('DigitalOcean');
      } else if (url.includes('linode.com')) {
        this.hosting = 'Linode';
        this.technologies.push('Linode');
      } else if (url.includes('vultr.com')) {
        this.hosting = 'Vultr';
        this.technologies.push('Vultr');
      } else if (url.includes('ovh.com')) {
        this.hosting = 'OVH';
        this.technologies.push('OVH');
      } else if (url.includes('godaddy.com')) {
        this.hosting = 'GoDaddy';
        this.technologies.push('GoDaddy');
      } else if (url.includes('hostgator.com')) {
        this.hosting = 'HostGator';
        this.technologies.push('HostGator');
      } else if (url.includes('bluehost.com')) {
        this.hosting = 'Bluehost';
        this.technologies.push('Bluehost');
      } else if (url.includes('dreamhost.com')) {
        this.hosting = 'DreamHost';
        this.technologies.push('DreamHost');
      } else if (url.includes('siteground.com')) {
        this.hosting = 'SiteGround';
        this.technologies.push('SiteGround');
      } else if (url.includes('a2hosting.com')) {
        this.hosting = 'A2 Hosting';
        this.technologies.push('A2 Hosting');
      } else if (url.includes('inmotionhosting.com')) {
        this.hosting = 'InMotion Hosting';
        this.technologies.push('InMotion Hosting');
      } else if (url.includes('hostinger.com')) {
        this.hosting = 'Hostinger';
        this.technologies.push('Hostinger');
      } else if (url.includes('namecheap.com')) {
        this.hosting = 'Namecheap';
        this.technologies.push('Namecheap');
      } else if (url.includes('ionos.com')) {
        this.hosting = 'IONOS';
        this.technologies.push('IONOS');
      } else if (url.includes('1and1.com')) {
        this.hosting = '1&1 IONOS';
        this.technologies.push('1&1 IONOS');
      } else if (url.includes('webhost.com')) {
        this.hosting = 'WebHost';
        this.technologies.push('WebHost');
      } else if (url.includes('hostmonster.com')) {
        this.hosting = 'HostMonster';
        this.technologies.push('HostMonster');
      } else if (url.includes('justhost.com')) {
        this.hosting = 'JustHost';
        this.technologies.push('JustHost');
      } else if (url.includes('ipage.com')) {
        this.hosting = 'iPage';
        this.technologies.push('iPage');
      } else if (url.includes('fatcow.com')) {
        this.hosting = 'FatCow';
        this.technologies.push('FatCow');
      } else if (url.includes('hostpapa.com')) {
        this.hosting = 'HostPapa';
        this.technologies.push('HostPapa');
      } else if (url.includes('greengeeks.com')) {
        this.hosting = 'GreenGeeks';
        this.technologies.push('GreenGeeks');
      } else if (url.includes('webhostingpad.com')) {
        this.hosting = 'WebHostingPad';
        this.technologies.push('WebHostingPad');
      } else if (url.includes('arvixe.com')) {
        this.hosting = 'Arvixe';
        this.technologies.push('Arvixe');
      } else if (url.includes('midphase.com')) {
        this.hosting = 'Midphase';
        this.technologies.push('Midphase');
      } else if (url.includes('westhost.com')) {
        this.hosting = 'WestHost';
        this.technologies.push('WestHost');
      } else if (url.includes('powweb.com')) {
        this.hosting = 'PowWeb';
        this.technologies.push('PowWeb');
      } else if (url.includes('startlogic.com')) {
        this.hosting = 'StartLogic';
        this.technologies.push('StartLogic');
      } else if (url.includes('supergreenhosting.com')) {
        this.hosting = 'SuperGreen Hosting';
        this.technologies.push('SuperGreen Hosting');
      } else if (url.includes('hostclear.com')) {
        this.hosting = 'HostClear';
        this.technologies.push('HostClear');
      } else if (url.includes('hostnine.com')) {
        this.hosting = 'HostNine';
        this.technologies.push('HostNine');
      }
    }
  }

  private detectFrameworks(html: string): void {
    // React detection
    if (html.includes('react') || html.includes('reactjs') || html.includes('react-dom')) {
      this.addFramework('React');
    }
    
    // Angular detection
    if (html.includes('angular') || html.includes('ng-') || html.includes('angularjs')) {
      this.addFramework('Angular');
    }
    
    // Vue.js detection
    if (html.includes('vue') || html.includes('v-') || html.includes('vuejs')) {
      this.addFramework('Vue.js');
    }
    
    // jQuery detection
    if (html.includes('jquery') || html.includes('jquery.min.js')) {
      this.addFramework('jQuery');
    }
    
    // Bootstrap detection
    if (html.includes('bootstrap') || html.includes('bootstrap.min.css') || html.includes('bootstrap.min.js')) {
      this.addFramework('Bootstrap');
    }
    
    // Tailwind CSS detection
    if (html.includes('tailwind') || html.includes('tailwindcss')) {
      this.addFramework('Tailwind CSS');
    }
    
    // Material-UI detection
    if (html.includes('material-ui') || html.includes('mui') || html.includes('@mui/')) {
      this.addFramework('Material-UI');
    }
    
    // Ant Design detection
    if (html.includes('antd') || html.includes('ant-design')) {
      this.addFramework('Ant Design');
    }
    
    // Chakra UI detection
    if (html.includes('chakra') || html.includes('chakra-ui')) {
      this.addFramework('Chakra UI');
    }
    
    // Next.js detection
    if (html.includes('next') || html.includes('__next') || html.includes('nextjs')) {
      this.addFramework('Next.js');
    }
    
    // Nuxt.js detection
    if (html.includes('nuxt') || html.includes('nuxtjs')) {
      this.addFramework('Nuxt.js');
    }
    
    // Gatsby detection
    if (html.includes('gatsby') || html.includes('gatsbyjs')) {
      this.addFramework('Gatsby');
    }
  }

  private detectCMS(html: string): void {
    // WordPress detection
    if (html.includes('wp-content') || html.includes('wp-includes') || html.includes('wordpress') || 
        html.includes('wp-json') || html.includes('wp-admin')) {
      this.cms = 'WordPress';
      this.technologies.push('WordPress');
    }
    // Drupal detection
    else if (html.includes('drupal') || html.includes('drupal.js') || html.includes('drupal.css')) {
      this.cms = 'Drupal';
      this.technologies.push('Drupal');
    }
    // Joomla detection
    else if (html.includes('joomla') || html.includes('joomla.js') || html.includes('joomla.css')) {
      this.cms = 'Joomla';
      this.technologies.push('Joomla');
    }
    // Shopify detection
    else if (html.includes('shopify') || html.includes('shopify.com') || html.includes('myshopify.com')) {
      this.cms = 'Shopify';
      this.technologies.push('Shopify');
    }
    // Wix detection
    else if (html.includes('wix') || html.includes('wixsite.com') || html.includes('wix.com')) {
      this.cms = 'Wix';
      this.technologies.push('Wix');
    }
    // Squarespace detection
    else if (html.includes('squarespace') || html.includes('squarespace.com')) {
      this.cms = 'Squarespace';
      this.technologies.push('Squarespace');
    }
    // Ghost detection
    else if (html.includes('ghost') || html.includes('ghost.org')) {
      this.cms = 'Ghost';
      this.technologies.push('Ghost');
    }
    // Hugo detection
    else if (html.includes('hugo') || html.includes('hugo.js')) {
      this.cms = 'Hugo';
      this.technologies.push('Hugo');
    }
    // Jekyll detection
    else if (html.includes('jekyll') || html.includes('jekyll.js')) {
      this.cms = 'Jekyll';
      this.technologies.push('Jekyll');
    }
  }

  private detectTechnologiesFromContent(html: string): void {
    // Google Analytics detection
    if (html.includes('google-analytics.com') || html.includes('gtag') || html.includes('ga(') || 
        html.includes('googletagmanager.com') || html.includes('gtm.js')) {
      this.addTechnology('Google Analytics');
    }
    
    // Facebook Pixel detection
    if (html.includes('facebook.net') || html.includes('fbq') || html.includes('facebook.com/tr')) {
      this.addTechnology('Facebook Pixel');
    }
    
    // Stripe detection
    if (html.includes('stripe.com') || html.includes('stripe.js') || html.includes('stripe-js')) {
      this.addTechnology('Stripe');
    }
    
    // PayPal detection
    if (html.includes('paypal.com') || html.includes('paypal.js') || html.includes('paypalobjects.com')) {
      this.addTechnology('PayPal');
    }
    
    // reCAPTCHA detection
    if (html.includes('recaptcha') || html.includes('g-recaptcha') || html.includes('recaptcha.js')) {
      this.addTechnology('reCAPTCHA');
    }
    
    // AWS detection
    if (html.includes('aws') || html.includes('amazonaws.com') || html.includes('s3.amazonaws.com')) {
      this.addTechnology('AWS');
    }
    
    // Google Cloud detection
    if (html.includes('google-cloud') || html.includes('gcp') || html.includes('googleapis.com')) {
      this.addTechnology('Google Cloud');
    }
    
    // Azure detection
    if (html.includes('azure') || html.includes('microsoft.com') || html.includes('azurewebsites.net')) {
      this.addTechnology('Microsoft Azure');
    }
    
    // Vercel detection
    if (html.includes('vercel') || html.includes('vercel.app') || html.includes('vercel.com')) {
      this.addTechnology('Vercel');
    }
    
    // Netlify detection
    if (html.includes('netlify') || html.includes('netlify.app') || html.includes('netlify.com')) {
      this.addTechnology('Netlify');
    }
    
    // Firebase detection
    if (html.includes('firebase') || html.includes('firebaseapp.com') || html.includes('firebase.js')) {
      this.addTechnology('Firebase');
    }
    
    // Sentry detection
    if (html.includes('sentry') || html.includes('sentry.io') || html.includes('sentry.js')) {
      this.addTechnology('Sentry');
    }
    
    // Mixpanel detection
    if (html.includes('mixpanel') || html.includes('mixpanel.com') || html.includes('mixpanel.js')) {
      this.addTechnology('Mixpanel');
    }
    
    // Hotjar detection
    if (html.includes('hotjar') || html.includes('hotjar.com') || html.includes('hjsv')) {
      this.addTechnology('Hotjar');
    }
    
    // Intercom detection
    if (html.includes('intercom') || html.includes('intercom.io') || html.includes('intercom.js')) {
      this.addTechnology('Intercom');
    }
    
    // Zendesk detection
    if (html.includes('zendesk') || html.includes('zendesk.com') || html.includes('zdassets.com')) {
      this.addTechnology('Zendesk');
    }
    
    // Mailchimp detection
    if (html.includes('mailchimp') || html.includes('mailchimp.com') || html.includes('chimpstatic.com')) {
      this.addTechnology('Mailchimp');
    }
    
    // HubSpot detection
    if (html.includes('hubspot') || html.includes('hubspot.com') || html.includes('hs-scripts.com')) {
      this.addTechnology('HubSpot');
    }
    
    // Salesforce detection
    if (html.includes('salesforce') || html.includes('force.com') || html.includes('salesforce.com')) {
      this.addTechnology('Salesforce');
    }
    
    // WooCommerce detection
    if (html.includes('woocommerce') || html.includes('wc-') || html.includes('woocommerce.js')) {
      this.addTechnology('WooCommerce');
    }
    
    // Magento detection
    if (html.includes('magento') || html.includes('magento.js') || html.includes('magento.css')) {
      this.addTechnology('Magento');
    }
    
    // PrestaShop detection
    if (html.includes('prestashop') || html.includes('prestashop.js')) {
      this.addTechnology('PrestaShop');
    }
    
    // OpenCart detection
    if (html.includes('opencart') || html.includes('opencart.js')) {
      this.addTechnology('OpenCart');
    }
    
    // Laravel detection
    if (html.includes('laravel') || html.includes('laravel.js') || html.includes('laravel.css')) {
      this.addTechnology('Laravel');
    }
    
    // Django detection
    if (html.includes('django') || html.includes('django.js') || html.includes('django.css')) {
      this.addTechnology('Django');
    }
    
    // Ruby on Rails detection
    if (html.includes('rails') || html.includes('ruby on rails') || html.includes('rails.js')) {
      this.addTechnology('Ruby on Rails');
    }
    
    // Express.js detection
    if (html.includes('express') || html.includes('expressjs') || html.includes('express.js')) {
      this.addTechnology('Express.js');
    }
    
    // Webpack detection
    if (html.includes('webpack') || html.includes('webpack.js') || html.includes('webpack-dev-server')) {
      this.addTechnology('Webpack');
    }
    
    // Vite detection
    if (html.includes('vite') || html.includes('vite.js') || html.includes('@vitejs')) {
      this.addTechnology('Vite');
    }
    
    // Parcel detection
    if (html.includes('parcel') || html.includes('parcel.js')) {
      this.addTechnology('Parcel');
    }
    
    // Rollup detection
    if (html.includes('rollup') || html.includes('rollup.js')) {
      this.addTechnology('Rollup');
    }
    
    // Babel detection
    if (html.includes('babel') || html.includes('babel.js') || html.includes('@babel')) {
      this.addTechnology('Babel');
    }
    
    // TypeScript detection
    if (html.includes('typescript') || html.includes('ts-') || html.includes('.ts')) {
      this.addTechnology('TypeScript');
    }
    
    // Sass/SCSS detection
    if (html.includes('sass') || html.includes('scss') || html.includes('.scss')) {
      this.addTechnology('Sass/SCSS');
    }
    
    // Less detection
    if (html.includes('less') || html.includes('.less')) {
      this.addTechnology('Less');
    }
    
    // PostCSS detection
    if (html.includes('postcss') || html.includes('postcss.js')) {
      this.addTechnology('PostCSS');
    }
    
    // Autoprefixer detection
    if (html.includes('autoprefixer') || html.includes('autoprefixer.js')) {
      this.addTechnology('Autoprefixer');
    }
    
    // ESLint detection
    if (html.includes('eslint') || html.includes('eslint.js')) {
      this.addTechnology('ESLint');
    }
    
    // Prettier detection
    if (html.includes('prettier') || html.includes('prettier.js')) {
      this.addTechnology('Prettier');
    }
    
    // Jest detection
    if (html.includes('jest') || html.includes('jest.js')) {
      this.addTechnology('Jest');
    }
    
    // Cypress detection
    if (html.includes('cypress') || html.includes('cypress.js')) {
      this.addTechnology('Cypress');
    }
    
    // Playwright detection
    if (html.includes('playwright') || html.includes('playwright.js')) {
      this.addTechnology('Playwright');
    }
    
    // Selenium detection
    if (html.includes('selenium') || html.includes('selenium.js')) {
      this.addTechnology('Selenium');
    }
    
    // Docker detection
    if (html.includes('docker') || html.includes('docker.js')) {
      this.addTechnology('Docker');
    }
    
    // Kubernetes detection
    if (html.includes('kubernetes') || html.includes('k8s') || html.includes('kube')) {
      this.addTechnology('Kubernetes');
    }
    
    // Terraform detection
    if (html.includes('terraform') || html.includes('terraform.js')) {
      this.addTechnology('Terraform');
    }
    
    // Ansible detection
    if (html.includes('ansible') || html.includes('ansible.js')) {
      this.addTechnology('Ansible');
    }
    
    // Jenkins detection
    if (html.includes('jenkins') || html.includes('jenkins.js')) {
      this.addTechnology('Jenkins');
    }
    
    // GitHub Actions detection
    if (html.includes('github actions') || html.includes('github.com/actions')) {
      this.addTechnology('GitHub Actions');
    }
    
    // GitLab CI detection
    if (html.includes('gitlab ci') || html.includes('gitlab.com/ci')) {
      this.addTechnology('GitLab CI');
    }
    
    // CircleCI detection
    if (html.includes('circleci') || html.includes('circleci.com')) {
      this.addTechnology('CircleCI');
    }
    
    // Travis CI detection
    if (html.includes('travis ci') || html.includes('travis-ci.com')) {
      this.addTechnology('Travis CI');
    }
  }

  private detectTechnologiesFromScripts(): void {
    try {
      // Parse the DOM to find script tags
      const scripts = this.dom.window.document.querySelectorAll('script[src]');
      
      scripts.forEach((script) => {
        const src = script.getAttribute('src')?.toLowerCase() || '';
        
        // Detect CDN technologies
        if (src.includes('cdnjs.cloudflare.com')) {
          this.addTechnology('Cloudflare CDN');
        }
        if (src.includes('unpkg.com')) {
          this.addTechnology('unpkg CDN');
        }
        if (src.includes('jsdelivr.net')) {
          this.addTechnology('jsDelivr CDN');
        }
        if (src.includes('cdn.jsdelivr.net')) {
          this.addTechnology('jsDelivr CDN');
        }
        
        // Detect specific libraries from CDN
        if (src.includes('jquery')) {
          this.addFramework('jQuery');
        }
        if (src.includes('bootstrap')) {
          this.addFramework('Bootstrap');
        }
        if (src.includes('react')) {
          this.addFramework('React');
        }
        if (src.includes('vue')) {
          this.addFramework('Vue.js');
        }
        if (src.includes('angular')) {
          this.addFramework('Angular');
        }
        
        // Detect analytics and tracking
        if (src.includes('google-analytics.com') || src.includes('googletagmanager.com')) {
          this.addTechnology('Google Analytics');
        }
        if (src.includes('facebook.net')) {
          this.addTechnology('Facebook Pixel');
        }
        if (src.includes('hotjar.com')) {
          this.addTechnology('Hotjar');
        }
        if (src.includes('mixpanel.com')) {
          this.addTechnology('Mixpanel');
        }
        if (src.includes('sentry.io')) {
          this.addTechnology('Sentry');
        }
        
        // Detect payment processors
        if (src.includes('stripe.com')) {
          this.addTechnology('Stripe');
        }
        if (src.includes('paypal.com')) {
          this.addTechnology('PayPal');
        }
        
        // Detect security
        if (src.includes('recaptcha')) {
          this.addTechnology('reCAPTCHA');
        }
        
        // Detect hosting and cloud services
        if (src.includes('vercel.app') || src.includes('vercel.com')) {
          this.addTechnology('Vercel');
        }
        if (src.includes('netlify.app') || src.includes('netlify.com')) {
          this.addTechnology('Netlify');
        }
        if (src.includes('firebaseapp.com')) {
          this.addTechnology('Firebase');
        }
        if (src.includes('amazonaws.com')) {
          this.addTechnology('AWS');
        }
        if (src.includes('googleapis.com')) {
          this.addTechnology('Google Cloud');
        }
        if (src.includes('azurewebsites.net')) {
          this.addTechnology('Microsoft Azure');
        }
      });
      
      // Also check inline scripts for technology signatures
      const inlineScripts = this.dom.window.document.querySelectorAll('script:not([src])');
      inlineScripts.forEach((script) => {
        const content = script.textContent?.toLowerCase() || '';
        
        // Detect frameworks from inline scripts
        if (content.includes('react') || content.includes('reactdom')) {
          this.addFramework('React');
        }
        if (content.includes('vue') || content.includes('vuejs')) {
          this.addFramework('Vue.js');
        }
        if (content.includes('angular') || content.includes('angularjs')) {
          this.addFramework('Angular');
        }
        if (content.includes('jquery') || content.includes('$(')) {
          this.addFramework('jQuery');
        }
        
        // Detect analytics from inline scripts
        if (content.includes('gtag') || content.includes('ga(') || content.includes('googleanalytics')) {
          this.addTechnology('Google Analytics');
        }
        if (content.includes('fbq') || content.includes('facebook')) {
          this.addTechnology('Facebook Pixel');
        }
        if (content.includes('mixpanel')) {
          this.addTechnology('Mixpanel');
        }
        if (content.includes('hotjar')) {
          this.addTechnology('Hotjar');
        }
        if (content.includes('sentry')) {
          this.addTechnology('Sentry');
        }
        
        // Detect payment processors from inline scripts
        if (content.includes('stripe')) {
          this.addTechnology('Stripe');
        }
        if (content.includes('paypal')) {
          this.addTechnology('PayPal');
        }
      });
      
    } catch (error) {
      console.error('Error detecting technologies from scripts:', error);
    }
  }

  private parseHTML(): void {
    this.dom = new JSDOM(this.html);
  }

  private checkGDPR() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    console.log('Starting comprehensive GDPR compliance analysis for:', this.url);

    // 1. Cookie Banner Analysis (Real Detection)
    const cookieBannerAnalysis = this.analyzeCookieBanner();
    const hasCookieBanner = cookieBannerAnalysis.found;
    if (!hasCookieBanner) {
      issues.push('No cookie consent banner found');
      recommendations.push('Implement a cookie consent banner that clearly explains data collection and provides accept/reject options');
      score -= 15;
    } else {
      console.log('Cookie banner found:', cookieBannerAnalysis.details);
      if (!cookieBannerAnalysis.hasAcceptButton) {
        issues.push('Cookie banner found but missing accept button');
        recommendations.push('Add clear accept/reject buttons to cookie banner');
        score -= 5;
      }
      if (!cookieBannerAnalysis.hasRejectButton) {
        issues.push('Cookie banner found but missing reject option');
        recommendations.push('Add reject option to cookie banner for GDPR compliance');
        score -= 5;
      }
    }

    // 2. Privacy Policy Analysis (Real Detection)
    const privacyPolicyAnalysis = this.analyzePrivacyPolicy();
    const hasPrivacyPolicy = privacyPolicyAnalysis.found;
    if (!hasPrivacyPolicy) {
      issues.push('No privacy policy found');
      recommendations.push('Create and prominently link to a comprehensive privacy policy');
      score -= 15;
    } else {
      console.log('Privacy policy found:', privacyPolicyAnalysis.details);
      if (!privacyPolicyAnalysis.hasDataCollection) {
        issues.push('Privacy policy found but missing data collection information');
        recommendations.push('Add detailed data collection practices to privacy policy');
        score -= 5;
      }
      if (!privacyPolicyAnalysis.hasDataUsage) {
        issues.push('Privacy policy found but missing data usage information');
        recommendations.push('Add clear data usage purposes to privacy policy');
        score -= 5;
      }
    }

    // 3. Terms of Service Analysis (Real Detection)
    const termsAnalysis = this.analyzeTermsOfService();
    const hasTermsOfService = termsAnalysis.found;
    if (!hasTermsOfService) {
      issues.push('No terms of service found');
      recommendations.push('Create and link to terms of service');
      score -= 10;
    } else {
      console.log('Terms of service found:', termsAnalysis.details);
    }

    // 4. Data Processing Notice Analysis (Real Detection)
    const dataProcessingAnalysis = this.analyzeDataProcessingNotice();
    const hasDataProcessingNotice = dataProcessingAnalysis.found;
    if (!hasDataProcessingNotice) {
      issues.push('No data processing notice found');
      recommendations.push('Add clear data processing notices explaining how personal data is handled');
      score -= 10;
    } else {
      console.log('Data processing notice found:', dataProcessingAnalysis.details);
    }

    // 5. Cookie Policy Analysis (Real Detection)
    const cookiePolicyAnalysis = this.analyzeCookiePolicy();
    const hasCookiePolicy = cookiePolicyAnalysis.found;
    if (!hasCookiePolicy) {
      issues.push('No cookie policy found');
      recommendations.push('Create a detailed cookie policy explaining all cookie types and purposes');
      score -= 10;
    } else {
      console.log('Cookie policy found:', cookiePolicyAnalysis.details);
    }

    // 6. Data Retention Policy Analysis (Real Detection)
    const retentionAnalysis = this.analyzeDataRetentionPolicy();
    const hasDataRetentionPolicy = retentionAnalysis.found;
    if (!hasDataRetentionPolicy) {
      issues.push('No data retention policy found');
      recommendations.push('Define and publish data retention policies with specific timeframes');
      score -= 10;
    } else {
      console.log('Data retention policy found:', retentionAnalysis.details);
    }

    // 7. User Consent Mechanism Analysis (Real Detection)
    const consentAnalysis = this.analyzeUserConsentMechanism();
    const hasUserConsentMechanism = consentAnalysis.found;
    if (!hasUserConsentMechanism) {
      issues.push('No user consent mechanism found');
      recommendations.push('Implement granular consent mechanisms for different data processing activities');
      score -= 10;
    } else {
      console.log('User consent mechanism found:', consentAnalysis.details);
    }

    // 8. Data Portability Analysis (Real Detection)
    const portabilityAnalysis = this.analyzeDataPortability();
    const hasDataPortability = portabilityAnalysis.found;
    if (!hasDataPortability) {
      issues.push('No data portability option found');
      recommendations.push('Provide data export functionality for users to download their personal data');
      score -= 10;
    } else {
      console.log('Data portability option found:', portabilityAnalysis.details);
    }

    // 9. Right to Erasure Analysis (Real Detection)
    const erasureAnalysis = this.analyzeRightToErasure();
    const hasRightToErasure = erasureAnalysis.found;
    if (!hasRightToErasure) {
      issues.push('No right to erasure mechanism found');
      recommendations.push('Implement data deletion functionality for users to request data removal');
      score -= 10;
    } else {
      console.log('Right to erasure mechanism found:', erasureAnalysis.details);
    }

    // 10. Data Minimization Analysis (Real Detection)
    const minimizationAnalysis = this.analyzeDataMinimization();
    const hasDataMinimization = minimizationAnalysis.compliant;
    if (!hasDataMinimization) {
      issues.push('Data minimization not properly implemented');
      recommendations.push('Ensure data collection is minimized and only necessary for specific purposes');
      score -= 10;
    } else {
      console.log('Data minimization analysis:', minimizationAnalysis.details);
    }

    // 11. Purpose Limitation Analysis (Real Detection)
    const purposeAnalysis = this.analyzePurposeLimitation();
    const hasPurposeLimitation = purposeAnalysis.compliant;
    if (!hasPurposeLimitation) {
      issues.push('Purpose limitation not properly implemented');
      recommendations.push('Clearly state the purpose of data collection and ensure it is lawful');
      score -= 10;
    } else {
      console.log('Purpose limitation analysis:', purposeAnalysis.details);
    }

    // 12. Lawful Basis Analysis (Real Detection)
    const lawfulBasisAnalysis = this.analyzeLawfulBasis();
    const hasLawfulBasis = lawfulBasisAnalysis.compliant;
    if (!hasLawfulBasis) {
      issues.push('No lawful basis for data processing found');
      recommendations.push('Ensure data processing is based on a valid legal basis (consent, contract, legitimate interest, etc.)');
      score -= 10;
    } else {
      console.log('Lawful basis analysis:', lawfulBasisAnalysis.details);
    }

    // 13. Third-party Tracking Analysis (Real Detection)
    const trackingAnalysis = this.analyzeThirdPartyTracking();
    if (trackingAnalysis.hasTracking && !trackingAnalysis.hasConsent) {
      issues.push('Third-party tracking detected without proper consent mechanism');
      recommendations.push('Implement consent mechanism for third-party tracking and analytics');
      score -= 15;
    } else if (trackingAnalysis.hasTracking) {
      console.log('Third-party tracking analysis:', trackingAnalysis.details);
    }

    // 14. Data Transfer Analysis (Real Detection)
    const transferAnalysis = this.analyzeDataTransfer();
    if (transferAnalysis.hasInternationalTransfer && !transferAnalysis.hasSafeguards) {
      issues.push('International data transfer detected without proper safeguards');
      recommendations.push('Implement appropriate safeguards for international data transfers');
      score -= 10;
    } else if (transferAnalysis.hasInternationalTransfer) {
      console.log('Data transfer analysis:', transferAnalysis.details);
    }

    // 15. Data Protection Officer Analysis (Real Detection)
    const dpoAnalysis = this.analyzeDataProtectionOfficer();
    const hasDPO = dpoAnalysis.found;
    if (!hasDPO) {
      issues.push('No Data Protection Officer contact information found');
      recommendations.push('Appoint and publish contact information for Data Protection Officer if required');
      score -= 5;
    } else {
      console.log('Data Protection Officer found:', dpoAnalysis.details);
    }

    // 16. Data Breach Notification Analysis (Real Detection)
    const breachAnalysis = this.analyzeDataBreachNotification();
    const hasBreachNotification = breachAnalysis.found;
    if (!hasBreachNotification) {
      issues.push('No data breach notification procedure found');
      recommendations.push('Implement and publish data breach notification procedures');
      score -= 5;
    } else {
      console.log('Data breach notification found:', breachAnalysis.details);
    }

    // 17. Children's Data Protection Analysis (Real Detection)
    const childrenAnalysis = this.analyzeChildrenDataProtection();
    if (childrenAnalysis.hasChildrenData && !childrenAnalysis.hasProtection) {
      issues.push('Children\'s data processing detected without proper protection measures');
      recommendations.push('Implement enhanced protection measures for children\'s data processing');
      score -= 10;
    } else if (childrenAnalysis.hasChildrenData) {
      console.log('Children\'s data protection analysis:', childrenAnalysis.details);
    }

    // 18. Automated Decision Making Analysis (Real Detection)
    const automatedAnalysis = this.analyzeAutomatedDecisionMaking();
    if (automatedAnalysis.hasAutomatedDecisions && !automatedAnalysis.hasSafeguards) {
      issues.push('Automated decision making detected without proper safeguards');
      recommendations.push('Implement safeguards for automated decision making including human review rights');
      score -= 10;
    } else if (automatedAnalysis.hasAutomatedDecisions) {
      console.log('Automated decision making analysis:', automatedAnalysis.details);
    }

    // 19. Data Subject Rights Analysis (Real Detection)
    const rightsAnalysis = this.analyzeDataSubjectRights();
    const hasDataSubjectRights = rightsAnalysis.found;
    if (!hasDataSubjectRights) {
      issues.push('Data subject rights not clearly communicated');
      recommendations.push('Clearly communicate all data subject rights including access, rectification, erasure, and objection');
      score -= 10;
    } else {
      console.log('Data subject rights found:', rightsAnalysis.details);
    }

    // 20. Privacy by Design Analysis (Real Detection)
    const privacyByDesignAnalysis = this.analyzePrivacyByDesign();
    const hasPrivacyByDesign = privacyByDesignAnalysis.compliant;
    if (!hasPrivacyByDesign) {
      issues.push('Privacy by design principles not implemented');
      recommendations.push('Implement privacy by design principles in all data processing activities');
      score -= 5;
    } else {
      console.log('Privacy by design analysis:', privacyByDesignAnalysis.details);
    }

    console.log('GDPR compliance analysis completed. Score:', score, 'Issues:', issues.length);

    return {
      hasCookieBanner,
      hasPrivacyPolicy,
      hasTermsOfService,
      hasDataProcessingNotice,
      hasCookiePolicy,
      hasDataRetentionPolicy,
      hasUserConsentMechanism,
      hasDataPortability,
      hasRightToErasure,
      hasDataMinimization,
      hasPurposeLimitation,
      hasLawfulBasis,
      score: Math.max(0, score),
      issues,
      recommendations,
      complianceLevel: this.determineComplianceLevel(score),
    };
  }

  private checkAccessibility() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    // Check for alt text on images
    const images = this.dom.window.document.querySelectorAll('img');
    const imagesWithAlt = Array.from(images).filter((img: Element) => {
      const imgElement = img as HTMLImageElement;
      const alt = imgElement.getAttribute('alt');
      return alt !== null && alt.trim().length > 0;
    });
    
    const imagesWithoutAlt = images.length - imagesWithAlt.length;
    if (imagesWithoutAlt > 0) {
      issues.push(`${imagesWithoutAlt} images missing alt text`);
      recommendations.push('Add descriptive alt text to all images for screen readers');
      score -= Math.min(15, imagesWithoutAlt * 2);
    }

    // Check for proper heading structure
    const headings = this.dom.window.document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    const headingLevels = Array.from(headings).map(h => parseInt(h.tagName.charAt(1)));
    
    let headingStructureIssues = 0;
    let previousLevel = 0;
    
    for (const level of headingLevels) {
      if (level > previousLevel + 1) {
        headingStructureIssues++;
      }
      previousLevel = level;
    }
    
    if (headingStructureIssues > 0) {
      issues.push('Improper heading hierarchy detected');
      recommendations.push('Use proper heading hierarchy (h1, h2, h3, etc.) without skipping levels');
      score -= 10;
    }
    
    if (headings.length === 0) {
      issues.push('No heading structure found');
      recommendations.push('Implement proper heading hierarchy for better document structure');
      score -= 15;
    }

    // Check for keyboard navigation
    const hasKeyboardNavigation = this.checkKeyboardNavigation();
    if (!hasKeyboardNavigation) {
      issues.push('Limited keyboard navigation support');
      recommendations.push('Ensure all interactive elements are keyboard accessible');
      score -= 15;
    }

    // Check for screen reader support
    const hasScreenReaderSupport = this.checkScreenReaderSupport();
    if (!hasScreenReaderSupport) {
      issues.push('Limited screen reader support');
      recommendations.push('Add ARIA labels and semantic HTML elements');
      score -= 15;
    }

    // Check for focus indicators
    const hasFocusIndicators = this.checkFocusIndicators();
    if (!hasFocusIndicators) {
      issues.push('No visible focus indicators');
      recommendations.push('Add visible focus indicators for keyboard navigation');
      score -= 10;
    }

    // Check for skip links
    const hasSkipLinks = this.checkSkipLinks();
    if (!hasSkipLinks) {
      issues.push('No skip navigation links');
      recommendations.push('Add skip links for keyboard users');
      score -= 10;
    }

    // Check for ARIA labels
    const hasARIALabels = this.checkARIALabels();
    if (!hasARIALabels) {
      issues.push('Missing ARIA labels');
      recommendations.push('Add ARIA labels to interactive elements');
      score -= 10;
    }

    // Check for semantic HTML
    const hasSemanticHTML = this.checkSemanticHTML();
    if (!hasSemanticHTML) {
      issues.push('Limited semantic HTML usage');
      recommendations.push('Use semantic HTML elements (nav, main, article, etc.)');
      score -= 10;
    }

    // Check for form labels
    const formInputs = this.dom.window.document.querySelectorAll('input, select, textarea');
    const inputsWithLabels = Array.from(formInputs).filter(input => {
      const inputElement = input as HTMLInputElement;
      const id = inputElement.id;
      if (id) {
        const label = this.dom.window.document.querySelector(`label[for="${id}"]`);
        if (label) return true;
      }
      
      // Check for parent label
      const parentLabel = inputElement.closest('label');
      if (parentLabel) return true;
      
      // Check for aria-label
      const ariaLabel = inputElement.getAttribute('aria-label');
      if (ariaLabel && ariaLabel.trim()) return true;
      
      return false;
    });
    
    const inputsWithoutLabels = formInputs.length - inputsWithLabels.length;
    if (inputsWithoutLabels > 0) {
      issues.push(`${inputsWithoutLabels} form inputs missing labels`);
      recommendations.push('Add proper labels to all form inputs');
      score -= Math.min(10, inputsWithoutLabels * 2);
    }

    // Check for color contrast (simplified)
    const hasContrastRatio = this.checkContrastRatio();
    if (!hasContrastRatio) {
      issues.push('Potential color contrast issues');
      recommendations.push('Ensure sufficient color contrast for text readability');
      score -= 10;
    }

    return {
      hasAltText: imagesWithAlt.length > 0 || images.length === 0,
      hasProperHeadings: headings.length > 0 && headingStructureIssues === 0,
      hasContrastRatio,
      hasKeyboardNavigation,
      hasScreenReaderSupport,
      hasFocusIndicators,
      hasSkipLinks,
      hasARIALabels,
      hasSemanticHTML,
      hasFormLabels: inputsWithLabels.length > 0,
      hasLanguageDeclaration: this.checkLanguageDeclaration(),
      hasErrorHandling: this.checkErrorHandling(),
      score: Math.max(0, score),
      issues,
      recommendations,
      wcagLevel: this.determineWCAGLevel(score),
    };
  }

  private checkSecurity() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 0; // Start from 0 and add points for good practices

    console.log('Starting comprehensive security analysis for:', this.url);

    // 1. Real HTTPS Analysis (Actual Detection) - CRITICAL: 25 points
    const httpsAnalysis = this.analyzeHTTPS();
    if (httpsAnalysis.enabled) {
      score += 25;
      console.log(' HTTPS enabled: +25 points');
    } else {
      issues.push('Website not using HTTPS');
      recommendations.push('Implement SSL/TLS encryption for secure data transmission');
      console.log(' HTTPS not enabled: 0 points');
    }

    // 2. Real Security Headers Analysis (Actual Detection) - IMPORTANT: Up to 20 points
    const securityHeadersAnalysis = this.analyzeSecurityHeaders();
    const headerScore = securityHeadersAnalysis.details.totalHeaders * 4; // 4 points per header
    score += headerScore;
    
    if (headerScore < 20) {
      issues.push('Missing important security headers');
      recommendations.push('Implement security headers: X-Frame-Options, X-Content-Type-Options, etc.');
    }
    console.log(` Security headers: +${headerScore} points (${securityHeadersAnalysis.details.totalHeaders}/5 headers)`);

    // 3. Real Content Security Policy Analysis (Actual Detection) - IMPORTANT: 15 points
    const cspAnalysis = this.analyzeContentSecurityPolicy();
    if (cspAnalysis.enabled) {
      score += 15;
      console.log(' CSP enabled: +15 points');
    } else {
      issues.push('No Content Security Policy found');
      recommendations.push('Implement Content Security Policy to prevent XSS attacks');
      console.log(' CSP not enabled: 0 points');
    }

    // 4. Real HSTS Analysis (Actual Detection) - IMPORTANT: 10 points
    const hstsAnalysis = this.analyzeHSTS();
    if (hstsAnalysis.enabled) {
      score += 10;
      console.log(' HSTS enabled: +10 points');
    } else {
      issues.push('No HTTP Strict Transport Security');
      recommendations.push('Enable HSTS header to enforce HTTPS connections');
      console.log(' HSTS not enabled: 0 points');
    }

    // 5. Real XSS Protection Analysis (Actual Detection) - IMPORTANT: 10 points
    const xssAnalysis = this.analyzeXSSProtection();
    if (xssAnalysis.protected) {
      score += 10;
      console.log(' XSS protection: +10 points');
    } else {
      issues.push(xssAnalysis.issues.join(', '));
      recommendations.push('Implement XSS protection mechanisms');
      console.log(' XSS protection: 0 points');
    }

    // 6. Real CSRF Protection Analysis (Actual Detection) - MODERATE: 8 points
    const csrfAnalysis = this.analyzeCSRFProtection();
    if (csrfAnalysis.protected) {
      score += 8;
      console.log(' CSRF protection: +8 points');
    } else {
      issues.push('No CSRF protection detected');
      recommendations.push('Implement CSRF tokens or other CSRF protection mechanisms');
      console.log(' CSRF protection: 0 points');
    }

    // 7. Real Input Validation Analysis (Actual Detection) - MODERATE: 6 points
    const inputValidationAnalysis = this.analyzeInputValidation();
    if (inputValidationAnalysis.validated) {
      score += 6;
      console.log(' Input validation: +6 points');
    } else {
      issues.push(inputValidationAnalysis.issues.join(', '));
      recommendations.push('Implement proper input validation for all user inputs');
      console.log(' Input validation: 0 points');
    }

    // 8. Real Output Encoding Analysis (Actual Detection) - MODERATE: 6 points
    const outputEncodingAnalysis = this.analyzeOutputEncoding();
    if (outputEncodingAnalysis.encoded) {
      score += 6;
      console.log(' Output encoding: +6 points');
    } else {
      issues.push(outputEncodingAnalysis.issues.join(', '));
      recommendations.push('Ensure all output is properly encoded to prevent XSS');
      console.log(' Output encoding: 0 points');
    }

    // 9. Real Session Management Analysis (Actual Detection) - MODERATE: 6 points
    const sessionAnalysis = this.analyzeSessionManagement();
    if (sessionAnalysis.secure) {
      score += 6;
      console.log(' Session management: +6 points');
    } else {
      issues.push(sessionAnalysis.issues.join(', '));
      recommendations.push('Implement secure session management and secure cookie handling');
      console.log(' Session management: 0 points');
    }

    // 10. Real Cookie Security Analysis (Actual Detection) - MODERATE: 6 points
    const cookieAnalysis = this.analyzeCookieSecurity();
    if (cookieAnalysis.secure) {
      score += 6;
      console.log(' Cookie security: +6 points');
    } else {
      issues.push(cookieAnalysis.issues.join(', '));
      recommendations.push('Set Secure and HttpOnly flags for cookies');
      console.log(' Cookie security: 0 points');
    }

    // 11. Real Error Handling Analysis (Actual Detection) - MODERATE: 4 points
    const errorHandlingAnalysis = this.analyzeErrorHandling();
    if (errorHandlingAnalysis.secure) {
      score += 4;
      console.log(' Error handling: +4 points');
    } else {
      issues.push(errorHandlingAnalysis.issues.join(', '));
      recommendations.push('Ensure proper error handling and logging to prevent sensitive information exposure');
      console.log(' Error handling: 0 points');
    }

    // 12. Real Sensitive Information Exposure Analysis (Actual Detection) - CRITICAL: -10 points if exposed
    const sensitiveInfoAnalysis = this.analyzeSensitiveInformation();
    if (sensitiveInfoAnalysis.exposed) {
      issues.push(sensitiveInfoAnalysis.issues.join(', '));
      recommendations.push('Remove or properly secure sensitive information from HTML source');
      score -= 10;
      console.log(' Sensitive info exposed: -10 points');
    } else {
      console.log(' No sensitive info exposed: 0 points');
    }

    // 13. Real Open Redirect Analysis (Actual Detection) - CRITICAL: -10 points if vulnerable
    const openRedirectAnalysis = this.analyzeOpenRedirects();
    if (openRedirectAnalysis.vulnerable) {
      issues.push(openRedirectAnalysis.issues.join(', '));
      recommendations.push('Validate and sanitize all redirect URLs');
      score -= 10;
      console.log(' Open redirects: -10 points');
    } else {
      console.log(' No open redirects: 0 points');
    }

    // 14. Real SQL Injection Analysis (Actual Detection) - CRITICAL: -10 points if vulnerable
    const sqlInjectionAnalysis = this.analyzeSQLInjection();
    if (sqlInjectionAnalysis.vulnerable) {
      issues.push(sqlInjectionAnalysis.issues.join(', '));
      recommendations.push('Implement proper SQL injection protection');
      score -= 10;
      console.log(' SQL injection: -10 points');
    } else {
      console.log(' No SQL injection: 0 points');
    }

    // 15. Real Clickjacking Analysis (Actual Detection) - MODERATE: -5 points if vulnerable
    const clickjackingAnalysis = this.analyzeClickjacking();
    if (clickjackingAnalysis.vulnerable) {
      issues.push(clickjackingAnalysis.issues.join(', '));
      recommendations.push('Implement clickjacking protection');
      score -= 5;
      console.log(' Clickjacking: -5 points');
    } else {
      console.log(' No clickjacking: 0 points');
    }

    // 16. Real Information Disclosure Analysis (Actual Detection) - MODERATE: -5 points if disclosed
    const infoDisclosureAnalysis = this.analyzeInformationDisclosure();
    if (infoDisclosureAnalysis.disclosed) {
      issues.push(infoDisclosureAnalysis.issues.join(', '));
      recommendations.push('Remove sensitive information from responses');
      score -= 5;
      console.log(' Info disclosure: -5 points');
    } else {
      console.log(' No info disclosure: 0 points');
    }

    // 17. Real Authentication Analysis (Actual Detection) - MODERATE: 4 points
    const authAnalysis = this.analyzeAuthentication();
    if (authAnalysis.secure) {
      score += 4;
      console.log(' Authentication: +4 points');
    } else {
      issues.push(authAnalysis.issues.join(', '));
      recommendations.push('Implement secure authentication mechanisms');
      console.log(' Authentication: 0 points');
    }

    // 18. Real Authorization Analysis (Actual Detection) - MODERATE: 4 points
    const authorizationAnalysis = this.analyzeAuthorization();
    if (authorizationAnalysis.secure) {
      score += 4;
      console.log(' Authorization: +4 points');
    } else {
      issues.push(authorizationAnalysis.issues.join(', '));
      recommendations.push('Implement proper authorization controls');
      console.log(' Authorization: 0 points');
    }

    // 19. Real Data Encryption Analysis (Actual Detection) - MODERATE: 4 points
    const encryptionAnalysis = this.analyzeDataEncryption();
    if (encryptionAnalysis.encrypted) {
      score += 4;
      console.log(' Data encryption: +4 points');
    } else {
      issues.push(encryptionAnalysis.issues.join(', '));
      recommendations.push('Implement data encryption for sensitive information');
      console.log(' Data encryption: 0 points');
    }

    // 20. Real Third-Party Security Analysis (Actual Detection) - MODERATE: 3 points
    const thirdPartySecurityAnalysis = this.analyzeThirdPartySecurity();
    if (thirdPartySecurityAnalysis.secure) {
      score += 3;
      console.log(' Third-party security: +3 points');
    } else {
      issues.push(thirdPartySecurityAnalysis.issues.join(', '));
      recommendations.push('Review and secure third-party integrations');
      console.log(' Third-party security: 0 points');
    }

    // 21. Real API Security Analysis (Actual Detection) - MODERATE: 3 points
    const apiSecurityAnalysis = this.analyzeAPISecurity();
    if (apiSecurityAnalysis.secure) {
      score += 3;
      console.log(' API security: +3 points');
    } else {
      issues.push(apiSecurityAnalysis.issues.join(', '));
      recommendations.push('Implement API security best practices');
      console.log(' API security: 0 points');
    }

    // 22. Real File Upload Security Analysis (Actual Detection) - MODERATE: 3 points
    const fileUploadAnalysis = this.analyzeFileUploadSecurity();
    if (fileUploadAnalysis.secure) {
      score += 3;
      console.log(' File upload security: +3 points');
    } else {
      issues.push(fileUploadAnalysis.issues.join(', '));
      recommendations.push('Implement secure file upload mechanisms');
      console.log(' File upload security: 0 points');
    }

    // 23. Real Business Logic Analysis (Actual Detection) - MODERATE: 3 points
    const businessLogicAnalysis = this.analyzeBusinessLogic();
    if (businessLogicAnalysis.secure) {
      score += 3;
      console.log(' Business logic: +3 points');
    } else {
      issues.push(businessLogicAnalysis.issues.join(', '));
      recommendations.push('Review and secure business logic');
      console.log(' Business logic: 0 points');
    }

    // 24. Real Security Misconfiguration Analysis (Actual Detection) - MODERATE: 3 points
    const misconfigAnalysis = this.analyzeSecurityMisconfiguration();
    if (misconfigAnalysis.secure) {
      score += 3;
      console.log(' Security config: +3 points');
    } else {
      issues.push(misconfigAnalysis.issues.join(', '));
      recommendations.push('Fix security misconfigurations');
      console.log(' Security config: 0 points');
    }

    // 25. Real Vulnerable Components Analysis (Actual Detection) - CRITICAL: -10 points if vulnerable
    const vulnerableComponentsAnalysis = this.analyzeVulnerableComponents();
    if (vulnerableComponentsAnalysis.vulnerable) {
      issues.push(vulnerableComponentsAnalysis.issues.join(', '));
      recommendations.push('Update vulnerable components and dependencies');
      score -= 10;
      console.log(' Vulnerable components: -10 points');
    } else {
      console.log(' No vulnerable components: 0 points');
    }

    // Ensure score doesn't go below 0 or above 100
    score = Math.max(0, Math.min(100, score));
    
    console.log(` Security analysis completed. Total score: ${score}/100`);
    console.log(` Issues found: ${issues.length}, Recommendations: ${recommendations.length}`);

    return {
      hasHTTPS: httpsAnalysis.enabled,
      hasSecurityHeaders: securityHeadersAnalysis.optimized,
      hasCSP: cspAnalysis.enabled,
      hasHSTS: hstsAnalysis.enabled,
      hasXFrameOptions: securityHeadersAnalysis.details.hasXFrameOptions,
      hasXContentTypeOptions: securityHeadersAnalysis.details.hasXContentTypeOptions,
      hasReferrerPolicy: securityHeadersAnalysis.details.hasReferrerPolicy,
      hasPermissionsPolicy: securityHeadersAnalysis.details.hasPermissionsPolicy,
      hasSecureCookies: cookieAnalysis.secure,
      hasCSRFProtection: csrfAnalysis.protected,
      hasInputValidation: inputValidationAnalysis.validated,
      hasOutputEncoding: outputEncodingAnalysis.encoded,
      hasSessionManagement: sessionAnalysis.secure,
      hasErrorHandling: errorHandlingAnalysis.secure,
      score: score,
      issues,
      recommendations,
      securityLevel: this.determineSecurityLevel(score),
    };
  }

  private checkPerformance() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 0; // Start from 0 and add points for good practices

    console.log('Starting comprehensive performance analysis for:', this.url);

    // 1. Real Load Time Analysis (Actual Measurement) - CRITICAL: Up to 25 points
    const loadTimeSeconds = this.loadTime / 1000;
    console.log('Real load time:', loadTimeSeconds, 'seconds');
    
    if (this.loadTime < 1000) {
      score += 25;
      console.log(' Excellent load time (<1s): +25 points');
    } else if (this.loadTime < 2000) {
      score += 20;
      console.log(' Good load time (<2s): +20 points');
    } else if (this.loadTime < 3000) {
      score += 15;
      console.log(' Acceptable load time (<3s): +15 points');
    } else if (this.loadTime < 5000) {
      score += 10;
      console.log(' Slow load time (<5s): +10 points');
      issues.push(`Slow page load time: ${loadTimeSeconds.toFixed(2)}s`);
      recommendations.push('Optimize page load time to under 3 seconds for better user experience');
    } else {
      console.log(' Very slow load time (>5s): 0 points');
      issues.push(`Very slow page load time: ${loadTimeSeconds.toFixed(2)}s`);
      recommendations.push('Urgently optimize page load time for better user experience');
    }

    // 2. Real Page Size Analysis (Actual Measurement)
    const pageSizeKB = Math.round(this.pageSize / 1024);
    const pageSizeMB = (this.pageSize / (1024 * 1024)).toFixed(2);
    console.log('Real page size:', pageSizeKB, 'KB (', pageSizeMB, 'MB)');
    
    if (this.pageSize > 5000000) { // 5MB
      issues.push(`Large page size: ${pageSizeMB}MB`);
      recommendations.push('Reduce page size through optimization and compression');
      score -= 15;
    } else if (this.pageSize > 2000000) { // 2MB
      issues.push(`Moderate page size: ${pageSizeMB}MB`);
      recommendations.push('Consider reducing page size for better performance');
      score -= 10;
    } else if (this.pageSize < 500000) { // 500KB
      score += 5;
    }

    // 3. Real Image Analysis (Actual Detection)
    const imageAnalysis = this.analyzeImages();
    if (!imageAnalysis.optimized) {
      issues.push(imageAnalysis.issues.join(', '));
      recommendations.push('Optimize images using modern formats (WebP, AVIF) and proper sizing');
      score -= 15;
    } else {
      console.log('Image analysis:', imageAnalysis.details);
    }

    // 4. Real Resource Analysis (Actual Detection)
    const resourceAnalysis = this.analyzeResources();
    if (!resourceAnalysis.optimized) {
      issues.push(resourceAnalysis.issues.join(', '));
      recommendations.push('Optimize resources through minification, compression, and bundling');
      score -= 15;
    } else {
      console.log('Resource analysis:', resourceAnalysis.details);
    }

    // 5. Real Compression Analysis (Actual Detection)
    const compressionAnalysis = this.analyzeCompression();
    if (!compressionAnalysis.enabled) {
      issues.push('No compression detected');
      recommendations.push('Enable GZIP/Brotli compression to reduce file sizes');
      score -= 15;
    } else {
      console.log('Compression analysis:', compressionAnalysis.details);
    }

    // 6. Real Caching Analysis (Actual Detection)
    const cachingAnalysis = this.analyzeCaching();
    if (!cachingAnalysis.enabled) {
      issues.push('No caching headers detected');
      recommendations.push('Implement proper caching strategies for static resources');
      score -= 10;
    } else {
      console.log('Caching analysis:', cachingAnalysis.details);
    }

    // 7. Real CDN Analysis (Actual Detection)
    const cdnAnalysis = this.analyzeCDN();
    if (!cdnAnalysis.used) {
      issues.push('No CDN detected');
      recommendations.push('Consider using a CDN for better global performance');
      score -= 10;
    } else {
      console.log('CDN analysis:', cdnAnalysis.details);
    }

    // 8. Real Render-Blocking Analysis (Actual Detection)
    const renderBlockingAnalysis = this.analyzeRenderBlocking();
    if (renderBlockingAnalysis.count > 0) {
      issues.push(`${renderBlockingAnalysis.count} render-blocking resources detected`);
      recommendations.push('Optimize critical rendering path by deferring non-critical resources');
      score -= 10;
    } else {
      console.log('Render-blocking analysis:', renderBlockingAnalysis.details);
    }

    // 9. Real JavaScript Analysis (Actual Detection)
    const javascriptAnalysis = this.analyzeJavaScript();
    if (!javascriptAnalysis.optimized) {
      issues.push(javascriptAnalysis.issues.join(', '));
      recommendations.push('Optimize JavaScript loading and execution');
      score -= 10;
    } else {
      console.log('JavaScript analysis:', javascriptAnalysis.details);
    }

    // 10. Real CSS Analysis (Actual Detection)
    const cssAnalysis = this.analyzeCSS();
    if (!cssAnalysis.optimized) {
      issues.push(cssAnalysis.issues.join(', '));
      recommendations.push('Optimize CSS delivery and reduce unused styles');
      score -= 10;
    } else {
      console.log('CSS analysis:', cssAnalysis.details);
    }

    // 11. Real Font Analysis (Actual Detection)
    const fontAnalysis = this.analyzeFonts();
    if (!fontAnalysis.optimized) {
      issues.push(fontAnalysis.issues.join(', '));
      recommendations.push('Optimize font loading and use font-display: swap');
      score -= 10;
    } else {
      console.log('Font analysis:', fontAnalysis.details);
    }

    // 12. Real Third-Party Analysis (Actual Detection)
    const thirdPartyAnalysis = this.analyzeThirdPartyResources();
    if (thirdPartyAnalysis.hasExcessiveThirdParty) {
      issues.push(`${thirdPartyAnalysis.count} third-party resources detected`);
      recommendations.push('Reduce third-party resources and load them asynchronously');
      score -= 10;
    } else {
      console.log('Third-party analysis:', thirdPartyAnalysis.details);
    }

    // 13. Real HTTP/2 Analysis (Actual Detection)
    const http2Analysis = this.analyzeHTTP2();
    if (!http2Analysis.enabled) {
      issues.push('HTTP/2 not detected');
      recommendations.push('Upgrade to HTTP/2 for better multiplexing and performance');
      score -= 5;
    } else {
      console.log('HTTP/2 analysis:', http2Analysis.details);
    }

    // 14. Real Security Headers Analysis (Performance Impact)
    const securityHeadersAnalysis = this.analyzeSecurityHeaders();
    if (!securityHeadersAnalysis.optimized) {
      issues.push('Security headers may impact performance');
      recommendations.push('Optimize security headers for better performance');
      score -= 5;
    } else {
      console.log('Security headers analysis:', securityHeadersAnalysis.details);
    }

    // 15. Real Core Web Vitals Calculation (Based on Real Data)
    const coreWebVitals = this.calculateRealCoreWebVitals();
    
    // First Contentful Paint (FCP)
    if (coreWebVitals.fcp > 1800) {
      issues.push(`First Contentful Paint: ${coreWebVitals.fcp}ms (poor)`);
      score -= 10;
    } else if (coreWebVitals.fcp > 1000) {
      issues.push(`First Contentful Paint: ${coreWebVitals.fcp}ms (needs improvement)`);
      score -= 5;
    }

    // Largest Contentful Paint (LCP)
    if (coreWebVitals.lcp > 4000) {
      issues.push(`Largest Contentful Paint: ${coreWebVitals.lcp}ms (poor)`);
      score -= 10;
    } else if (coreWebVitals.lcp > 2500) {
      issues.push(`Largest Contentful Paint: ${coreWebVitals.lcp}ms (needs improvement)`);
      score -= 5;
    }

    // Cumulative Layout Shift (CLS)
    if (coreWebVitals.cls > 0.25) {
      issues.push(`Cumulative Layout Shift: ${coreWebVitals.cls.toFixed(3)} (poor)`);
      score -= 10;
    } else if (coreWebVitals.cls > 0.1) {
      issues.push(`Cumulative Layout Shift: ${coreWebVitals.cls.toFixed(3)} (needs improvement)`);
      score -= 5;
    }

    // First Input Delay (FID)
    if (coreWebVitals.fid > 300) {
      issues.push(`First Input Delay: ${coreWebVitals.fid}ms (poor)`);
      score -= 10;
    } else if (coreWebVitals.fid > 100) {
      issues.push(`First Input Delay: ${coreWebVitals.fid}ms (needs improvement)`);
      score -= 5;
    }

    // 16. Real Performance Budget Analysis
    const performanceBudget = this.analyzePerformanceBudget();
    if (!performanceBudget.withinBudget) {
      issues.push(`Performance budget exceeded: ${performanceBudget.details}`);
      recommendations.push('Implement performance budgets to maintain fast loading times');
      score -= 10;
    } else {
      console.log('Performance budget analysis:', performanceBudget.details);
    }

    // 17. Real Mobile Performance Analysis
    const mobileAnalysis = this.analyzeMobilePerformance();
    if (!mobileAnalysis.optimized) {
      issues.push(mobileAnalysis.issues.join(', '));
      recommendations.push('Optimize for mobile performance and reduce mobile-specific issues');
      score -= 10;
    } else {
      console.log('Mobile performance analysis:', mobileAnalysis.details);
    }

    // 18. Real Resource Loading Analysis
    const resourceLoadingAnalysis = this.analyzeResourceLoading();
    if (!resourceLoadingAnalysis.optimized) {
      issues.push(resourceLoadingAnalysis.issues.join(', '));
      recommendations.push('Optimize resource loading order and priorities');
      score -= 10;
    } else {
      console.log('Resource loading analysis:', resourceLoadingAnalysis.details);
    }

    // 19. Real Database Query Analysis (if applicable)
    const databaseAnalysis = this.analyzeDatabasePerformance();
    if (databaseAnalysis.hasIssues) {
      issues.push(databaseAnalysis.issues.join(', '));
      recommendations.push('Optimize database queries and implement caching');
      score -= 5;
    } else {
      console.log('Database analysis:', databaseAnalysis.details);
    }

    // 20. Real Server Response Analysis
    const serverAnalysis = this.analyzeServerPerformance();
    if (!serverAnalysis.optimized) {
      issues.push(serverAnalysis.issues.join(', '));
      recommendations.push('Optimize server response times and implement caching');
      score -= 10;
    } else {
      console.log('Server performance analysis:', serverAnalysis.details);
    }

    // 21. NEW: Real Network Analysis (Actual Detection)
    const networkAnalysis = this.analyzeNetworkPerformance();
    if (!networkAnalysis.optimized) {
      issues.push(networkAnalysis.issues.join(', '));
      recommendations.push('Optimize network requests and reduce round trips');
      score -= 10;
    } else {
      console.log('Network analysis:', networkAnalysis.details);
    }

    // 22. NEW: Real DOM Analysis (Actual Detection)
    const domAnalysis = this.analyzeDOMPerformance();
    if (!domAnalysis.optimized) {
      issues.push(domAnalysis.issues.join(', '));
      recommendations.push('Optimize DOM structure and reduce complexity');
      score -= 10;
    } else {
      console.log('DOM analysis:', domAnalysis.details);
    }

    // 23. NEW: Real Event Handler Analysis (Actual Detection)
    const eventHandlerAnalysis = this.analyzeEventHandlerPerformance();
    if (!eventHandlerAnalysis.optimized) {
      issues.push(eventHandlerAnalysis.issues.join(', '));
      recommendations.push('Optimize event handlers and reduce event listeners');
      score -= 10;
    } else {
      console.log('Event handler analysis:', eventHandlerAnalysis.details);
    }

    // 24. NEW: Real Animation Analysis (Actual Detection)
    const animationAnalysis = this.analyzeAnimationPerformance();
    if (!animationAnalysis.optimized) {
      issues.push(animationAnalysis.issues.join(', '));
      recommendations.push('Optimize animations and use hardware acceleration');
      score -= 10;
    } else {
      console.log('Animation analysis:', animationAnalysis.details);
    }

    // 25. NEW: Real Media Analysis (Actual Detection)
    const mediaAnalysis = this.analyzeMediaPerformance();
    if (!mediaAnalysis.optimized) {
      issues.push(mediaAnalysis.issues.join(', '));
      recommendations.push('Optimize media loading and use appropriate formats');
      score -= 10;
    } else {
      console.log('Media analysis:', mediaAnalysis.details);
    }

    // 26. NEW: Real API Performance Analysis (Actual Detection)
    const apiAnalysis = this.analyzeAPIPerformance();
    if (!apiAnalysis.optimized) {
      issues.push(apiAnalysis.issues.join(', '));
      recommendations.push('Optimize API calls and implement caching');
      score -= 10;
    } else {
      console.log('API performance analysis:', apiAnalysis.details);
    }

    // 27. NEW: Real Memory Usage Analysis (Actual Detection)
    const memoryAnalysis = this.analyzeMemoryPerformance();
    if (!memoryAnalysis.optimized) {
      issues.push(memoryAnalysis.issues.join(', '));
      recommendations.push('Optimize memory usage and reduce memory leaks');
      score -= 10;
    } else {
      console.log('Memory analysis:', memoryAnalysis.details);
    }

    // 28. NEW: Real Accessibility Performance Analysis (Actual Detection)
    const accessibilityPerformanceAnalysis = this.analyzeAccessibilityPerformance();
    if (!accessibilityPerformanceAnalysis.optimized) {
      issues.push(accessibilityPerformanceAnalysis.issues.join(', '));
      recommendations.push('Optimize accessibility features for better performance');
      score -= 5;
    } else {
      console.log('Accessibility performance analysis:', accessibilityPerformanceAnalysis.details);
    }

    // 29. NEW: Real SEO Performance Analysis (Actual Detection)
    const seoPerformanceAnalysis = this.analyzeSEOPerformance();
    if (!seoPerformanceAnalysis.optimized) {
      issues.push(seoPerformanceAnalysis.issues.join(', '));
      recommendations.push('Optimize SEO elements for better performance');
      score -= 5;
    } else {
      console.log('SEO performance analysis:', seoPerformanceAnalysis.details);
    }

    // 30. NEW: Real Progressive Web App Analysis (Actual Detection)
    const pwaAnalysis = this.analyzePWAPerformance();
    if (!pwaAnalysis.optimized) {
      issues.push(pwaAnalysis.issues.join(', '));
      recommendations.push('Implement PWA features for better performance');
      score -= 5;
    } else {
      console.log('PWA analysis:', pwaAnalysis.details);
    }

    console.log('Performance analysis completed. Score:', score, 'Issues:', issues.length);

    return {
      loadTime: this.loadTime,
      pageSize: this.pageSize,
      imageOptimization: imageAnalysis.optimized,
      minification: resourceAnalysis.optimized,
      compression: compressionAnalysis.enabled,
      caching: cachingAnalysis.enabled,
      cdnUsage: cdnAnalysis.used,
      renderBlockingResources: renderBlockingAnalysis.count,
      unusedCSS: cssAnalysis.unusedCSS,
      unusedJS: javascriptAnalysis.unusedJS,
      firstContentfulPaint: coreWebVitals.fcp,
      largestContentfulPaint: coreWebVitals.lcp,
      cumulativeLayoutShift: coreWebVitals.cls,
      firstInputDelay: coreWebVitals.fid,
      score: Math.max(0, score),
      issues,
      recommendations,
      performanceGrade: this.determinePerformanceGrade(score),
    };
  }

  private checkSEO() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    // Check for meta title
    const hasMetaTitle = this.checkMetaTitle();
    if (!hasMetaTitle.valid) {
      issues.push(hasMetaTitle.issue || 'No meta title found');
      recommendations.push('Add a descriptive meta title (50-60 characters)');
      score -= 15;
    }

    // Check for meta description
    const hasMetaDescription = this.checkMetaDescription();
    if (!hasMetaDescription.valid) {
      issues.push(hasMetaDescription.issue || 'No meta description found');
      recommendations.push('Add a compelling meta description (150-160 characters)');
      score -= 15;
    }

    // Check for Open Graph
    const hasOpenGraph = this.checkOpenGraph();
    if (!hasOpenGraph.valid) {
      issues.push(hasOpenGraph.issues.join(', '));
      recommendations.push('Add Open Graph tags for better social media sharing');
      score -= 10;
    }

    // Check for Twitter Card
    const hasTwitterCard = this.checkTwitterCard();
    if (!hasTwitterCard.valid) {
      issues.push(hasTwitterCard.issues.join(', '));
      recommendations.push('Add Twitter Card tags for better Twitter sharing');
      score -= 10;
    }

    // Check for structured data
    const hasStructuredData = this.checkStructuredData();
    if (!hasStructuredData.valid) {
      issues.push(hasStructuredData.issues.join(', '));
      recommendations.push('Implement structured data (JSON-LD) for better search results');
      score -= 10;
    }

    // Check for sitemap
    const hasSitemap = this.checkSitemap();
    if (!hasSitemap.valid) {
      issues.push(hasSitemap.issues.join(', '));
      recommendations.push('Create and submit a sitemap to search engines');
      score -= 10;
    }

    // Check for robots.txt
    const hasRobotsTxt = this.checkRobotsTxt();
    if (!hasRobotsTxt.valid) {
      issues.push(hasRobotsTxt.issues.join(', '));
      recommendations.push('Create a robots.txt file to guide search engine crawlers');
      score -= 10;
    }

    // Check for canonical URL
    const hasCanonicalUrl = this.checkCanonicalUrl();
    if (!hasCanonicalUrl.valid) {
      issues.push(hasCanonicalUrl.issues.join(', '));
      recommendations.push('Add canonical URLs to prevent duplicate content issues');
      score -= 10;
    }

    // Check for internal linking
    const hasInternalLinking = this.checkInternalLinking();
    if (!hasInternalLinking.valid) {
      issues.push(hasInternalLinking.issues.join(', '));
      recommendations.push('Implement strategic internal linking for better SEO');
      score -= 10;
    }

    // Check for heading structure
    const headingStructure = this.checkHeadingStructure();
    if (!headingStructure.valid) {
      issues.push(headingStructure.issues.join(', '));
      recommendations.push('Improve heading structure for better content organization');
      score -= 10;
    }

    // Check for image optimization
    const imageSEO = this.checkImageSEO();
    if (!imageSEO.valid) {
      issues.push(imageSEO.issues.join(', '));
      recommendations.push('Optimize images with proper alt text and file names');
      score -= 10;
    }

    // Check for mobile optimization
    const hasMobileOptimization = this.checkMobileOptimization();
    if (!hasMobileOptimization) {
      issues.push('Mobile optimization not implemented');
      recommendations.push('Ensure responsive design and fast loading on mobile devices');
      score -= 10;
    }

    // Check for SSL
    const hasSSL = this.checkSSL();
    if (!hasSSL) {
      issues.push('SSL not implemented');
      recommendations.push('Ensure all resources are served over HTTPS');
      score -= 10;
    }

    return {
      hasMetaTitle: hasMetaTitle.valid,
      hasMetaDescription: hasMetaDescription.valid,
      hasOpenGraph: hasOpenGraph.valid,
      hasTwitterCard: hasTwitterCard.valid,
      hasStructuredData: hasStructuredData.valid,
      hasSitemap: hasSitemap.valid,
      hasRobotsTxt: hasRobotsTxt.valid,
      hasCanonicalUrl: hasCanonicalUrl.valid,
      hasInternalLinking: hasInternalLinking.valid,
      hasHeadingStructure: headingStructure.valid,
      hasImageOptimization: imageSEO.valid,
      hasMobileOptimization,
      hasPageSpeed: true, // Assuming a baseline for page speed
      hasSSL,
      score: Math.max(0, score),
      issues,
      recommendations,
      seoScore: score,
    };
  }

  private calculateOverall(results: any, options: ScanOptions) {
    const categories = ['gdpr', 'accessibility', 'security', 'performance', 'seo'];
    const enabledCategories = categories.filter(cat => options[cat as keyof ScanOptions] as boolean);
    
    if (enabledCategories.length === 0) {
      return {
        score: 0,
        grade: 'F' as const,
        totalIssues: 0,
        recommendations: ['No scan categories selected'],
        priorityIssues: [],
        complianceStatus: 'critical' as const
      };
    }

    let totalScore = 0;
    let totalIssues = 0;
    let allRecommendations: string[] = [];
    let priorityIssues: string[] = [];

    enabledCategories.forEach(category => {
      const result = results[category];
      if (result) {
        totalScore += result.score;
        totalIssues += result.issues.length;
        allRecommendations.push(...result.recommendations);
        
        // Add critical issues to priority list
        if (result.score < 50) {
          priorityIssues.push(`${category.toUpperCase()}: ${result.issues[0] || 'Critical issues found'}`);
        }
      }
    });

    const averageScore = Math.round(totalScore / enabledCategories.length);
    
    // Determine grade based on average score
    let grade: 'A' | 'B' | 'C' | 'D' | 'F';
    if (averageScore >= 90) grade = 'A';
    else if (averageScore >= 80) grade = 'B';
    else if (averageScore >= 70) grade = 'C';
    else if (averageScore >= 60) grade = 'D';
    else grade = 'F';

    // Determine compliance status
    let complianceStatus: 'excellent' | 'good' | 'fair' | 'poor' | 'critical';
    if (averageScore >= 90) complianceStatus = 'excellent';
    else if (averageScore >= 80) complianceStatus = 'good';
    else if (averageScore >= 70) complianceStatus = 'fair';
    else if (averageScore >= 50) complianceStatus = 'poor';
    else complianceStatus = 'critical';

    // Add general recommendations based on scan coverage
    if (enabledCategories.length < 3) {
      allRecommendations.push('Consider running a full scan to get comprehensive compliance insights');
    }

    if (priorityIssues.length === 0 && averageScore < 80) {
      priorityIssues.push('Review and address the identified issues to improve compliance score');
    }

    return {
      score: averageScore,
      grade,
      totalIssues,
      recommendations: allRecommendations.slice(0, 10), // Limit to top 10 recommendations
      priorityIssues: priorityIssues.slice(0, 5), // Limit to top 5 priority issues
      complianceStatus
    };
  }

  // Helper methods for GDPR checks
  private findCookieBanner(): Element | null {
    const selectors = [
      '[class*="cookie"]',
      '[class*="consent"]',
      '[id*="cookie"]',
      '[id*="consent"]',
      '[class*="gdpr"]',
      '[id*="gdpr"]',
      '[class*="banner"]',
      '[id*="banner"]',
      '[class*="notice"]',
      '[id*="notice"]',
      '[class*="popup"]',
      '[id*="popup"]',
      '[class*="modal"]',
      '[id*="modal"]',
      '[class*="toast"]',
      '[id*="toast"]',
    ];

    for (const selector of selectors) {
      const elements = this.dom.window.document.querySelectorAll(selector);
      for (const element of Array.from(elements)) {
        const text = element.textContent?.toLowerCase() || '';
        const html = element.innerHTML.toLowerCase();
        
        // Check for cookie-related keywords
        const cookieKeywords = ['cookie', 'consent', 'accept', 'gdpr', 'privacy', 'tracking', 'analytics'];
        const hasCookieKeywords = cookieKeywords.some(keyword => 
          text.includes(keyword) || html.includes(keyword)
        );
        
        // Check for action buttons
        const hasActionButtons = element.querySelectorAll('button, input[type="button"], input[type="submit"], a[href="#"]').length > 0;
        
        // Check if element is visible (simplified check)
        const style = this.dom.window.getComputedStyle(element);
        const isVisible = style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
        
        if (hasCookieKeywords && (hasActionButtons || isVisible)) {
          return element;
        }
      }
    }

    return null;
  }

  private findPrivacyPolicy(): boolean {
    // Check for privacy policy links
    const privacySelectors = [
      'a[href*="privacy"]',
      'a[href*="policy"]',
      'a[href*="privacy-policy"]',
      'a[href*="privacy_policy"]',
      'a[href*="privacy-policy.html"]',
      'a[href*="privacy-policy.php"]',
      'a[href*="privacy-policy.asp"]',
      'a[href*="privacy-policy.aspx"]',
    ];

    for (const selector of privacySelectors) {
      const links = this.dom.window.document.querySelectorAll(selector);
      if (links.length > 0) return true;
    }

    // Check for privacy policy text
    const textContent = this.html.toLowerCase();
    const privacyTexts = [
      'privacy policy',
      'privacy notice',
      'privacy statement',
      'data protection policy',
      'information privacy',
    ];

    return privacyTexts.some(text => textContent.includes(text));
  }

  private findTermsOfService(): boolean {
    // Check for terms links
    const termsSelectors = [
      'a[href*="terms"]',
      'a[href*="service"]',
      'a[href*="conditions"]',
      'a[href*="terms-of-service"]',
      'a[href*="terms_of_service"]',
      'a[href*="terms-and-conditions"]',
      'a[href*="terms_conditions"]',
    ];

    for (const selector of termsSelectors) {
      const links = this.dom.window.document.querySelectorAll(selector);
      if (links.length > 0) return true;
    }

    // Check for terms text
    const textContent = this.html.toLowerCase();
    const termsTexts = [
      'terms of service',
      'terms and conditions',
      'terms & conditions',
      'user agreement',
      'service agreement',
    ];

    return termsTexts.some(text => textContent.includes(text));
  }

  private findDataProcessingNotice(): boolean {
    const textContent = this.html.toLowerCase();
    const processingTexts = [
      'data processing',
      'personal data',
      'data protection',
      'information processing',
      'data collection',
      'data usage',
      'data handling',
      'data storage',
      'data retention',
      'data sharing',
      'data transfer',
      'data processing notice',
      'data processing agreement',
      'data processing policy',
    ];

    return processingTexts.some(text => textContent.includes(text));
  }

  private findCookiePolicy(): boolean {
    // Check for cookie policy links
    const cookieSelectors = [
      'a[href*="cookie"]',
      'a[href*="cookies"]',
      'a[href*="cookie-policy"]',
      'a[href*="cookie_policy"]',
      'a[href*="cookies-policy"]',
    ];

    for (const selector of cookieSelectors) {
      const links = this.dom.window.document.querySelectorAll(selector);
      if (links.length > 0) return true;
    }

    // Check for cookie policy text
    const textContent = this.html.toLowerCase();
    const cookieTexts = [
      'cookie policy',
      'cookie notice',
      'cookie statement',
      'cookies policy',
      'cookies notice',
      'cookie information',
      'cookie usage',
      'cookie settings',
    ];

    return cookieTexts.some(text => textContent.includes(text));
  }

  private findDataRetentionPolicy(): boolean {
    const textContent = this.html.toLowerCase();
    const retentionTexts = [
      'data retention',
      'retention policy',
      'data retention policy',
      'retention period',
      'data storage period',
      'how long we keep',
      'how long we store',
      'data retention period',
      'retention schedule',
    ];

    return retentionTexts.some(text => textContent.includes(text));
  }

  private findUserConsentMechanism(): boolean {
    // Check for consent forms and mechanisms
    const consentSelectors = [
      '[class*="consent"]',
      '[id*="consent"]',
      '[class*="opt-in"]',
      '[id*="opt-in"]',
      '[class*="opt-out"]',
      '[id*="opt-out"]',
      'input[type="checkbox"][name*="consent"]',
      'input[type="radio"][name*="consent"]',
      'button[class*="consent"]',
      'button[id*="consent"]',
    ];

    for (const selector of consentSelectors) {
      const elements = this.dom.window.document.querySelectorAll(selector);
      if (elements.length > 0) return true;
    }

    // Check for consent text
    const textContent = this.html.toLowerCase();
    const consentTexts = [
      'consent',
      'opt-in',
      'opt-out',
      'agree to',
      'accept terms',
      'i agree',
      'i accept',
      'consent to',
      'permission',
      'authorization',
    ];

    return consentTexts.some(text => textContent.includes(text));
  }

  private findDataPortability(): boolean {
    const textContent = this.html.toLowerCase();
    const portabilityTexts = [
      'data portability',
      'export data',
      'download data',
      'data export',
      'export my data',
      'download my data',
      'data download',
      'export information',
      'data access',
      'right to data portability',
    ];

    return portabilityTexts.some(text => textContent.includes(text));
  }

  private findRightToErasure(): boolean {
    const textContent = this.html.toLowerCase();
    const erasureTexts = [
      'right to erasure',
      'right to be forgotten',
      'delete data',
      'delete my data',
      'remove data',
      'data deletion',
      'forget me',
      'erase data',
      'data erasure',
      'delete account',
      'account deletion',
      'data removal',
    ];

    return erasureTexts.some(text => textContent.includes(text));
  }

  // Helper methods for GDPR checks
  private checkDataMinimization(): boolean {
    const forms = this.dom.window.document.querySelectorAll('form');
    const inputs = this.dom.window.document.querySelectorAll('input, select, textarea');
    const hasMinimizedData = Array.from(forms).some(form => {
      const formInputs = Array.from(form.querySelectorAll('input, select, textarea'));
      return formInputs.length <= 5; // Example: if a form has more than 5 inputs, it's not minimal
    });
    return !hasMinimizedData;
  }

  private checkPurposeLimitation(): boolean {
    const privacyPolicyText = this.html.toLowerCase();
    const purposeTexts = [
      'purpose of data collection',
      'data processing purpose',
      'data usage purpose',
      'data handling purpose',
      'data retention purpose',
      'data sharing purpose',
      'data transfer purpose',
    ];
    return purposeTexts.some(text => privacyPolicyText.includes(text));
  }

  private checkLawfulBasis(): boolean {
    const privacyPolicyText = this.html.toLowerCase();
    const lawfulBasisTexts = [
      'lawful basis for data processing',
      'legal basis for data processing',
      'basis for data processing',
      'data processing lawful basis',
      'data processing legal basis',
    ];
    return lawfulBasisTexts.some(text => privacyPolicyText.includes(text));
  }

  // Helper methods for accessibility checks
  private checkKeyboardNavigation(): boolean {
    const interactiveElements = this.dom.window.document.querySelectorAll('a, button, input, select, textarea, [tabindex]');
    const focusableElements = Array.from(interactiveElements).filter(el => {
      const element = el as HTMLElement;
      const tabIndex = element.getAttribute('tabindex');
      return tabIndex !== '-1' && element.style.display !== 'none' && element.style.visibility !== 'hidden';
    });
    
    return focusableElements.length > 0;
  }

  private checkScreenReaderSupport(): boolean {
    const ariaElements = this.dom.window.document.querySelectorAll('[aria-label], [aria-labelledby], [role], [aria-describedby]');
    const semanticElements = this.dom.window.document.querySelectorAll('nav, main, article, section, aside, header, footer, button, input, textarea, select');
    
    return ariaElements.length > 0 || semanticElements.length > 0;
  }

  private checkFocusIndicators(): boolean {
    // Check for CSS focus styles
    const styleSheets = this.dom.window.document.styleSheets;
    let hasFocusStyles = false;
    
    try {
      for (let i = 0; i < styleSheets.length; i++) {
        const rules = styleSheets[i].cssRules || styleSheets[i].rules;
        if (rules) {
          for (let j = 0; j < rules.length; j++) {
            const rule = rules[j] as CSSStyleRule;
            if (rule.selectorText && rule.selectorText.includes(':focus')) {
              hasFocusStyles = true;
              break;
            }
          }
        }
      }
    } catch (e) {
      // Cross-origin stylesheets will throw an error
    }
    
    return hasFocusStyles;
  }

  private checkSkipLinks(): boolean {
    const skipLinks = this.dom.window.document.querySelectorAll('a[href*="#"], a[href*="skip"], a[href*="main"], a[href*="content"]');
    const skipLinkTexts = Array.from(skipLinks).map(link => link.textContent?.toLowerCase() || '');
    
    const skipKeywords = ['skip', 'jump', 'main content', 'main navigation', 'skip to content', 'skip navigation'];
    return skipLinkTexts.some(text => skipKeywords.some(keyword => text.includes(keyword)));
  }

  private checkARIALabels(): boolean {
    const ariaElements = this.dom.window.document.querySelectorAll('[aria-label], [aria-labelledby], [aria-describedby]');
    return ariaElements.length > 0;
  }

  private checkSemanticHTML(): boolean {
    const semanticElements = this.dom.window.document.querySelectorAll('nav, main, article, section, aside, header, footer, figure, figcaption, time, mark, details, summary');
    return semanticElements.length > 0;
  }

  private checkContrastRatio(): boolean {
    // This is a simplified check - in a real implementation, you'd analyze CSS colors
    // For now, we'll assume good contrast if the site has proper styling
    const hasStyles = this.dom.window.document.querySelectorAll('link[rel="stylesheet"], style').length > 0;
    return hasStyles;
  }

  // Helper methods for security checks
  private checkSecurityHeaders() {
    const headers = this.responseHeaders || {};
    const issues: string[] = [];
    let optimized = true;

    // Check for X-Frame-Options
    const hasXFrameOptions = headers['x-frame-options'] || headers['X-Frame-Options'];
    if (!hasXFrameOptions) {
      issues.push('No X-Frame-Options header');
      optimized = false;
    }

    // Check for X-Content-Type-Options
    const hasXContentTypeOptions = headers['x-content-type-options'] || headers['X-Content-Type-Options'];
    if (!hasXContentTypeOptions) {
      issues.push('No X-Content-Type-Options header');
      optimized = false;
    }

    // Check for Referrer Policy
    const hasReferrerPolicy = headers['referrer-policy'] || headers['Referrer-Policy'];
    if (!hasReferrerPolicy) {
      issues.push('No Referrer Policy header');
      optimized = false;
    }

    // Check for Permissions Policy
    const hasPermissionsPolicy = headers['permissions-policy'] || headers['Permissions-Policy'];
    if (!hasPermissionsPolicy) {
      issues.push('No Permissions Policy header');
      optimized = false;
    }

    // Check for X-XSS-Protection
    const hasXSSProtection = headers['x-xss-protection'] || headers['X-XSS-Protection'];
    if (!hasXSSProtection) {
      issues.push('No X-XSS-Protection header');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        hasXFrameOptions: !!hasXFrameOptions,
        hasXContentTypeOptions: !!hasXContentTypeOptions,
        hasReferrerPolicy: !!hasReferrerPolicy,
        hasPermissionsPolicy: !!hasPermissionsPolicy,
        hasXSSProtection: !!hasXSSProtection,
        totalHeaders: [hasXFrameOptions, hasXContentTypeOptions, hasReferrerPolicy, hasPermissionsPolicy, hasXSSProtection].filter(Boolean).length
      }
    };
  }

  private checkCSP(): boolean {
    const cspMeta = this.dom.window.document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const cspHeader = this.responseHeaders?.['content-security-policy'] || this.responseHeaders?.['Content-Security-Policy'];
    return cspMeta !== null || !!cspHeader;
  }

  private checkHSTS(): boolean {
    return !!(this.responseHeaders?.['strict-transport-security'] || this.responseHeaders?.['Strict-Transport-Security']);
  }

  private checkXFrameOptions(): boolean {
    return !!(this.responseHeaders?.['x-frame-options'] || this.responseHeaders?.['X-Frame-Options']);
  }

  private checkXContentTypeOptions(): boolean {
    return !!(this.responseHeaders?.['x-content-type-options'] || this.responseHeaders?.['X-Content-Type-Options']);
  }

  private checkReferrerPolicy(): boolean {
    return !!(this.responseHeaders?.['referrer-policy'] || this.responseHeaders?.['Referrer-Policy']);
  }

  private checkPermissionsPolicy(): boolean {
    return !!(this.responseHeaders?.['permissions-policy'] || this.responseHeaders?.['Permissions-Policy']);
  }

  private checkSecureCookies(): boolean {
    // Check for Set-Cookie headers with secure flags
    const setCookieHeaders = this.responseHeaders?.['set-cookie'] || this.responseHeaders?.['Set-Cookie'];
    if (setCookieHeaders) {
      const cookies = Array.isArray(setCookieHeaders) ? setCookieHeaders : [setCookieHeaders];
      return cookies.some(cookie => cookie.toLowerCase().includes('secure') || cookie.toLowerCase().includes('httponly'));
    }
    return false;
  }

  private checkCSRFProtection(): boolean {
    // Check for CSRF tokens in forms
    const forms = this.dom.window.document.querySelectorAll('form');
    const hasCSRFTokens = Array.from(forms).some(form => {
      const inputs = form.querySelectorAll('input[type="hidden"]');
      return Array.from(inputs).some(input => {
        const name = input.getAttribute('name')?.toLowerCase() || '';
        const value = input.getAttribute('value') || '';
        return name.includes('csrf') || name.includes('token') || name.includes('nonce') || 
               value.length > 20; // Long values are likely tokens
      });
    });
    
    return hasCSRFTokens;
  }

  private checkInputValidation(): boolean {
    const forms = this.dom.window.document.querySelectorAll('form');
    const hasInputValidation = Array.from(forms).some(form => {
      const inputs = form.querySelectorAll('input, select, textarea');
      return Array.from(inputs).some(input => {
        const inputElement = input as HTMLInputElement;
        const name = inputElement.getAttribute('name')?.toLowerCase() || '';
        const type = inputElement.getAttribute('type')?.toLowerCase() || '';
        if (type === 'email' || type === 'tel' || type === 'number' || type === 'date') {
          return !inputElement.checkValidity();
        }
        return false;
      });
    });
    return !hasInputValidation;
  }

  private checkOutputEncoding(): boolean {
    const html = this.html.toLowerCase();
    const sensitivePatterns = [
      'password',
      'secret',
      'key',
      'token',
      'api_key',
      'private_key',
      'database_url',
      'connection_string',
      'aws_access_key',
      'aws_secret_key',
      'google_api_key',
      'facebook_app_secret',
      'twitter_api_secret',
      'github_token',
      'slack_token',
      'stripe_secret_key',
      'paypal_secret',
      'mongodb_uri',
      'redis_url',
      'jwt_secret',
    ];
    
    return !sensitivePatterns.some(pattern => html.includes(pattern));
  }

  private checkSessionManagement(): boolean {
    const cookies = this.responseHeaders?.['set-cookie'] || this.responseHeaders?.['Set-Cookie'];
    if (cookies) {
      const cookieArray = Array.isArray(cookies) ? cookies : [cookies];
      return cookieArray.every(cookie => {
        const parts = cookie.split(';');
        const secure = parts.some((part: string) => part.trim().toLowerCase().includes('secure'));
        const httponly = parts.some((part: string) => part.trim().toLowerCase().includes('httponly'));
        return secure && httponly;
      });
    }
    return false;
  }

  private checkErrorHandling(): boolean {
    const html = this.html.toLowerCase();
    const errorKeywords = ['error', 'exception', 'stack trace', 'debug', 'mysql_error', 'sql error'];
    return !errorKeywords.some(keyword => html.includes(keyword));
  }

  private checkOpenRedirects(): boolean {
    // Check for potential open redirect parameters
    const url = new URL(this.url);
    const redirectParams = ['redirect', 'url', 'next', 'target', 'return', 'goto', 'link', 'continue'];
    
    return !redirectParams.some(param => {
      const value = url.searchParams.get(param);
      return value && (value.startsWith('http://') || value.startsWith('https://'));
    });
  }

  private checkSensitiveInfoExposure(): boolean {
    const html = this.html.toLowerCase();
    const sensitivePatterns = [
      'password',
      'secret',
      'key',
      'token',
      'api_key',
      'private_key',
      'database_url',
      'connection_string',
      'aws_access_key',
      'aws_secret_key',
      'google_api_key',
      'facebook_app_secret',
      'twitter_api_secret',
      'github_token',
      'slack_token',
      'stripe_secret_key',
      'paypal_secret',
      'mongodb_uri',
      'redis_url',
      'jwt_secret',
    ];
    
    return !sensitivePatterns.some(pattern => html.includes(pattern));
  }

  // Helper methods for performance checks
  private checkImageOptimization() {
    const images = this.dom.window.document.querySelectorAll('img');
    const issues: string[] = [];
    let optimized = true;

    if (images.length > 0) {
      // Check for missing width/height attributes
      const imagesWithoutDimensions = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        return !imgElement.width || !imgElement.height;
      });
      
      if (imagesWithoutDimensions.length > 0) {
        issues.push(`${imagesWithoutDimensions.length} images missing width/height attributes`);
        optimized = false;
      }

      // Check for large images
      const largeImages = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        const src = imgElement.src;
        return src && (src.includes('large') || src.includes('original') || src.includes('full'));
      });
      
      if (largeImages.length > 0) {
        issues.push(`${largeImages.length} potentially oversized images detected`);
        optimized = false;
      }

      // Check for modern image formats
      const modernFormats = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        const src = imgElement.src;
        return src && (src.includes('.webp') || src.includes('.avif') || src.includes('.svg'));
      });
      
      if (modernFormats.length === 0 && images.length > 0) {
        issues.push('No modern image formats (WebP, AVIF) detected');
        optimized = false;
      }
    }

    return { optimized, issues };
  }

  private checkMinification() {
    const issues: string[] = [];
    let optimized = true;

    // Check for minified CSS
    const cssLinks = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]');
    const minifiedCSS = Array.from(cssLinks).filter(link => {
      const href = link.getAttribute('href') || '';
      return href.includes('.min.css') || href.includes('minified');
    });
    
    if (minifiedCSS.length === 0 && cssLinks.length > 0) {
      issues.push('CSS files not minified');
      optimized = false;
    }

    // Check for minified JS
    const scriptTags = this.dom.window.document.querySelectorAll('script[src]');
    const minifiedJS = Array.from(scriptTags).filter(script => {
      const src = script.getAttribute('src') || '';
      return src.includes('.min.js') || src.includes('minified');
    });
    
    if (minifiedJS.length === 0 && scriptTags.length > 0) {
      issues.push('JavaScript files not minified');
      optimized = false;
    }

    return { optimized, issues };
  }

  private checkCompression() {
    const contentEncoding = this.responseHeaders?.['content-encoding'] || this.responseHeaders?.['Content-Encoding'];
    const acceptEncoding = this.responseHeaders?.['accept-encoding'] || this.responseHeaders?.['Accept-Encoding'];
    
    return {
      enabled: !!(contentEncoding && (contentEncoding.includes('gzip') || contentEncoding.includes('br') || contentEncoding.includes('deflate'))),
      supported: !!(acceptEncoding && (acceptEncoding.includes('gzip') || acceptEncoding.includes('br') || acceptEncoding.includes('deflate'))),
      details: {
        contentEncoding,
        acceptEncoding,
        hasGzip: contentEncoding?.includes('gzip') || false,
        hasBrotli: contentEncoding?.includes('br') || false,
        hasDeflate: contentEncoding?.includes('deflate') || false
      }
    };
  }

  private checkCaching() {
    const cacheControl = this.responseHeaders?.['cache-control'] || this.responseHeaders?.['Cache-Control'];
    const expires = this.responseHeaders?.['expires'] || this.responseHeaders?.['Expires'];
    const etag = this.responseHeaders?.['etag'] || this.responseHeaders?.['ETag'];
    const lastModified = this.responseHeaders?.['last-modified'] || this.responseHeaders?.['Last-Modified'];
    
    return {
      enabled: !!(cacheControl || expires || etag || lastModified),
      hasCacheControl: !!cacheControl,
      hasExpires: !!expires,
      hasETag: !!etag,
      hasLastModified: !!lastModified
    };
  }

  private checkCDNUsage() {
    const cdnDomains = [
      'cdn.', 'static.', 'assets.', 'media.', 'img.', 'js.', 'css.',
      'cloudfront.net', 'cloudflare.com', 'fastly.com', 'akamai.com',
      'jsdelivr.net', 'unpkg.com', 'cdnjs.cloudflare.com'
    ];
    
    const url = this.url.toLowerCase();
    const used = cdnDomains.some(domain => url.includes(domain));
    
    return { used };
  }

  private checkRenderBlockingResources() {
    const renderBlocking = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]:not([media="print"]), script:not([async]):not([defer])');
    return { count: renderBlocking.length };
  }

  private checkUnusedResources() {
    // This is a simplified check - in a real implementation, you'd analyze actual usage
    const cssLinks = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]');
    const scriptTags = this.dom.window.document.querySelectorAll('script[src]');
    
    // Assume some resources might be unused if there are many
    const potentiallyUnused = Math.max(0, cssLinks.length + scriptTags.length - 5);
    
    return { unused: potentiallyUnused };
  }

  // Additional security vulnerability checks
  private checkCommonVulnerabilities() {
    const vulnerabilities: string[] = [];
    const recommendations: string[] = [];

    // Check for SQL injection patterns in forms
    const forms = this.dom.window.document.querySelectorAll('form');
    forms.forEach(form => {
      const inputs = form.querySelectorAll('input, textarea, select');
      inputs.forEach(input => {
        const name = input.getAttribute('name') || '';
        const id = input.getAttribute('id') || '';
        if (name.includes('sql') || name.includes('query') || id.includes('sql') || id.includes('query')) {
          vulnerabilities.push('Potential SQL injection vulnerability in form field');
          recommendations.push('Implement proper input validation and parameterized queries');
        }
      });
    });

    // Check for XSS vulnerabilities
    const scripts = this.dom.window.document.querySelectorAll('script');
    scripts.forEach(script => {
      const content = script.textContent || '';
      if (content.includes('innerHTML') || content.includes('outerHTML') || content.includes('document.write')) {
        vulnerabilities.push('Potential XSS vulnerability detected');
        recommendations.push('Avoid using innerHTML/outerHTML with user input, use textContent instead');
      }
    });

    // Check for exposed error messages
    const errorKeywords = ['error', 'exception', 'stack trace', 'debug', 'mysql_error', 'sql error'];
    const html = this.html.toLowerCase();
    errorKeywords.forEach(keyword => {
      if (html.includes(keyword)) {
        vulnerabilities.push('Error messages potentially exposed');
        recommendations.push('Disable detailed error messages in production');
      }
    });

    // Check for directory listing
    if (html.includes('index of') || html.includes('directory listing')) {
      vulnerabilities.push('Directory listing enabled');
      recommendations.push('Disable directory listing in web server configuration');
    }

    // Check for default credentials
    const defaultCreds = ['admin:admin', 'root:root', 'user:password', 'admin:password'];
    defaultCreds.forEach(creds => {
      if (html.includes(creds)) {
        vulnerabilities.push('Default credentials potentially exposed');
        recommendations.push('Change default credentials immediately');
      }
    });

    return { vulnerabilities, recommendations };
  }

  // Check for outdated software versions
  private checkSoftwareVersions() {
    const outdated: string[] = [];
    const recommendations: string[] = [];

    // Check for common outdated software signatures
    const versionPatterns = [
      { pattern: 'wordpress', version: '5.0', name: 'WordPress' },
      { pattern: 'php', version: '7.4', name: 'PHP' },
      { pattern: 'apache', version: '2.4', name: 'Apache' },
      { pattern: 'nginx', version: '1.18', name: 'Nginx' },
      { pattern: 'jquery', version: '3.6', name: 'jQuery' },
      { pattern: 'bootstrap', version: '5.0', name: 'Bootstrap' },
    ];

    const html = this.html.toLowerCase();
    versionPatterns.forEach(({ pattern, version, name }) => {
      if (html.includes(pattern)) {
        // This is a simplified check - in a real implementation, you'd extract actual versions
        outdated.push(`Potentially outdated ${name} version`);
        recommendations.push(`Update ${name} to the latest version`);
      }
    });

    return { outdated, recommendations };
  }

  // Check for privacy and data protection
  private checkPrivacyCompliance() {
    const issues: string[] = [];
    const recommendations: string[] = [];

    // Check for tracking scripts
    const trackingScripts = [
      'google-analytics.com',
      'googletagmanager.com',
      'facebook.net',
      'doubleclick.net',
      'hotjar.com',
      'mixpanel.com',
      'amplitude.com',
      'segment.com'
    ];

    const html = this.html.toLowerCase();
    trackingScripts.forEach(script => {
      if (html.includes(script)) {
        issues.push(`Third-party tracking script detected: ${script}`);
        recommendations.push('Ensure tracking scripts comply with privacy regulations and user consent');
      }
    });

    // Check for data collection forms
    const forms = this.dom.window.document.querySelectorAll('form');
    forms.forEach(form => {
      const inputs = form.querySelectorAll('input, textarea, select');
      const personalDataFields = Array.from(inputs).filter((input: Element) => {
        const name = input.getAttribute('name')?.toLowerCase() || '';
        const type = input.getAttribute('type')?.toLowerCase() || '';
        return name.includes('email') || name.includes('phone') || name.includes('address') || 
               name.includes('name') || name.includes('ssn') || name.includes('credit') ||
               type === 'email' || type === 'tel';
      });

      if (personalDataFields.length > 0) {
        issues.push('Personal data collection form detected');
        recommendations.push('Ensure data collection forms have proper privacy notices and consent mechanisms');
      }
    });

    return { issues, recommendations };
  }

  // Helper methods for SEO checks
  private checkMetaTitle() {
    const title = this.dom.window.document.querySelector('title');
    if (!title) {
      return { valid: false, issue: 'No title tag found' };
    }
    
    const titleText = title.textContent?.trim() || '';
    if (titleText.length === 0) {
      return { valid: false, issue: 'Empty title tag' };
    }
    
    if (titleText.length < 30) {
      return { valid: false, issue: 'Title too short (should be 50-60 characters)' };
    }
    
    if (titleText.length > 60) {
      return { valid: false, issue: 'Title too long (should be 50-60 characters)' };
    }
    
    return { valid: true };
  }

  private checkMetaDescription() {
    const metaDesc = this.dom.window.document.querySelector('meta[name="description"]');
    if (!metaDesc) {
      return { valid: false, issue: 'No meta description found' };
    }
    
    const content = metaDesc.getAttribute('content')?.trim() || '';
    if (content.length === 0) {
      return { valid: false, issue: 'Empty meta description' };
    }
    
    if (content.length < 120) {
      return { valid: false, issue: 'Meta description too short (should be 150-160 characters)' };
    }
    
    if (content.length > 160) {
      return { valid: false, issue: 'Meta description too long (should be 150-160 characters)' };
    }
    
    return { valid: true };
  }

  private checkOpenGraph() {
    const ogTags = this.dom.window.document.querySelectorAll('meta[property^="og:"]');
    const issues: string[] = [];
    
    if (ogTags.length === 0) {
      issues.push('No Open Graph tags found');
    } else {
      const requiredTags = ['og:title', 'og:description', 'og:image'];
      const foundTags = Array.from(ogTags).map(tag => tag.getAttribute('property'));
      
      requiredTags.forEach(tag => {
        if (!foundTags.includes(tag)) {
          issues.push(`Missing ${tag} tag`);
        }
      });
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkTwitterCard() {
    const twitterTags = this.dom.window.document.querySelectorAll('meta[name^="twitter:"]');
    const issues: string[] = [];
    
    if (twitterTags.length === 0) {
      issues.push('No Twitter Card tags found');
    } else {
      const requiredTags = ['twitter:card', 'twitter:title', 'twitter:description'];
      const foundTags = Array.from(twitterTags).map(tag => tag.getAttribute('name'));
      
      requiredTags.forEach(tag => {
        if (!foundTags.includes(tag)) {
          issues.push(`Missing ${tag} tag`);
        }
      });
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkStructuredData() {
    const structuredData = this.dom.window.document.querySelectorAll('script[type="application/ld+json"]');
    const issues: string[] = [];
    
    if (structuredData.length === 0) {
      issues.push('No structured data found');
    } else {
      // Check if structured data is valid JSON
      structuredData.forEach((script, index) => {
        try {
          const content = script.textContent || '';
          JSON.parse(content);
        } catch (e) {
          issues.push(`Invalid JSON in structured data ${index + 1}`);
        }
      });
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkSitemap() {
    const sitemapLink = this.dom.window.document.querySelector('link[rel="sitemap"]');
    const issues: string[] = [];
    
    if (!sitemapLink) {
      issues.push('No sitemap link found');
    }
    
    // Check for robots.txt reference to sitemap
    const robotsTxt = this.dom.window.document.querySelector('meta[name="robots"]');
    if (!robotsTxt) {
      issues.push('No robots meta tag found');
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkRobotsTxt() {
    // This would require checking robots.txt file - simplified for now
    const robotsMeta = this.dom.window.document.querySelector('meta[name="robots"]');
    const issues: string[] = [];
    
    if (!robotsMeta) {
      issues.push('No robots meta tag found');
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkCanonicalUrl() {
    const canonical = this.dom.window.document.querySelector('link[rel="canonical"]');
    const issues: string[] = [];
    
    if (!canonical) {
      issues.push('No canonical URL found');
    } else {
      const href = canonical.getAttribute('href');
      if (!href || href.trim().length === 0) {
        issues.push('Empty canonical URL');
      }
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkInternalLinking() {
    const internalLinks = this.dom.window.document.querySelectorAll('a[href^="/"], a[href^="' + this.url + '"]');
    const issues: string[] = [];
    
    if (internalLinks.length === 0) {
      issues.push('No internal links found');
    } else if (internalLinks.length < 3) {
import axios from 'axios';
import { JSDOM } from 'jsdom';

interface ScanOptions {
  gdpr: boolean;
  accessibility: boolean;
  security: boolean;
  performance: boolean;
  seo: boolean;
  customRules: string[];
}

interface ScanResult {
  gdpr: {
    hasCookieBanner: boolean;
    hasPrivacyPolicy: boolean;
    hasTermsOfService: boolean;
    hasDataProcessingNotice: boolean;
    hasCookiePolicy: boolean;
    hasDataRetentionPolicy: boolean;
    hasUserConsentMechanism: boolean;
    hasDataPortability: boolean;
    hasRightToErasure: boolean;
    hasDataMinimization: boolean;
    hasPurposeLimitation: boolean;
    hasLawfulBasis: boolean;
    score: number;
    issues: string[];
    recommendations: string[];
    complianceLevel: 'compliant' | 'partially-compliant' | 'non-compliant';
  };
  accessibility: {
    hasAltText: boolean;
    hasProperHeadings: boolean;
    hasContrastRatio: boolean;
    hasKeyboardNavigation: boolean;
    hasScreenReaderSupport: boolean;
    hasFocusIndicators: boolean;
    hasSkipLinks: boolean;
    hasARIALabels: boolean;
    hasSemanticHTML: boolean;
    hasFormLabels: boolean;
    hasLanguageDeclaration: boolean;
    hasErrorHandling: boolean;
    score: number;
    issues: string[];
    recommendations: string[];
    wcagLevel: 'A' | 'AA' | 'AAA' | 'non-compliant';
  };
  security: {
    hasHTTPS: boolean;
    hasSecurityHeaders: boolean;
    hasCSP: boolean;
    hasHSTS: boolean;
    hasXFrameOptions: boolean;
    hasXContentTypeOptions: boolean;
    hasReferrerPolicy: boolean;
    hasPermissionsPolicy: boolean;
    hasSecureCookies: boolean;
    hasCSRFProtection: boolean;
    hasInputValidation: boolean;
    hasOutputEncoding: boolean;
    hasSessionManagement: boolean;
    hasErrorHandling: boolean;
    score: number;
    issues: string[];
    recommendations: string[];
    securityLevel: 'high' | 'medium' | 'low' | 'critical';
  };
  performance: {
    loadTime: number;
    pageSize: number;
    imageOptimization: boolean;
    minification: boolean;
    compression: boolean;
    caching: boolean;
    cdnUsage: boolean;
    renderBlockingResources: number;
    unusedCSS: number;
    unusedJS: number;
    firstContentfulPaint: number;
    largestContentfulPaint: number;
    cumulativeLayoutShift: number;
    firstInputDelay: number;
    score: number;
    issues: string[];
    recommendations: string[];
    performanceGrade: 'A' | 'B' | 'C' | 'D' | 'F';
  };
  seo: {
    hasMetaTitle: boolean;
    hasMetaDescription: boolean;
    hasOpenGraph: boolean;
    hasTwitterCard: boolean;
    hasStructuredData: boolean;
    hasSitemap: boolean;
    hasRobotsTxt: boolean;
    hasCanonicalUrl: boolean;
    hasInternalLinking: boolean;
    hasHeadingStructure: boolean;
    hasImageOptimization: boolean;
    hasMobileOptimization: boolean;
    hasPageSpeed: boolean;
    hasSSL: boolean;
    score: number;
    issues: string[];
    recommendations: string[];
    seoScore: number;
  };
  overall: {
    score: number;
    grade: 'A' | 'B' | 'C' | 'D' | 'F';
    totalIssues: number;
    recommendations: string[];
    priorityIssues: string[];
    complianceStatus: 'excellent' | 'good' | 'fair' | 'poor' | 'critical';
  };
  scanDuration: number;
  technicalDetails: {
    serverInfo: string;
    technologies: string[];
    frameworks: string[];
    cms: string | null;
    hosting: string | null;
  };
}

export class WebsiteScanner {
  private url: string;
  private html: string = '';
  private dom!: JSDOM;
  private responseHeaders: any = {};
  private loadTime: number = 0;
  private pageSize: number = 0;
  private serverInfo: string = '';
  private technologies: string[] = [];
  private frameworks: string[] = [];
  private cms: string | null = null;
  private hosting: string | null = null;

  constructor(url: string) {
    this.url = url;
  }

  async scan(options: ScanOptions = {
    gdpr: true,
    accessibility: true,
    security: true,
    performance: false,
    seo: false,
    customRules: []
  }): Promise<ScanResult> {
    try {
      const startTime = Date.now();
      
      console.log(`Starting scan for ${this.url} with options:`, options);
      
      await this.fetchContent();
      this.parseHTML();
      this.detectTechnologies(); // Add this line to detect technologies

      const results: any = {};

      // Debug: Log what we're about to scan
      console.log('Starting scan with options:', options);
      console.log('HTML content length:', this.html.length);
      console.log('DOM parsed successfully:', !!this.dom);

      // Perform scans based on options
      if (options.gdpr) {
        console.log('Performing GDPR scan...');
        results.gdpr = this.checkGDPR();
      }

      if (options.accessibility) {
        console.log('Performing accessibility checks...');
        results.accessibility = this.checkAccessibility();
      }

      if (options.security) {
        console.log('Performing security checks...');
        results.security = this.checkSecurity();
      }

      if (options.performance) {
        console.log('Performing performance checks...');
        results.performance = this.checkPerformance();
      }

      if (options.seo) {
        console.log('Performing SEO checks...');
        results.seo = this.checkSEO();
      }

      const totalScanDuration = Date.now() - startTime;
      
      // Calculate overall score
      const overall = this.calculateOverall(results, options);
      
      // Debug: Log final technical details
      console.log('Final technical details being returned:');
      console.log('- Server Info:', this.serverInfo);
      console.log('- Technologies:', this.technologies);
      console.log('- Frameworks:', this.frameworks);
      console.log('- CMS:', this.cms);
      console.log('- Hosting:', this.hosting);
      console.log('- Total scan duration:', totalScanDuration, 'ms');

      return {
        gdpr: results.gdpr || this.getDefaultGDPR(),
        accessibility: results.accessibility || this.getDefaultAccessibility(),
        security: results.security || this.getDefaultSecurity(),
        performance: results.performance || this.getDefaultPerformance(),
        seo: results.seo || this.getDefaultSEO(),
        overall,
        scanDuration: totalScanDuration,
        technicalDetails: {
          serverInfo: this.serverInfo,
          technologies: this.technologies,
          frameworks: this.frameworks,
          cms: this.cms,
          hosting: this.hosting,
        }
      };
    } catch (error) {
      console.error('Scan error:', error);
      throw new Error(`Failed to scan website: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async fetchContent(): Promise<void> {
    try {
      const startTime = Date.now();
      
      const response = await axios.get(this.url, {
        timeout: 30000, // 30 seconds timeout
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; ComplianceScanner/1.0)',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.5',
          'Accept-Encoding': 'gzip, deflate, br',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
        },
        maxRedirects: 5,
        validateStatus: () => true, // Accept all status codes
        responseType: 'text',
        decompress: true,
      });
      
      const endTime = Date.now();
      this.loadTime = endTime - startTime;
      this.html = response.data;
      this.responseHeaders = response.headers;
      this.pageSize = Buffer.byteLength(response.data, 'utf8');
      
      // Extract server information
      this.serverInfo = response.headers['server'] || response.headers['Server'] || 'Unknown';
      
      // Detect technologies and frameworks
      this.detectTechnologies();
      
      console.log(`Fetched ${this.url}: ${this.loadTime}ms, ${this.pageSize} bytes, Server: ${this.serverInfo}`);
    } catch (error) {
      console.error(`Failed to fetch ${this.url}:`, error);
      throw new Error(`Failed to fetch website content: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private detectTechnologies(): void {
    const html = this.html.toLowerCase();
    const headers = this.responseHeaders;
    
    console.log('Detecting technologies for:', this.url);
    console.log('Server info:', this.serverInfo);
    
    // Clear previous detections
    this.technologies = [];
    this.frameworks = [];
    this.cms = null;
    this.hosting = null;
    
    // Detect server and hosting from headers
    this.detectServerAndHosting(headers);
    
    // Detect frameworks from HTML content
    this.detectFrameworks(html);
    
    // Detect CMS from HTML content
    this.detectCMS(html);
    
    // Detect technologies from HTML content and scripts
    this.detectTechnologiesFromContent(html);
    
    // Detect technologies from external scripts
    this.detectTechnologiesFromScripts();
    
    // Remove duplicates
    this.technologies = this.removeDuplicates(this.technologies);
    this.frameworks = this.removeDuplicates(this.frameworks);
    
    console.log('Detected frameworks:', this.frameworks);
    console.log('Detected CMS:', this.cms);
    console.log('Detected hosting:', this.hosting);
    console.log('Detected technologies:', this.technologies);
  }

  private removeDuplicates(array: string[]): string[] {
    return Array.from(new Set(array));
  }

  private addTechnology(tech: string): void {
    if (tech && !this.technologies.includes(tech)) {
      this.technologies.push(tech);
    }
  }

  private addFramework(framework: string): void {
    if (framework && !this.frameworks.includes(framework)) {
      this.frameworks.push(framework);
    }
  }

  private detectServerAndHosting(headers: any): void {
    // Server detection from headers
    const server = headers['server'] || headers['Server'] || '';
    const poweredBy = headers['x-powered-by'] || headers['X-Powered-By'] || '';
    const via = headers['via'] || headers['Via'] || '';
    const cfRay = headers['cf-ray'] || headers['CF-Ray'] || '';
    const xPoweredBy = headers['x-powered-by'] || headers['X-Powered-By'] || '';
    
    console.log('Raw headers for server detection:', {
      server,
      poweredBy,
      via,
      cfRay,
      xPoweredBy
    });
    
    if (server) {
      this.serverInfo = server;
      
      // Detect hosting from server header
      if (server.includes('cloudflare')) {
        this.hosting = 'Cloudflare';
        this.technologies.push('Cloudflare');
      } else if (server.includes('nginx')) {
        this.hosting = 'Nginx';
        this.technologies.push('Nginx');
      } else if (server.includes('apache')) {
        this.hosting = 'Apache';
        this.technologies.push('Apache');
      } else if (server.includes('iis')) {
        this.hosting = 'IIS';
        this.technologies.push('IIS');
      } else if (server.includes('caddy')) {
        this.hosting = 'Caddy';
        this.technologies.push('Caddy');
      } else if (server.includes('lighttpd')) {
        this.hosting = 'Lighttpd';
        this.technologies.push('Lighttpd');
      } else if (server.includes('gws')) {
        this.hosting = 'Google Web Server';
        this.technologies.push('Google Web Server');
      } else if (server.includes('sffe')) {
        this.hosting = 'Google Frontend';
        this.technologies.push('Google Frontend');
      } else if (server.includes('openresty')) {
        this.hosting = 'OpenResty';
        this.technologies.push('OpenResty');
      } else if (server.includes('litespeed')) {
        this.hosting = 'LiteSpeed';
        this.technologies.push('LiteSpeed');
      } else if (server.includes('jetty')) {
        this.hosting = 'Jetty';
        this.technologies.push('Jetty');
      } else if (server.includes('tomcat')) {
        this.hosting = 'Apache Tomcat';
        this.technologies.push('Apache Tomcat');
      } else if (server.includes('express')) {
        this.hosting = 'Express.js';
        this.technologies.push('Express.js');
      } else if (server.includes('node')) {
        this.hosting = 'Node.js';
        this.technologies.push('Node.js');
      } else if (server.includes('php')) {
        this.hosting = 'PHP';
        this.technologies.push('PHP');
      } else if (server.includes('python')) {
        this.hosting = 'Python';
        this.technologies.push('Python');
      } else if (server.includes('ruby')) {
        this.hosting = 'Ruby';
        this.technologies.push('Ruby');
      } else if (server.includes('asp.net')) {
        this.hosting = 'ASP.NET';
        this.technologies.push('ASP.NET');
      } else if (server.includes('django')) {
        this.hosting = 'Django';
        this.technologies.push('Django');
      } else if (server.includes('flask')) {
        this.hosting = 'Flask';
        this.technologies.push('Flask');
      } else if (server.includes('rails')) {
        this.hosting = 'Ruby on Rails';
        this.technologies.push('Ruby on Rails');
      } else if (server.includes('laravel')) {
        this.hosting = 'Laravel';
        this.technologies.push('Laravel');
      } else if (server.includes('wordpress')) {
        this.hosting = 'WordPress';
        this.technologies.push('WordPress');
      } else if (server.includes('drupal')) {
        this.hosting = 'Drupal';
        this.technologies.push('Drupal');
      } else if (server.includes('joomla')) {
        this.hosting = 'Joomla';
        this.technologies.push('Joomla');
      } else if (server.includes('shopify')) {
        this.hosting = 'Shopify';
        this.technologies.push('Shopify');
      } else if (server.includes('wix')) {
        this.hosting = 'Wix';
        this.technologies.push('Wix');
      } else if (server.includes('squarespace')) {
        this.hosting = 'Squarespace';
        this.technologies.push('Squarespace');
      } else if (server.includes('ghost')) {
        this.hosting = 'Ghost';
        this.technologies.push('Ghost');
      } else if (server.includes('hugo')) {
        this.hosting = 'Hugo';
        this.technologies.push('Hugo');
      } else if (server.includes('jekyll')) {
        this.hosting = 'Jekyll';
        this.technologies.push('Jekyll');
      } else if (server.includes('next')) {
        this.hosting = 'Next.js';
        this.technologies.push('Next.js');
      } else if (server.includes('nuxt')) {
        this.hosting = 'Nuxt.js';
        this.technologies.push('Nuxt.js');
      } else if (server.includes('gatsby')) {
        this.hosting = 'Gatsby';
        this.technologies.push('Gatsby');
      } else if (server.includes('vercel')) {
        this.hosting = 'Vercel';
        this.technologies.push('Vercel');
      } else if (server.includes('netlify')) {
        this.hosting = 'Netlify';
        this.technologies.push('Netlify');
      } else if (server.includes('firebase')) {
        this.hosting = 'Firebase';
        this.technologies.push('Firebase');
      } else if (server.includes('aws')) {
        this.hosting = 'AWS';
        this.technologies.push('AWS');
      } else if (server.includes('google')) {
        this.hosting = 'Google Cloud';
        this.technologies.push('Google Cloud');
      } else if (server.includes('azure')) {
        this.hosting = 'Microsoft Azure';
        this.technologies.push('Microsoft Azure');
      } else if (server.includes('heroku')) {
        this.hosting = 'Heroku';
        this.technologies.push('Heroku');
      } else if (server.includes('digitalocean')) {
        this.hosting = 'DigitalOcean';
        this.technologies.push('DigitalOcean');
      } else if (server.includes('linode')) {
        this.hosting = 'Linode';
        this.technologies.push('Linode');
      } else if (server.includes('vultr')) {
        this.hosting = 'Vultr';
        this.technologies.push('Vultr');
      } else if (server.includes('ovh')) {
        this.hosting = 'OVH';
        this.technologies.push('OVH');
      } else if (server.includes('godaddy')) {
        this.hosting = 'GoDaddy';
        this.technologies.push('GoDaddy');
      } else if (server.includes('hostgator')) {
        this.hosting = 'HostGator';
        this.technologies.push('HostGator');
      } else if (server.includes('bluehost')) {
        this.hosting = 'Bluehost';
        this.technologies.push('Bluehost');
      } else if (server.includes('dreamhost')) {
        this.hosting = 'DreamHost';
        this.technologies.push('DreamHost');
      } else if (server.includes('siteground')) {
        this.hosting = 'SiteGround';
        this.technologies.push('SiteGround');
      } else if (server.includes('a2hosting')) {
        this.hosting = 'A2 Hosting';
        this.technologies.push('A2 Hosting');
      } else if (server.includes('inmotion')) {
        this.hosting = 'InMotion Hosting';
        this.technologies.push('InMotion Hosting');
      } else if (server.includes('hostinger')) {
        this.hosting = 'Hostinger';
        this.technologies.push('Hostinger');
      } else if (server.includes('namecheap')) {
        this.hosting = 'Namecheap';
        this.technologies.push('Namecheap');
      } else if (server.includes('ionos')) {
        this.hosting = 'IONOS';
        this.technologies.push('IONOS');
      } else if (server.includes('1and1')) {
        this.hosting = '1&1 IONOS';
        this.technologies.push('1&1 IONOS');
      } else if (server.includes('webhost')) {
        this.hosting = 'WebHost';
        this.technologies.push('WebHost');
      } else if (server.includes('hostmonster')) {
        this.hosting = 'HostMonster';
        this.technologies.push('HostMonster');
      } else if (server.includes('justhost')) {
        this.hosting = 'JustHost';
        this.technologies.push('JustHost');
      } else if (server.includes('ipage')) {
        this.hosting = 'iPage';
        this.technologies.push('iPage');
      } else if (server.includes('fatcow')) {
        this.hosting = 'FatCow';
        this.technologies.push('FatCow');
      } else if (server.includes('hostpapa')) {
        this.hosting = 'HostPapa';
        this.technologies.push('HostPapa');
      } else if (server.includes('greengeeks')) {
        this.hosting = 'GreenGeeks';
        this.technologies.push('GreenGeeks');
      } else if (server.includes('webhostingpad')) {
        this.hosting = 'WebHostingPad';
        this.technologies.push('WebHostingPad');
      } else if (server.includes('arvixe')) {
        this.hosting = 'Arvixe';
        this.technologies.push('Arvixe');
      } else if (server.includes('midphase')) {
        this.hosting = 'Midphase';
        this.technologies.push('Midphase');
      } else if (server.includes('westhost')) {
        this.hosting = 'WestHost';
        this.technologies.push('WestHost');
      } else if (server.includes('powweb')) {
        this.hosting = 'PowWeb';
        this.technologies.push('PowWeb');
      } else if (server.includes('startlogic')) {
        this.hosting = 'StartLogic';
        this.technologies.push('StartLogic');
      } else if (server.includes('supergreen')) {
        this.hosting = 'SuperGreen Hosting';
        this.technologies.push('SuperGreen Hosting');
      } else if (server.includes('hostclear')) {
        this.hosting = 'HostClear';
        this.technologies.push('HostClear');
      } else if (server.includes('hostnine')) {
        this.hosting = 'HostNine';
        this.technologies.push('HostNine');
      } else if (server.includes('hostgator')) {
        this.hosting = 'HostGator';
        this.technologies.push('HostGator');
      } else if (server.includes('bluehost')) {
        this.hosting = 'Bluehost';
        this.technologies.push('Bluehost');
      } else if (server.includes('dreamhost')) {
        this.hosting = 'DreamHost';
        this.technologies.push('DreamHost');
      } else if (server.includes('siteground')) {
        this.hosting = 'SiteGround';
        this.technologies.push('SiteGround');
      } else if (server.includes('a2hosting')) {
        this.hosting = 'A2 Hosting';
        this.technologies.push('A2 Hosting');
      } else if (server.includes('inmotion')) {
        this.hosting = 'InMotion Hosting';
        this.technologies.push('InMotion Hosting');
      } else if (server.includes('hostinger')) {
        this.hosting = 'Hostinger';
        this.technologies.push('Hostinger');
      } else if (server.includes('namecheap')) {
        this.hosting = 'Namecheap';
        this.technologies.push('Namecheap');
      } else if (server.includes('ionos')) {
        this.hosting = 'IONOS';
        this.technologies.push('IONOS');
      } else if (server.includes('1and1')) {
        this.hosting = '1&1 IONOS';
        this.technologies.push('1&1 IONOS');
      } else if (server.includes('webhost')) {
        this.hosting = 'WebHost';
        this.technologies.push('WebHost');
      } else if (server.includes('hostmonster')) {
        this.hosting = 'HostMonster';
        this.technologies.push('HostMonster');
      } else if (server.includes('justhost')) {
        this.hosting = 'JustHost';
        this.technologies.push('JustHost');
      } else if (server.includes('ipage')) {
        this.hosting = 'iPage';
        this.technologies.push('iPage');
      } else if (server.includes('fatcow')) {
        this.hosting = 'FatCow';
        this.technologies.push('FatCow');
      } else if (server.includes('hostpapa')) {
        this.hosting = 'HostPapa';
        this.technologies.push('HostPapa');
      } else if (server.includes('greengeeks')) {
        this.hosting = 'GreenGeeks';
        this.technologies.push('GreenGeeks');
      } else if (server.includes('webhostingpad')) {
        this.hosting = 'WebHostingPad';
        this.technologies.push('WebHostingPad');
      } else if (server.includes('arvixe')) {
        this.hosting = 'Arvixe';
        this.technologies.push('Arvixe');
      } else if (server.includes('midphase')) {
        this.hosting = 'Midphase';
        this.technologies.push('Midphase');
      } else if (server.includes('westhost')) {
        this.hosting = 'WestHost';
        this.technologies.push('WestHost');
      } else if (server.includes('powweb')) {
        this.hosting = 'PowWeb';
        this.technologies.push('PowWeb');
      } else if (server.includes('startlogic')) {
        this.hosting = 'StartLogic';
        this.technologies.push('StartLogic');
      } else if (server.includes('supergreen')) {
        this.hosting = 'SuperGreen Hosting';
        this.technologies.push('SuperGreen Hosting');
      } else if (server.includes('hostclear')) {
        this.hosting = 'HostClear';
        this.technologies.push('HostClear');
      } else if (server.includes('hostnine')) {
        this.hosting = 'HostNine';
        this.technologies.push('HostNine');
      }
    }
    
    // Detect hosting from powered-by header
    if (poweredBy) {
      if (poweredBy.includes('PHP')) {
        this.technologies.push('PHP');
      } else if (poweredBy.includes('ASP.NET')) {
        this.technologies.push('ASP.NET');
      } else if (poweredBy.includes('Express')) {
        this.technologies.push('Express.js');
      } else if (poweredBy.includes('Node.js')) {
        this.technologies.push('Node.js');
      } else if (poweredBy.includes('Python')) {
        this.technologies.push('Python');
      } else if (poweredBy.includes('Ruby')) {
        this.technologies.push('Ruby');
      } else if (poweredBy.includes('Java')) {
        this.technologies.push('Java');
      } else if (poweredBy.includes('Go')) {
        this.technologies.push('Go');
      } else if (poweredBy.includes('Rust')) {
        this.technologies.push('Rust');
      } else if (poweredBy.includes('C++')) {
        this.technologies.push('C++');
      } else if (poweredBy.includes('C#')) {
        this.technologies.push('C#');
      } else if (poweredBy.includes('Scala')) {
        this.technologies.push('Scala');
      } else if (poweredBy.includes('Kotlin')) {
        this.technologies.push('Kotlin');
      } else if (poweredBy.includes('Swift')) {
        this.technologies.push('Swift');
      } else if (poweredBy.includes('Objective-C')) {
        this.technologies.push('Objective-C');
      } else if (poweredBy.includes('Perl')) {
        this.technologies.push('Perl');
      } else if (poweredBy.includes('Lua')) {
        this.technologies.push('Lua');
      } else if (poweredBy.includes('Haskell')) {
        this.technologies.push('Haskell');
      } else if (poweredBy.includes('Erlang')) {
        this.technologies.push('Erlang');
      } else if (poweredBy.includes('Elixir')) {
        this.technologies.push('Elixir');
      } else if (poweredBy.includes('Clojure')) {
        this.technologies.push('Clojure');
      } else if (poweredBy.includes('F#')) {
        this.technologies.push('F#');
      } else if (poweredBy.includes('OCaml')) {
        this.technologies.push('OCaml');
      } else if (poweredBy.includes('R')) {
        this.technologies.push('R');
      } else if (poweredBy.includes('MATLAB')) {
        this.technologies.push('MATLAB');
      } else if (poweredBy.includes('Julia')) {
        this.technologies.push('Julia');
      } else if (poweredBy.includes('Dart')) {
        this.technologies.push('Dart');
      } else if (poweredBy.includes('TypeScript')) {
        this.technologies.push('TypeScript');
      } else if (poweredBy.includes('CoffeeScript')) {
        this.technologies.push('CoffeeScript');
      } else if (poweredBy.includes('LiveScript')) {
        this.technologies.push('LiveScript');
      } else if (poweredBy.includes('Elm')) {
        this.technologies.push('Elm');
      } else if (poweredBy.includes('PureScript')) {
        this.technologies.push('PureScript');
      } else if (poweredBy.includes('Reason')) {
        this.technologies.push('Reason');
      } else if (poweredBy.includes('ReScript')) {
        this.technologies.push('ReScript');
      } else if (poweredBy.includes('Svelte')) {
        this.technologies.push('Svelte');
      } else if (poweredBy.includes('Alpine.js')) {
        this.technologies.push('Alpine.js');
      } else if (poweredBy.includes('Stimulus')) {
        this.technologies.push('Stimulus');
      } else if (poweredBy.includes('Hotwire')) {
        this.technologies.push('Hotwire');
      } else if (poweredBy.includes('Turbo')) {
        this.technologies.push('Turbo');
      } else if (poweredBy.includes('Strada')) {
        this.technologies.push('Strada');
      } else if (poweredBy.includes('Phoenix')) {
        this.technologies.push('Phoenix');
      } else if (poweredBy.includes('LiveView')) {
        this.technologies.push('LiveView');
      } else if (poweredBy.includes('Blazor')) {
        this.technologies.push('Blazor');
      } else if (poweredBy.includes('WebAssembly')) {
        this.technologies.push('WebAssembly');
      } else if (poweredBy.includes('WASM')) {
        this.technologies.push('WebAssembly');
      } else if (poweredBy.includes('WebGL')) {
        this.technologies.push('WebGL');
      } else if (poweredBy.includes('Canvas')) {
        this.technologies.push('Canvas');
      } else if (poweredBy.includes('SVG')) {
        this.technologies.push('SVG');
      } else if (poweredBy.includes('WebRTC')) {
        this.technologies.push('WebRTC');
      } else if (poweredBy.includes('WebSocket')) {
        this.technologies.push('WebSocket');
      } else if (poweredBy.includes('Server-Sent Events')) {
        this.technologies.push('Server-Sent Events');
      } else if (poweredBy.includes('SSE')) {
        this.technologies.push('Server-Sent Events');
      } else if (poweredBy.includes('GraphQL')) {
        this.technologies.push('GraphQL');
      } else if (poweredBy.includes('REST')) {
        this.technologies.push('REST API');
      } else if (poweredBy.includes('SOAP')) {
        this.technologies.push('SOAP');
      } else if (poweredBy.includes('gRPC')) {
        this.technologies.push('gRPC');
      } else if (poweredBy.includes('Protocol Buffers')) {
        this.technologies.push('Protocol Buffers');
      } else if (poweredBy.includes('protobuf')) {
        this.technologies.push('Protocol Buffers');
      } else if (poweredBy.includes('MessagePack')) {
        this.technologies.push('MessagePack');
      } else if (poweredBy.includes('BSON')) {
        this.technologies.push('BSON');
      } else if (poweredBy.includes('XML')) {
        this.technologies.push('XML');
      } else if (poweredBy.includes('YAML')) {
        this.technologies.push('YAML');
      } else if (poweredBy.includes('TOML')) {
        this.technologies.push('TOML');
      } else if (poweredBy.includes('INI')) {
        this.technologies.push('INI');
      } else if (poweredBy.includes('JSON')) {
        this.technologies.push('JSON');
      } else if (poweredBy.includes('CSV')) {
        this.technologies.push('CSV');
      } else if (poweredBy.includes('TSV')) {
        this.technologies.push('TSV');
      } else if (poweredBy.includes('Markdown')) {
        this.technologies.push('Markdown');
      } else if (poweredBy.includes('AsciiDoc')) {
        this.technologies.push('AsciiDoc');
      } else if (poweredBy.includes('reStructuredText')) {
        this.technologies.push('reStructuredText');
      } else if (poweredBy.includes('Textile')) {
        this.technologies.push('Textile');
      } else if (poweredBy.includes('WikiText')) {
        this.technologies.push('WikiText');
      } else if (poweredBy.includes('BBCode')) {
        this.technologies.push('BBCode');
      } else if (poweredBy.includes('HTML')) {
        this.technologies.push('HTML');
      } else if (poweredBy.includes('CSS')) {
        this.technologies.push('CSS');
      } else if (poweredBy.includes('JavaScript')) {
        this.technologies.push('JavaScript');
      } else if (poweredBy.includes('JS')) {
        this.technologies.push('JavaScript');
      } else if (poweredBy.includes('ECMAScript')) {
        this.technologies.push('ECMAScript');
      } else if (poweredBy.includes('ES6')) {
        this.technologies.push('ECMAScript 6');
      } else if (poweredBy.includes('ES2015')) {
        this.technologies.push('ECMAScript 2015');
      } else if (poweredBy.includes('ES2016')) {
        this.technologies.push('ECMAScript 2016');
      } else if (poweredBy.includes('ES2017')) {
        this.technologies.push('ECMAScript 2017');
      } else if (poweredBy.includes('ES2018')) {
        this.technologies.push('ECMAScript 2018');
      } else if (poweredBy.includes('ES2019')) {
        this.technologies.push('ECMAScript 2019');
      } else if (poweredBy.includes('ES2020')) {
        this.technologies.push('ECMAScript 2020');
      } else if (poweredBy.includes('ES2021')) {
        this.technologies.push('ECMAScript 2021');
      } else if (poweredBy.includes('ES2022')) {
        this.technologies.push('ECMAScript 2022');
      } else if (poweredBy.includes('ES2023')) {
        this.technologies.push('ECMAScript 2023');
      } else if (poweredBy.includes('ES2024')) {
        this.technologies.push('ECMAScript 2024');
      }
    }
    
    // Detect hosting from Via header
    if (via) {
      if (via.includes('cloudflare')) {
        this.hosting = 'Cloudflare';
        this.technologies.push('Cloudflare');
      } else if (via.includes('fastly')) {
        this.hosting = 'Fastly';
        this.technologies.push('Fastly');
      } else if (via.includes('akamai')) {
        this.hosting = 'Akamai';
        this.technologies.push('Akamai');
      } else if (via.includes('cloudfront')) {
        this.hosting = 'AWS CloudFront';
        this.technologies.push('AWS CloudFront');
      } else if (via.includes('google')) {
        this.hosting = 'Google Cloud';
        this.technologies.push('Google Cloud');
      } else if (via.includes('azure')) {
        this.hosting = 'Microsoft Azure';
        this.technologies.push('Microsoft Azure');
      } else if (via.includes('heroku')) {
        this.hosting = 'Heroku';
        this.technologies.push('Heroku');
      } else if (via.includes('vercel')) {
        this.hosting = 'Vercel';
        this.technologies.push('Vercel');
      } else if (via.includes('netlify')) {
        this.hosting = 'Netlify';
        this.technologies.push('Netlify');
      } else if (via.includes('firebase')) {
        this.hosting = 'Firebase';
        this.technologies.push('Firebase');
      } else if (via.includes('digitalocean')) {
        this.hosting = 'DigitalOcean';
        this.technologies.push('DigitalOcean');
      } else if (via.includes('linode')) {
        this.hosting = 'Linode';
        this.technologies.push('Linode');
      } else if (via.includes('vultr')) {
        this.hosting = 'Vultr';
        this.technologies.push('Vultr');
      } else if (via.includes('ovh')) {
        this.hosting = 'OVH';
        this.technologies.push('OVH');
      } else if (via.includes('godaddy')) {
        this.hosting = 'GoDaddy';
        this.technologies.push('GoDaddy');
      } else if (via.includes('hostgator')) {
        this.hosting = 'HostGator';
        this.technologies.push('HostGator');
      } else if (via.includes('bluehost')) {
        this.hosting = 'Bluehost';
        this.technologies.push('Bluehost');
      } else if (via.includes('dreamhost')) {
        this.hosting = 'DreamHost';
        this.technologies.push('DreamHost');
      } else if (via.includes('siteground')) {
        this.hosting = 'SiteGround';
        this.technologies.push('SiteGround');
      } else if (via.includes('a2hosting')) {
        this.hosting = 'A2 Hosting';
        this.technologies.push('A2 Hosting');
      } else if (via.includes('inmotion')) {
        this.hosting = 'InMotion Hosting';
        this.technologies.push('InMotion Hosting');
      } else if (via.includes('hostinger')) {
        this.hosting = 'Hostinger';
        this.technologies.push('Hostinger');
      } else if (via.includes('namecheap')) {
        this.hosting = 'Namecheap';
        this.technologies.push('Namecheap');
      } else if (via.includes('ionos')) {
        this.hosting = 'IONOS';
        this.technologies.push('IONOS');
      } else if (via.includes('1and1')) {
        this.hosting = '1&1 IONOS';
        this.technologies.push('1&1 IONOS');
      } else if (via.includes('webhost')) {
        this.hosting = 'WebHost';
        this.technologies.push('WebHost');
      } else if (via.includes('hostmonster')) {
        this.hosting = 'HostMonster';
        this.technologies.push('HostMonster');
      } else if (via.includes('justhost')) {
        this.hosting = 'JustHost';
        this.technologies.push('JustHost');
      } else if (via.includes('ipage')) {
        this.hosting = 'iPage';
        this.technologies.push('iPage');
      } else if (via.includes('fatcow')) {
        this.hosting = 'FatCow';
        this.technologies.push('FatCow');
      } else if (via.includes('hostpapa')) {
        this.hosting = 'HostPapa';
        this.technologies.push('HostPapa');
      } else if (via.includes('greengeeks')) {
        this.hosting = 'GreenGeeks';
        this.technologies.push('GreenGeeks');
      } else if (via.includes('webhostingpad')) {
        this.hosting = 'WebHostingPad';
        this.technologies.push('WebHostingPad');
      } else if (via.includes('arvixe')) {
        this.hosting = 'Arvixe';
        this.technologies.push('Arvixe');
      } else if (via.includes('midphase')) {
        this.hosting = 'Midphase';
        this.technologies.push('Midphase');
      } else if (via.includes('westhost')) {
        this.hosting = 'WestHost';
        this.technologies.push('WestHost');
      } else if (via.includes('powweb')) {
        this.hosting = 'PowWeb';
        this.technologies.push('PowWeb');
      } else if (via.includes('startlogic')) {
        this.hosting = 'StartLogic';
        this.technologies.push('StartLogic');
      } else if (via.includes('supergreen')) {
        this.hosting = 'SuperGreen Hosting';
        this.technologies.push('SuperGreen Hosting');
      } else if (via.includes('hostclear')) {
        this.hosting = 'HostClear';
        this.technologies.push('HostClear');
      } else if (via.includes('hostnine')) {
        this.hosting = 'HostNine';
        this.technologies.push('HostNine');
      }
    }
    
    // Detect hosting from CF-Ray header (Cloudflare specific)
    if (cfRay) {
      this.hosting = 'Cloudflare';
      this.technologies.push('Cloudflare');
    }
    
    // If no specific hosting detected, try to infer from URL
    if (!this.hosting) {
      const url = this.url.toLowerCase();
      if (url.includes('vercel.app') || url.includes('vercel.com')) {
        this.hosting = 'Vercel';
        this.technologies.push('Vercel');
      } else if (url.includes('netlify.app') || url.includes('netlify.com')) {
        this.hosting = 'Netlify';
        this.technologies.push('Netlify');
      } else if (url.includes('firebaseapp.com')) {
        this.hosting = 'Firebase';
        this.technologies.push('Firebase');
      } else if (url.includes('herokuapp.com')) {
        this.hosting = 'Heroku';
        this.technologies.push('Heroku');
      } else if (url.includes('amazonaws.com') || url.includes('aws')) {
        this.hosting = 'AWS';
        this.technologies.push('AWS');
      } else if (url.includes('googleapis.com') || url.includes('google.com')) {
        this.hosting = 'Google Cloud';
        this.technologies.push('Google Cloud');
      } else if (url.includes('azurewebsites.net') || url.includes('azure.com')) {
        this.hosting = 'Microsoft Azure';
        this.technologies.push('Microsoft Azure');
      } else if (url.includes('digitalocean.com')) {
        this.hosting = 'DigitalOcean';
        this.technologies.push('DigitalOcean');
      } else if (url.includes('linode.com')) {
        this.hosting = 'Linode';
        this.technologies.push('Linode');
      } else if (url.includes('vultr.com')) {
        this.hosting = 'Vultr';
        this.technologies.push('Vultr');
      } else if (url.includes('ovh.com')) {
        this.hosting = 'OVH';
        this.technologies.push('OVH');
      } else if (url.includes('godaddy.com')) {
        this.hosting = 'GoDaddy';
        this.technologies.push('GoDaddy');
      } else if (url.includes('hostgator.com')) {
        this.hosting = 'HostGator';
        this.technologies.push('HostGator');
      } else if (url.includes('bluehost.com')) {
        this.hosting = 'Bluehost';
        this.technologies.push('Bluehost');
      } else if (url.includes('dreamhost.com')) {
        this.hosting = 'DreamHost';
        this.technologies.push('DreamHost');
      } else if (url.includes('siteground.com')) {
        this.hosting = 'SiteGround';
        this.technologies.push('SiteGround');
      } else if (url.includes('a2hosting.com')) {
        this.hosting = 'A2 Hosting';
        this.technologies.push('A2 Hosting');
      } else if (url.includes('inmotionhosting.com')) {
        this.hosting = 'InMotion Hosting';
        this.technologies.push('InMotion Hosting');
      } else if (url.includes('hostinger.com')) {
        this.hosting = 'Hostinger';
        this.technologies.push('Hostinger');
      } else if (url.includes('namecheap.com')) {
        this.hosting = 'Namecheap';
        this.technologies.push('Namecheap');
      } else if (url.includes('ionos.com')) {
        this.hosting = 'IONOS';
        this.technologies.push('IONOS');
      } else if (url.includes('1and1.com')) {
        this.hosting = '1&1 IONOS';
        this.technologies.push('1&1 IONOS');
      } else if (url.includes('webhost.com')) {
        this.hosting = 'WebHost';
        this.technologies.push('WebHost');
      } else if (url.includes('hostmonster.com')) {
        this.hosting = 'HostMonster';
        this.technologies.push('HostMonster');
      } else if (url.includes('justhost.com')) {
        this.hosting = 'JustHost';
        this.technologies.push('JustHost');
      } else if (url.includes('ipage.com')) {
        this.hosting = 'iPage';
        this.technologies.push('iPage');
      } else if (url.includes('fatcow.com')) {
        this.hosting = 'FatCow';
        this.technologies.push('FatCow');
      } else if (url.includes('hostpapa.com')) {
        this.hosting = 'HostPapa';
        this.technologies.push('HostPapa');
      } else if (url.includes('greengeeks.com')) {
        this.hosting = 'GreenGeeks';
        this.technologies.push('GreenGeeks');
      } else if (url.includes('webhostingpad.com')) {
        this.hosting = 'WebHostingPad';
        this.technologies.push('WebHostingPad');
      } else if (url.includes('arvixe.com')) {
        this.hosting = 'Arvixe';
        this.technologies.push('Arvixe');
      } else if (url.includes('midphase.com')) {
        this.hosting = 'Midphase';
        this.technologies.push('Midphase');
      } else if (url.includes('westhost.com')) {
        this.hosting = 'WestHost';
        this.technologies.push('WestHost');
      } else if (url.includes('powweb.com')) {
        this.hosting = 'PowWeb';
        this.technologies.push('PowWeb');
      } else if (url.includes('startlogic.com')) {
        this.hosting = 'StartLogic';
        this.technologies.push('StartLogic');
      } else if (url.includes('supergreenhosting.com')) {
        this.hosting = 'SuperGreen Hosting';
        this.technologies.push('SuperGreen Hosting');
      } else if (url.includes('hostclear.com')) {
        this.hosting = 'HostClear';
        this.technologies.push('HostClear');
      } else if (url.includes('hostnine.com')) {
        this.hosting = 'HostNine';
        this.technologies.push('HostNine');
      }
    }
  }

  private detectFrameworks(html: string): void {
    // React detection
    if (html.includes('react') || html.includes('reactjs') || html.includes('react-dom')) {
      this.addFramework('React');
    }
    
    // Angular detection
    if (html.includes('angular') || html.includes('ng-') || html.includes('angularjs')) {
      this.addFramework('Angular');
    }
    
    // Vue.js detection
    if (html.includes('vue') || html.includes('v-') || html.includes('vuejs')) {
      this.addFramework('Vue.js');
    }
    
    // jQuery detection
    if (html.includes('jquery') || html.includes('jquery.min.js')) {
      this.addFramework('jQuery');
    }
    
    // Bootstrap detection
    if (html.includes('bootstrap') || html.includes('bootstrap.min.css') || html.includes('bootstrap.min.js')) {
      this.addFramework('Bootstrap');
    }
    
    // Tailwind CSS detection
    if (html.includes('tailwind') || html.includes('tailwindcss')) {
      this.addFramework('Tailwind CSS');
    }
    
    // Material-UI detection
    if (html.includes('material-ui') || html.includes('mui') || html.includes('@mui/')) {
      this.addFramework('Material-UI');
    }
    
    // Ant Design detection
    if (html.includes('antd') || html.includes('ant-design')) {
      this.addFramework('Ant Design');
    }
    
    // Chakra UI detection
    if (html.includes('chakra') || html.includes('chakra-ui')) {
      this.addFramework('Chakra UI');
    }
    
    // Next.js detection
    if (html.includes('next') || html.includes('__next') || html.includes('nextjs')) {
      this.addFramework('Next.js');
    }
    
    // Nuxt.js detection
    if (html.includes('nuxt') || html.includes('nuxtjs')) {
      this.addFramework('Nuxt.js');
    }
    
    // Gatsby detection
    if (html.includes('gatsby') || html.includes('gatsbyjs')) {
      this.addFramework('Gatsby');
    }
  }

  private detectCMS(html: string): void {
    // WordPress detection
    if (html.includes('wp-content') || html.includes('wp-includes') || html.includes('wordpress') || 
        html.includes('wp-json') || html.includes('wp-admin')) {
      this.cms = 'WordPress';
      this.technologies.push('WordPress');
    }
    // Drupal detection
    else if (html.includes('drupal') || html.includes('drupal.js') || html.includes('drupal.css')) {
      this.cms = 'Drupal';
      this.technologies.push('Drupal');
    }
    // Joomla detection
    else if (html.includes('joomla') || html.includes('joomla.js') || html.includes('joomla.css')) {
      this.cms = 'Joomla';
      this.technologies.push('Joomla');
    }
    // Shopify detection
    else if (html.includes('shopify') || html.includes('shopify.com') || html.includes('myshopify.com')) {
      this.cms = 'Shopify';
      this.technologies.push('Shopify');
    }
    // Wix detection
    else if (html.includes('wix') || html.includes('wixsite.com') || html.includes('wix.com')) {
      this.cms = 'Wix';
      this.technologies.push('Wix');
    }
    // Squarespace detection
    else if (html.includes('squarespace') || html.includes('squarespace.com')) {
      this.cms = 'Squarespace';
      this.technologies.push('Squarespace');
    }
    // Ghost detection
    else if (html.includes('ghost') || html.includes('ghost.org')) {
      this.cms = 'Ghost';
      this.technologies.push('Ghost');
    }
    // Hugo detection
    else if (html.includes('hugo') || html.includes('hugo.js')) {
      this.cms = 'Hugo';
      this.technologies.push('Hugo');
    }
    // Jekyll detection
    else if (html.includes('jekyll') || html.includes('jekyll.js')) {
      this.cms = 'Jekyll';
      this.technologies.push('Jekyll');
    }
  }

  private detectTechnologiesFromContent(html: string): void {
    // Google Analytics detection
    if (html.includes('google-analytics.com') || html.includes('gtag') || html.includes('ga(') || 
        html.includes('googletagmanager.com') || html.includes('gtm.js')) {
      this.addTechnology('Google Analytics');
    }
    
    // Facebook Pixel detection
    if (html.includes('facebook.net') || html.includes('fbq') || html.includes('facebook.com/tr')) {
      this.addTechnology('Facebook Pixel');
    }
    
    // Stripe detection
    if (html.includes('stripe.com') || html.includes('stripe.js') || html.includes('stripe-js')) {
      this.addTechnology('Stripe');
    }
    
    // PayPal detection
    if (html.includes('paypal.com') || html.includes('paypal.js') || html.includes('paypalobjects.com')) {
      this.addTechnology('PayPal');
    }
    
    // reCAPTCHA detection
    if (html.includes('recaptcha') || html.includes('g-recaptcha') || html.includes('recaptcha.js')) {
      this.addTechnology('reCAPTCHA');
    }
    
    // AWS detection
    if (html.includes('aws') || html.includes('amazonaws.com') || html.includes('s3.amazonaws.com')) {
      this.addTechnology('AWS');
    }
    
    // Google Cloud detection
    if (html.includes('google-cloud') || html.includes('gcp') || html.includes('googleapis.com')) {
      this.addTechnology('Google Cloud');
    }
    
    // Azure detection
    if (html.includes('azure') || html.includes('microsoft.com') || html.includes('azurewebsites.net')) {
      this.addTechnology('Microsoft Azure');
    }
    
    // Vercel detection
    if (html.includes('vercel') || html.includes('vercel.app') || html.includes('vercel.com')) {
      this.addTechnology('Vercel');
    }
    
    // Netlify detection
    if (html.includes('netlify') || html.includes('netlify.app') || html.includes('netlify.com')) {
      this.addTechnology('Netlify');
    }
    
    // Firebase detection
    if (html.includes('firebase') || html.includes('firebaseapp.com') || html.includes('firebase.js')) {
      this.addTechnology('Firebase');
    }
    
    // Sentry detection
    if (html.includes('sentry') || html.includes('sentry.io') || html.includes('sentry.js')) {
      this.addTechnology('Sentry');
    }
    
    // Mixpanel detection
    if (html.includes('mixpanel') || html.includes('mixpanel.com') || html.includes('mixpanel.js')) {
      this.addTechnology('Mixpanel');
    }
    
    // Hotjar detection
    if (html.includes('hotjar') || html.includes('hotjar.com') || html.includes('hjsv')) {
      this.addTechnology('Hotjar');
    }
    
    // Intercom detection
    if (html.includes('intercom') || html.includes('intercom.io') || html.includes('intercom.js')) {
      this.addTechnology('Intercom');
    }
    
    // Zendesk detection
    if (html.includes('zendesk') || html.includes('zendesk.com') || html.includes('zdassets.com')) {
      this.addTechnology('Zendesk');
    }
    
    // Mailchimp detection
    if (html.includes('mailchimp') || html.includes('mailchimp.com') || html.includes('chimpstatic.com')) {
      this.addTechnology('Mailchimp');
    }
    
    // HubSpot detection
    if (html.includes('hubspot') || html.includes('hubspot.com') || html.includes('hs-scripts.com')) {
      this.addTechnology('HubSpot');
    }
    
    // Salesforce detection
    if (html.includes('salesforce') || html.includes('force.com') || html.includes('salesforce.com')) {
      this.addTechnology('Salesforce');
    }
    
    // WooCommerce detection
    if (html.includes('woocommerce') || html.includes('wc-') || html.includes('woocommerce.js')) {
      this.addTechnology('WooCommerce');
    }
    
    // Magento detection
    if (html.includes('magento') || html.includes('magento.js') || html.includes('magento.css')) {
      this.addTechnology('Magento');
    }
    
    // PrestaShop detection
    if (html.includes('prestashop') || html.includes('prestashop.js')) {
      this.addTechnology('PrestaShop');
    }
    
    // OpenCart detection
    if (html.includes('opencart') || html.includes('opencart.js')) {
      this.addTechnology('OpenCart');
    }
    
    // Laravel detection
    if (html.includes('laravel') || html.includes('laravel.js') || html.includes('laravel.css')) {
      this.addTechnology('Laravel');
    }
    
    // Django detection
    if (html.includes('django') || html.includes('django.js') || html.includes('django.css')) {
      this.addTechnology('Django');
    }
    
    // Ruby on Rails detection
    if (html.includes('rails') || html.includes('ruby on rails') || html.includes('rails.js')) {
      this.addTechnology('Ruby on Rails');
    }
    
    // Express.js detection
    if (html.includes('express') || html.includes('expressjs') || html.includes('express.js')) {
      this.addTechnology('Express.js');
    }
    
    // Webpack detection
    if (html.includes('webpack') || html.includes('webpack.js') || html.includes('webpack-dev-server')) {
      this.addTechnology('Webpack');
    }
    
    // Vite detection
    if (html.includes('vite') || html.includes('vite.js') || html.includes('@vitejs')) {
      this.addTechnology('Vite');
    }
    
    // Parcel detection
    if (html.includes('parcel') || html.includes('parcel.js')) {
      this.addTechnology('Parcel');
    }
    
    // Rollup detection
    if (html.includes('rollup') || html.includes('rollup.js')) {
      this.addTechnology('Rollup');
    }
    
    // Babel detection
    if (html.includes('babel') || html.includes('babel.js') || html.includes('@babel')) {
      this.addTechnology('Babel');
    }
    
    // TypeScript detection
    if (html.includes('typescript') || html.includes('ts-') || html.includes('.ts')) {
      this.addTechnology('TypeScript');
    }
    
    // Sass/SCSS detection
    if (html.includes('sass') || html.includes('scss') || html.includes('.scss')) {
      this.addTechnology('Sass/SCSS');
    }
    
    // Less detection
    if (html.includes('less') || html.includes('.less')) {
      this.addTechnology('Less');
    }
    
    // PostCSS detection
    if (html.includes('postcss') || html.includes('postcss.js')) {
      this.addTechnology('PostCSS');
    }
    
    // Autoprefixer detection
    if (html.includes('autoprefixer') || html.includes('autoprefixer.js')) {
      this.addTechnology('Autoprefixer');
    }
    
    // ESLint detection
    if (html.includes('eslint') || html.includes('eslint.js')) {
      this.addTechnology('ESLint');
    }
    
    // Prettier detection
    if (html.includes('prettier') || html.includes('prettier.js')) {
      this.addTechnology('Prettier');
    }
    
    // Jest detection
    if (html.includes('jest') || html.includes('jest.js')) {
      this.addTechnology('Jest');
    }
    
    // Cypress detection
    if (html.includes('cypress') || html.includes('cypress.js')) {
      this.addTechnology('Cypress');
    }
    
    // Playwright detection
    if (html.includes('playwright') || html.includes('playwright.js')) {
      this.addTechnology('Playwright');
    }
    
    // Selenium detection
    if (html.includes('selenium') || html.includes('selenium.js')) {
      this.addTechnology('Selenium');
    }
    
    // Docker detection
    if (html.includes('docker') || html.includes('docker.js')) {
      this.addTechnology('Docker');
    }
    
    // Kubernetes detection
    if (html.includes('kubernetes') || html.includes('k8s') || html.includes('kube')) {
      this.addTechnology('Kubernetes');
    }
    
    // Terraform detection
    if (html.includes('terraform') || html.includes('terraform.js')) {
      this.addTechnology('Terraform');
    }
    
    // Ansible detection
    if (html.includes('ansible') || html.includes('ansible.js')) {
      this.addTechnology('Ansible');
    }
    
    // Jenkins detection
    if (html.includes('jenkins') || html.includes('jenkins.js')) {
      this.addTechnology('Jenkins');
    }
    
    // GitHub Actions detection
    if (html.includes('github actions') || html.includes('github.com/actions')) {
      this.addTechnology('GitHub Actions');
    }
    
    // GitLab CI detection
    if (html.includes('gitlab ci') || html.includes('gitlab.com/ci')) {
      this.addTechnology('GitLab CI');
    }
    
    // CircleCI detection
    if (html.includes('circleci') || html.includes('circleci.com')) {
      this.addTechnology('CircleCI');
    }
    
    // Travis CI detection
    if (html.includes('travis ci') || html.includes('travis-ci.com')) {
      this.addTechnology('Travis CI');
    }
  }

  private detectTechnologiesFromScripts(): void {
    try {
      // Parse the DOM to find script tags
      const scripts = this.dom.window.document.querySelectorAll('script[src]');
      
      scripts.forEach((script) => {
        const src = script.getAttribute('src')?.toLowerCase() || '';
        
        // Detect CDN technologies
        if (src.includes('cdnjs.cloudflare.com')) {
          this.addTechnology('Cloudflare CDN');
        }
        if (src.includes('unpkg.com')) {
          this.addTechnology('unpkg CDN');
        }
        if (src.includes('jsdelivr.net')) {
          this.addTechnology('jsDelivr CDN');
        }
        if (src.includes('cdn.jsdelivr.net')) {
          this.addTechnology('jsDelivr CDN');
        }
        
        // Detect specific libraries from CDN
        if (src.includes('jquery')) {
          this.addFramework('jQuery');
        }
        if (src.includes('bootstrap')) {
          this.addFramework('Bootstrap');
        }
        if (src.includes('react')) {
          this.addFramework('React');
        }
        if (src.includes('vue')) {
          this.addFramework('Vue.js');
        }
        if (src.includes('angular')) {
          this.addFramework('Angular');
        }
        
        // Detect analytics and tracking
        if (src.includes('google-analytics.com') || src.includes('googletagmanager.com')) {
          this.addTechnology('Google Analytics');
        }
        if (src.includes('facebook.net')) {
          this.addTechnology('Facebook Pixel');
        }
        if (src.includes('hotjar.com')) {
          this.addTechnology('Hotjar');
        }
        if (src.includes('mixpanel.com')) {
          this.addTechnology('Mixpanel');
        }
        if (src.includes('sentry.io')) {
          this.addTechnology('Sentry');
        }
        
        // Detect payment processors
        if (src.includes('stripe.com')) {
          this.addTechnology('Stripe');
        }
        if (src.includes('paypal.com')) {
          this.addTechnology('PayPal');
        }
        
        // Detect security
        if (src.includes('recaptcha')) {
          this.addTechnology('reCAPTCHA');
        }
        
        // Detect hosting and cloud services
        if (src.includes('vercel.app') || src.includes('vercel.com')) {
          this.addTechnology('Vercel');
        }
        if (src.includes('netlify.app') || src.includes('netlify.com')) {
          this.addTechnology('Netlify');
        }
        if (src.includes('firebaseapp.com')) {
          this.addTechnology('Firebase');
        }
        if (src.includes('amazonaws.com')) {
          this.addTechnology('AWS');
        }
        if (src.includes('googleapis.com')) {
          this.addTechnology('Google Cloud');
        }
        if (src.includes('azurewebsites.net')) {
          this.addTechnology('Microsoft Azure');
        }
      });
      
      // Also check inline scripts for technology signatures
      const inlineScripts = this.dom.window.document.querySelectorAll('script:not([src])');
      inlineScripts.forEach((script) => {
        const content = script.textContent?.toLowerCase() || '';
        
        // Detect frameworks from inline scripts
        if (content.includes('react') || content.includes('reactdom')) {
          this.addFramework('React');
        }
        if (content.includes('vue') || content.includes('vuejs')) {
          this.addFramework('Vue.js');
        }
        if (content.includes('angular') || content.includes('angularjs')) {
          this.addFramework('Angular');
        }
        if (content.includes('jquery') || content.includes('$(')) {
          this.addFramework('jQuery');
        }
        
        // Detect analytics from inline scripts
        if (content.includes('gtag') || content.includes('ga(') || content.includes('googleanalytics')) {
          this.addTechnology('Google Analytics');
        }
        if (content.includes('fbq') || content.includes('facebook')) {
          this.addTechnology('Facebook Pixel');
        }
        if (content.includes('mixpanel')) {
          this.addTechnology('Mixpanel');
        }
        if (content.includes('hotjar')) {
          this.addTechnology('Hotjar');
        }
        if (content.includes('sentry')) {
          this.addTechnology('Sentry');
        }
        
        // Detect payment processors from inline scripts
        if (content.includes('stripe')) {
          this.addTechnology('Stripe');
        }
        if (content.includes('paypal')) {
          this.addTechnology('PayPal');
        }
      });
      
    } catch (error) {
      console.error('Error detecting technologies from scripts:', error);
    }
  }

  private parseHTML(): void {
    this.dom = new JSDOM(this.html);
  }

  private checkGDPR() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    console.log('Starting comprehensive GDPR compliance analysis for:', this.url);

    // 1. Cookie Banner Analysis (Real Detection)
    const cookieBannerAnalysis = this.analyzeCookieBanner();
    const hasCookieBanner = cookieBannerAnalysis.found;
    if (!hasCookieBanner) {
      issues.push('No cookie consent banner found');
      recommendations.push('Implement a cookie consent banner that clearly explains data collection and provides accept/reject options');
      score -= 15;
    } else {
      console.log('Cookie banner found:', cookieBannerAnalysis.details);
      if (!cookieBannerAnalysis.hasAcceptButton) {
        issues.push('Cookie banner found but missing accept button');
        recommendations.push('Add clear accept/reject buttons to cookie banner');
        score -= 5;
      }
      if (!cookieBannerAnalysis.hasRejectButton) {
        issues.push('Cookie banner found but missing reject option');
        recommendations.push('Add reject option to cookie banner for GDPR compliance');
        score -= 5;
      }
    }

    // 2. Privacy Policy Analysis (Real Detection)
    const privacyPolicyAnalysis = this.analyzePrivacyPolicy();
    const hasPrivacyPolicy = privacyPolicyAnalysis.found;
    if (!hasPrivacyPolicy) {
      issues.push('No privacy policy found');
      recommendations.push('Create and prominently link to a comprehensive privacy policy');
      score -= 15;
    } else {
      console.log('Privacy policy found:', privacyPolicyAnalysis.details);
      if (!privacyPolicyAnalysis.hasDataCollection) {
        issues.push('Privacy policy found but missing data collection information');
        recommendations.push('Add detailed data collection practices to privacy policy');
        score -= 5;
      }
      if (!privacyPolicyAnalysis.hasDataUsage) {
        issues.push('Privacy policy found but missing data usage information');
        recommendations.push('Add clear data usage purposes to privacy policy');
        score -= 5;
      }
    }

    // 3. Terms of Service Analysis (Real Detection)
    const termsAnalysis = this.analyzeTermsOfService();
    const hasTermsOfService = termsAnalysis.found;
    if (!hasTermsOfService) {
      issues.push('No terms of service found');
      recommendations.push('Create and link to terms of service');
      score -= 10;
    } else {
      console.log('Terms of service found:', termsAnalysis.details);
    }

    // 4. Data Processing Notice Analysis (Real Detection)
    const dataProcessingAnalysis = this.analyzeDataProcessingNotice();
    const hasDataProcessingNotice = dataProcessingAnalysis.found;
    if (!hasDataProcessingNotice) {
      issues.push('No data processing notice found');
      recommendations.push('Add clear data processing notices explaining how personal data is handled');
      score -= 10;
    } else {
      console.log('Data processing notice found:', dataProcessingAnalysis.details);
    }

    // 5. Cookie Policy Analysis (Real Detection)
    const cookiePolicyAnalysis = this.analyzeCookiePolicy();
    const hasCookiePolicy = cookiePolicyAnalysis.found;
    if (!hasCookiePolicy) {
      issues.push('No cookie policy found');
      recommendations.push('Create a detailed cookie policy explaining all cookie types and purposes');
      score -= 10;
    } else {
      console.log('Cookie policy found:', cookiePolicyAnalysis.details);
    }

    // 6. Data Retention Policy Analysis (Real Detection)
    const retentionAnalysis = this.analyzeDataRetentionPolicy();
    const hasDataRetentionPolicy = retentionAnalysis.found;
    if (!hasDataRetentionPolicy) {
      issues.push('No data retention policy found');
      recommendations.push('Define and publish data retention policies with specific timeframes');
      score -= 10;
    } else {
      console.log('Data retention policy found:', retentionAnalysis.details);
    }

    // 7. User Consent Mechanism Analysis (Real Detection)
    const consentAnalysis = this.analyzeUserConsentMechanism();
    const hasUserConsentMechanism = consentAnalysis.found;
    if (!hasUserConsentMechanism) {
      issues.push('No user consent mechanism found');
      recommendations.push('Implement granular consent mechanisms for different data processing activities');
      score -= 10;
    } else {
      console.log('User consent mechanism found:', consentAnalysis.details);
    }

    // 8. Data Portability Analysis (Real Detection)
    const portabilityAnalysis = this.analyzeDataPortability();
    const hasDataPortability = portabilityAnalysis.found;
    if (!hasDataPortability) {
      issues.push('No data portability option found');
      recommendations.push('Provide data export functionality for users to download their personal data');
      score -= 10;
    } else {
      console.log('Data portability option found:', portabilityAnalysis.details);
    }

    // 9. Right to Erasure Analysis (Real Detection)
    const erasureAnalysis = this.analyzeRightToErasure();
    const hasRightToErasure = erasureAnalysis.found;
    if (!hasRightToErasure) {
      issues.push('No right to erasure mechanism found');
      recommendations.push('Implement data deletion functionality for users to request data removal');
      score -= 10;
    } else {
      console.log('Right to erasure mechanism found:', erasureAnalysis.details);
    }

    // 10. Data Minimization Analysis (Real Detection)
    const minimizationAnalysis = this.analyzeDataMinimization();
    const hasDataMinimization = minimizationAnalysis.compliant;
    if (!hasDataMinimization) {
      issues.push('Data minimization not properly implemented');
      recommendations.push('Ensure data collection is minimized and only necessary for specific purposes');
      score -= 10;
    } else {
      console.log('Data minimization analysis:', minimizationAnalysis.details);
    }

    // 11. Purpose Limitation Analysis (Real Detection)
    const purposeAnalysis = this.analyzePurposeLimitation();
    const hasPurposeLimitation = purposeAnalysis.compliant;
    if (!hasPurposeLimitation) {
      issues.push('Purpose limitation not properly implemented');
      recommendations.push('Clearly state the purpose of data collection and ensure it is lawful');
      score -= 10;
    } else {
      console.log('Purpose limitation analysis:', purposeAnalysis.details);
    }

    // 12. Lawful Basis Analysis (Real Detection)
    const lawfulBasisAnalysis = this.analyzeLawfulBasis();
    const hasLawfulBasis = lawfulBasisAnalysis.compliant;
    if (!hasLawfulBasis) {
      issues.push('No lawful basis for data processing found');
      recommendations.push('Ensure data processing is based on a valid legal basis (consent, contract, legitimate interest, etc.)');
      score -= 10;
    } else {
      console.log('Lawful basis analysis:', lawfulBasisAnalysis.details);
    }

    // 13. Third-party Tracking Analysis (Real Detection)
    const trackingAnalysis = this.analyzeThirdPartyTracking();
    if (trackingAnalysis.hasTracking && !trackingAnalysis.hasConsent) {
      issues.push('Third-party tracking detected without proper consent mechanism');
      recommendations.push('Implement consent mechanism for third-party tracking and analytics');
      score -= 15;
    } else if (trackingAnalysis.hasTracking) {
      console.log('Third-party tracking analysis:', trackingAnalysis.details);
    }

    // 14. Data Transfer Analysis (Real Detection)
    const transferAnalysis = this.analyzeDataTransfer();
    if (transferAnalysis.hasInternationalTransfer && !transferAnalysis.hasSafeguards) {
      issues.push('International data transfer detected without proper safeguards');
      recommendations.push('Implement appropriate safeguards for international data transfers');
      score -= 10;
    } else if (transferAnalysis.hasInternationalTransfer) {
      console.log('Data transfer analysis:', transferAnalysis.details);
    }

    // 15. Data Protection Officer Analysis (Real Detection)
    const dpoAnalysis = this.analyzeDataProtectionOfficer();
    const hasDPO = dpoAnalysis.found;
    if (!hasDPO) {
      issues.push('No Data Protection Officer contact information found');
      recommendations.push('Appoint and publish contact information for Data Protection Officer if required');
      score -= 5;
    } else {
      console.log('Data Protection Officer found:', dpoAnalysis.details);
    }

    // 16. Data Breach Notification Analysis (Real Detection)
    const breachAnalysis = this.analyzeDataBreachNotification();
    const hasBreachNotification = breachAnalysis.found;
    if (!hasBreachNotification) {
      issues.push('No data breach notification procedure found');
      recommendations.push('Implement and publish data breach notification procedures');
      score -= 5;
    } else {
      console.log('Data breach notification found:', breachAnalysis.details);
    }

    // 17. Children's Data Protection Analysis (Real Detection)
    const childrenAnalysis = this.analyzeChildrenDataProtection();
    if (childrenAnalysis.hasChildrenData && !childrenAnalysis.hasProtection) {
      issues.push('Children\'s data processing detected without proper protection measures');
      recommendations.push('Implement enhanced protection measures for children\'s data processing');
      score -= 10;
    } else if (childrenAnalysis.hasChildrenData) {
      console.log('Children\'s data protection analysis:', childrenAnalysis.details);
    }

    // 18. Automated Decision Making Analysis (Real Detection)
    const automatedAnalysis = this.analyzeAutomatedDecisionMaking();
    if (automatedAnalysis.hasAutomatedDecisions && !automatedAnalysis.hasSafeguards) {
      issues.push('Automated decision making detected without proper safeguards');
      recommendations.push('Implement safeguards for automated decision making including human review rights');
      score -= 10;
    } else if (automatedAnalysis.hasAutomatedDecisions) {
      console.log('Automated decision making analysis:', automatedAnalysis.details);
    }

    // 19. Data Subject Rights Analysis (Real Detection)
    const rightsAnalysis = this.analyzeDataSubjectRights();
    const hasDataSubjectRights = rightsAnalysis.found;
    if (!hasDataSubjectRights) {
      issues.push('Data subject rights not clearly communicated');
      recommendations.push('Clearly communicate all data subject rights including access, rectification, erasure, and objection');
      score -= 10;
    } else {
      console.log('Data subject rights found:', rightsAnalysis.details);
    }

    // 20. Privacy by Design Analysis (Real Detection)
    const privacyByDesignAnalysis = this.analyzePrivacyByDesign();
    const hasPrivacyByDesign = privacyByDesignAnalysis.compliant;
    if (!hasPrivacyByDesign) {
      issues.push('Privacy by design principles not implemented');
      recommendations.push('Implement privacy by design principles in all data processing activities');
      score -= 5;
    } else {
      console.log('Privacy by design analysis:', privacyByDesignAnalysis.details);
    }

    console.log('GDPR compliance analysis completed. Score:', score, 'Issues:', issues.length);

    return {
      hasCookieBanner,
      hasPrivacyPolicy,
      hasTermsOfService,
      hasDataProcessingNotice,
      hasCookiePolicy,
      hasDataRetentionPolicy,
      hasUserConsentMechanism,
      hasDataPortability,
      hasRightToErasure,
      hasDataMinimization,
      hasPurposeLimitation,
      hasLawfulBasis,
      score: Math.max(0, score),
      issues,
      recommendations,
      complianceLevel: this.determineComplianceLevel(score),
    };
  }

  private checkAccessibility() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    // Check for alt text on images
    const images = this.dom.window.document.querySelectorAll('img');
    const imagesWithAlt = Array.from(images).filter((img: Element) => {
      const imgElement = img as HTMLImageElement;
      const alt = imgElement.getAttribute('alt');
      return alt !== null && alt.trim().length > 0;
    });
    
    const imagesWithoutAlt = images.length - imagesWithAlt.length;
    if (imagesWithoutAlt > 0) {
      issues.push(`${imagesWithoutAlt} images missing alt text`);
      recommendations.push('Add descriptive alt text to all images for screen readers');
      score -= Math.min(15, imagesWithoutAlt * 2);
    }

    // Check for proper heading structure
    const headings = this.dom.window.document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    const headingLevels = Array.from(headings).map(h => parseInt(h.tagName.charAt(1)));
    
    let headingStructureIssues = 0;
    let previousLevel = 0;
    
    for (const level of headingLevels) {
      if (level > previousLevel + 1) {
        headingStructureIssues++;
      }
      previousLevel = level;
    }
    
    if (headingStructureIssues > 0) {
      issues.push('Improper heading hierarchy detected');
      recommendations.push('Use proper heading hierarchy (h1, h2, h3, etc.) without skipping levels');
      score -= 10;
    }
    
    if (headings.length === 0) {
      issues.push('No heading structure found');
      recommendations.push('Implement proper heading hierarchy for better document structure');
      score -= 15;
    }

    // Check for keyboard navigation
    const hasKeyboardNavigation = this.checkKeyboardNavigation();
    if (!hasKeyboardNavigation) {
      issues.push('Limited keyboard navigation support');
      recommendations.push('Ensure all interactive elements are keyboard accessible');
      score -= 15;
    }

    // Check for screen reader support
    const hasScreenReaderSupport = this.checkScreenReaderSupport();
    if (!hasScreenReaderSupport) {
      issues.push('Limited screen reader support');
      recommendations.push('Add ARIA labels and semantic HTML elements');
      score -= 15;
    }

    // Check for focus indicators
    const hasFocusIndicators = this.checkFocusIndicators();
    if (!hasFocusIndicators) {
      issues.push('No visible focus indicators');
      recommendations.push('Add visible focus indicators for keyboard navigation');
      score -= 10;
    }

    // Check for skip links
    const hasSkipLinks = this.checkSkipLinks();
    if (!hasSkipLinks) {
      issues.push('No skip navigation links');
      recommendations.push('Add skip links for keyboard users');
      score -= 10;
    }

    // Check for ARIA labels
    const hasARIALabels = this.checkARIALabels();
    if (!hasARIALabels) {
      issues.push('Missing ARIA labels');
      recommendations.push('Add ARIA labels to interactive elements');
      score -= 10;
    }

    // Check for semantic HTML
    const hasSemanticHTML = this.checkSemanticHTML();
    if (!hasSemanticHTML) {
      issues.push('Limited semantic HTML usage');
      recommendations.push('Use semantic HTML elements (nav, main, article, etc.)');
      score -= 10;
    }

    // Check for form labels
    const formInputs = this.dom.window.document.querySelectorAll('input, select, textarea');
    const inputsWithLabels = Array.from(formInputs).filter(input => {
      const inputElement = input as HTMLInputElement;
      const id = inputElement.id;
      if (id) {
        const label = this.dom.window.document.querySelector(`label[for="${id}"]`);
        if (label) return true;
      }
      
      // Check for parent label
      const parentLabel = inputElement.closest('label');
      if (parentLabel) return true;
      
      // Check for aria-label
      const ariaLabel = inputElement.getAttribute('aria-label');
      if (ariaLabel && ariaLabel.trim()) return true;
      
      return false;
    });
    
    const inputsWithoutLabels = formInputs.length - inputsWithLabels.length;
    if (inputsWithoutLabels > 0) {
      issues.push(`${inputsWithoutLabels} form inputs missing labels`);
      recommendations.push('Add proper labels to all form inputs');
      score -= Math.min(10, inputsWithoutLabels * 2);
    }

    // Check for color contrast (simplified)
    const hasContrastRatio = this.checkContrastRatio();
    if (!hasContrastRatio) {
      issues.push('Potential color contrast issues');
      recommendations.push('Ensure sufficient color contrast for text readability');
      score -= 10;
    }

    return {
      hasAltText: imagesWithAlt.length > 0 || images.length === 0,
      hasProperHeadings: headings.length > 0 && headingStructureIssues === 0,
      hasContrastRatio,
      hasKeyboardNavigation,
      hasScreenReaderSupport,
      hasFocusIndicators,
      hasSkipLinks,
      hasARIALabels,
      hasSemanticHTML,
      hasFormLabels: inputsWithLabels.length > 0,
      hasLanguageDeclaration: this.checkLanguageDeclaration(),
      hasErrorHandling: this.checkErrorHandling(),
      score: Math.max(0, score),
      issues,
      recommendations,
      wcagLevel: this.determineWCAGLevel(score),
    };
  }

  private checkSecurity() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 0; // Start from 0 and add points for good practices

    console.log('Starting comprehensive security analysis for:', this.url);

    // 1. Real HTTPS Analysis (Actual Detection) - CRITICAL: 25 points
    const httpsAnalysis = this.analyzeHTTPS();
    if (httpsAnalysis.enabled) {
      score += 25;
      console.log(' HTTPS enabled: +25 points');
    } else {
      issues.push('Website not using HTTPS');
      recommendations.push('Implement SSL/TLS encryption for secure data transmission');
      console.log(' HTTPS not enabled: 0 points');
    }

    // 2. Real Security Headers Analysis (Actual Detection) - IMPORTANT: Up to 20 points
    const securityHeadersAnalysis = this.analyzeSecurityHeaders();
    const headerScore = securityHeadersAnalysis.details.totalHeaders * 4; // 4 points per header
    score += headerScore;
    
    if (headerScore < 20) {
      issues.push('Missing important security headers');
      recommendations.push('Implement security headers: X-Frame-Options, X-Content-Type-Options, etc.');
    }
    console.log(` Security headers: +${headerScore} points (${securityHeadersAnalysis.details.totalHeaders}/5 headers)`);

    // 3. Real Content Security Policy Analysis (Actual Detection) - IMPORTANT: 15 points
    const cspAnalysis = this.analyzeContentSecurityPolicy();
    if (cspAnalysis.enabled) {
      score += 15;
      console.log(' CSP enabled: +15 points');
    } else {
      issues.push('No Content Security Policy found');
      recommendations.push('Implement Content Security Policy to prevent XSS attacks');
      console.log(' CSP not enabled: 0 points');
    }

    // 4. Real HSTS Analysis (Actual Detection) - IMPORTANT: 10 points
    const hstsAnalysis = this.analyzeHSTS();
    if (hstsAnalysis.enabled) {
      score += 10;
      console.log(' HSTS enabled: +10 points');
    } else {
      issues.push('No HTTP Strict Transport Security');
      recommendations.push('Enable HSTS header to enforce HTTPS connections');
      console.log(' HSTS not enabled: 0 points');
    }

    // 5. Real XSS Protection Analysis (Actual Detection) - IMPORTANT: 10 points
    const xssAnalysis = this.analyzeXSSProtection();
    if (xssAnalysis.protected) {
      score += 10;
      console.log(' XSS protection: +10 points');
    } else {
      issues.push(xssAnalysis.issues.join(', '));
      recommendations.push('Implement XSS protection mechanisms');
      console.log(' XSS protection: 0 points');
    }

    // 6. Real CSRF Protection Analysis (Actual Detection) - MODERATE: 8 points
    const csrfAnalysis = this.analyzeCSRFProtection();
    if (csrfAnalysis.protected) {
      score += 8;
      console.log(' CSRF protection: +8 points');
    } else {
      issues.push('No CSRF protection detected');
      recommendations.push('Implement CSRF tokens or other CSRF protection mechanisms');
      console.log(' CSRF protection: 0 points');
    }

    // 7. Real Input Validation Analysis (Actual Detection) - MODERATE: 6 points
    const inputValidationAnalysis = this.analyzeInputValidation();
    if (inputValidationAnalysis.validated) {
      score += 6;
      console.log(' Input validation: +6 points');
    } else {
      issues.push(inputValidationAnalysis.issues.join(', '));
      recommendations.push('Implement proper input validation for all user inputs');
      console.log(' Input validation: 0 points');
    }

    // 8. Real Output Encoding Analysis (Actual Detection) - MODERATE: 6 points
    const outputEncodingAnalysis = this.analyzeOutputEncoding();
    if (outputEncodingAnalysis.encoded) {
      score += 6;
      console.log(' Output encoding: +6 points');
    } else {
      issues.push(outputEncodingAnalysis.issues.join(', '));
      recommendations.push('Ensure all output is properly encoded to prevent XSS');
      console.log(' Output encoding: 0 points');
    }

    // 9. Real Session Management Analysis (Actual Detection) - MODERATE: 6 points
    const sessionAnalysis = this.analyzeSessionManagement();
    if (sessionAnalysis.secure) {
      score += 6;
      console.log(' Session management: +6 points');
    } else {
      issues.push(sessionAnalysis.issues.join(', '));
      recommendations.push('Implement secure session management and secure cookie handling');
      console.log(' Session management: 0 points');
    }

    // 10. Real Cookie Security Analysis (Actual Detection) - MODERATE: 6 points
    const cookieAnalysis = this.analyzeCookieSecurity();
    if (cookieAnalysis.secure) {
      score += 6;
      console.log(' Cookie security: +6 points');
    } else {
      issues.push(cookieAnalysis.issues.join(', '));
      recommendations.push('Set Secure and HttpOnly flags for cookies');
      console.log(' Cookie security: 0 points');
    }

    // 11. Real Error Handling Analysis (Actual Detection) - MODERATE: 4 points
    const errorHandlingAnalysis = this.analyzeErrorHandling();
    if (errorHandlingAnalysis.secure) {
      score += 4;
      console.log(' Error handling: +4 points');
    } else {
      issues.push(errorHandlingAnalysis.issues.join(', '));
      recommendations.push('Ensure proper error handling and logging to prevent sensitive information exposure');
      console.log(' Error handling: 0 points');
    }

    // 12. Real Sensitive Information Exposure Analysis (Actual Detection) - CRITICAL: -10 points if exposed
    const sensitiveInfoAnalysis = this.analyzeSensitiveInformation();
    if (sensitiveInfoAnalysis.exposed) {
      issues.push(sensitiveInfoAnalysis.issues.join(', '));
      recommendations.push('Remove or properly secure sensitive information from HTML source');
      score -= 10;
      console.log(' Sensitive info exposed: -10 points');
    } else {
      console.log(' No sensitive info exposed: 0 points');
    }

    // 13. Real Open Redirect Analysis (Actual Detection) - CRITICAL: -10 points if vulnerable
    const openRedirectAnalysis = this.analyzeOpenRedirects();
    if (openRedirectAnalysis.vulnerable) {
      issues.push(openRedirectAnalysis.issues.join(', '));
      recommendations.push('Validate and sanitize all redirect URLs');
      score -= 10;
      console.log(' Open redirects: -10 points');
    } else {
      console.log(' No open redirects: 0 points');
    }

    // 14. Real SQL Injection Analysis (Actual Detection) - CRITICAL: -10 points if vulnerable
    const sqlInjectionAnalysis = this.analyzeSQLInjection();
    if (sqlInjectionAnalysis.vulnerable) {
      issues.push(sqlInjectionAnalysis.issues.join(', '));
      recommendations.push('Implement proper SQL injection protection');
      score -= 10;
      console.log(' SQL injection: -10 points');
    } else {
      console.log(' No SQL injection: 0 points');
    }

    // 15. Real Clickjacking Analysis (Actual Detection) - MODERATE: -5 points if vulnerable
    const clickjackingAnalysis = this.analyzeClickjacking();
    if (clickjackingAnalysis.vulnerable) {
      issues.push(clickjackingAnalysis.issues.join(', '));
      recommendations.push('Implement clickjacking protection');
      score -= 5;
      console.log(' Clickjacking: -5 points');
    } else {
      console.log(' No clickjacking: 0 points');
    }

    // 16. Real Information Disclosure Analysis (Actual Detection) - MODERATE: -5 points if disclosed
    const infoDisclosureAnalysis = this.analyzeInformationDisclosure();
    if (infoDisclosureAnalysis.disclosed) {
      issues.push(infoDisclosureAnalysis.issues.join(', '));
      recommendations.push('Remove sensitive information from responses');
      score -= 5;
      console.log(' Info disclosure: -5 points');
    } else {
      console.log(' No info disclosure: 0 points');
    }

    // 17. Real Authentication Analysis (Actual Detection) - MODERATE: 4 points
    const authAnalysis = this.analyzeAuthentication();
    if (authAnalysis.secure) {
      score += 4;
      console.log(' Authentication: +4 points');
    } else {
      issues.push(authAnalysis.issues.join(', '));
      recommendations.push('Implement secure authentication mechanisms');
      console.log(' Authentication: 0 points');
    }

    // 18. Real Authorization Analysis (Actual Detection) - MODERATE: 4 points
    const authorizationAnalysis = this.analyzeAuthorization();
    if (authorizationAnalysis.secure) {
      score += 4;
      console.log(' Authorization: +4 points');
    } else {
      issues.push(authorizationAnalysis.issues.join(', '));
      recommendations.push('Implement proper authorization controls');
      console.log(' Authorization: 0 points');
    }

    // 19. Real Data Encryption Analysis (Actual Detection) - MODERATE: 4 points
    const encryptionAnalysis = this.analyzeDataEncryption();
    if (encryptionAnalysis.encrypted) {
      score += 4;
      console.log(' Data encryption: +4 points');
    } else {
      issues.push(encryptionAnalysis.issues.join(', '));
      recommendations.push('Implement data encryption for sensitive information');
      console.log(' Data encryption: 0 points');
    }

    // 20. Real Third-Party Security Analysis (Actual Detection) - MODERATE: 3 points
    const thirdPartySecurityAnalysis = this.analyzeThirdPartySecurity();
    if (thirdPartySecurityAnalysis.secure) {
      score += 3;
      console.log(' Third-party security: +3 points');
    } else {
      issues.push(thirdPartySecurityAnalysis.issues.join(', '));
      recommendations.push('Review and secure third-party integrations');
      console.log(' Third-party security: 0 points');
    }

    // 21. Real API Security Analysis (Actual Detection) - MODERATE: 3 points
    const apiSecurityAnalysis = this.analyzeAPISecurity();
    if (apiSecurityAnalysis.secure) {
      score += 3;
      console.log(' API security: +3 points');
    } else {
      issues.push(apiSecurityAnalysis.issues.join(', '));
      recommendations.push('Implement API security best practices');
      console.log(' API security: 0 points');
    }

    // 22. Real File Upload Security Analysis (Actual Detection) - MODERATE: 3 points
    const fileUploadAnalysis = this.analyzeFileUploadSecurity();
    if (fileUploadAnalysis.secure) {
      score += 3;
      console.log(' File upload security: +3 points');
    } else {
      issues.push(fileUploadAnalysis.issues.join(', '));
      recommendations.push('Implement secure file upload mechanisms');
      console.log(' File upload security: 0 points');
    }

    // 23. Real Business Logic Analysis (Actual Detection) - MODERATE: 3 points
    const businessLogicAnalysis = this.analyzeBusinessLogic();
    if (businessLogicAnalysis.secure) {
      score += 3;
      console.log(' Business logic: +3 points');
    } else {
      issues.push(businessLogicAnalysis.issues.join(', '));
      recommendations.push('Review and secure business logic');
      console.log(' Business logic: 0 points');
    }

    // 24. Real Security Misconfiguration Analysis (Actual Detection) - MODERATE: 3 points
    const misconfigAnalysis = this.analyzeSecurityMisconfiguration();
    if (misconfigAnalysis.secure) {
      score += 3;
      console.log(' Security config: +3 points');
    } else {
      issues.push(misconfigAnalysis.issues.join(', '));
      recommendations.push('Fix security misconfigurations');
      console.log(' Security config: 0 points');
    }

    // 25. Real Vulnerable Components Analysis (Actual Detection) - CRITICAL: -10 points if vulnerable
    const vulnerableComponentsAnalysis = this.analyzeVulnerableComponents();
    if (vulnerableComponentsAnalysis.vulnerable) {
      issues.push(vulnerableComponentsAnalysis.issues.join(', '));
      recommendations.push('Update vulnerable components and dependencies');
      score -= 10;
      console.log(' Vulnerable components: -10 points');
    } else {
      console.log(' No vulnerable components: 0 points');
    }

    // Ensure score doesn't go below 0 or above 100
    score = Math.max(0, Math.min(100, score));
    
    console.log(` Security analysis completed. Total score: ${score}/100`);
    console.log(` Issues found: ${issues.length}, Recommendations: ${recommendations.length}`);

    return {
      hasHTTPS: httpsAnalysis.enabled,
      hasSecurityHeaders: securityHeadersAnalysis.optimized,
      hasCSP: cspAnalysis.enabled,
      hasHSTS: hstsAnalysis.enabled,
      hasXFrameOptions: securityHeadersAnalysis.details.hasXFrameOptions,
      hasXContentTypeOptions: securityHeadersAnalysis.details.hasXContentTypeOptions,
      hasReferrerPolicy: securityHeadersAnalysis.details.hasReferrerPolicy,
      hasPermissionsPolicy: securityHeadersAnalysis.details.hasPermissionsPolicy,
      hasSecureCookies: cookieAnalysis.secure,
      hasCSRFProtection: csrfAnalysis.protected,
      hasInputValidation: inputValidationAnalysis.validated,
      hasOutputEncoding: outputEncodingAnalysis.encoded,
      hasSessionManagement: sessionAnalysis.secure,
      hasErrorHandling: errorHandlingAnalysis.secure,
      score: score,
      issues,
      recommendations,
      securityLevel: this.determineSecurityLevel(score),
    };
  }

  private checkPerformance() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    console.log('Starting comprehensive performance analysis for:', this.url);

    // 1. Real Load Time Analysis (Actual Measurement)
    const loadTimeSeconds = this.loadTime / 1000;
    console.log('Real load time:', loadTimeSeconds, 'seconds');
    
    if (this.loadTime > 3000) {
      issues.push(`Slow page load time: ${loadTimeSeconds.toFixed(2)}s`);
      recommendations.push('Optimize page load time to under 3 seconds for better user experience');
      score -= 20;
    } else if (this.loadTime > 2000) {
      issues.push(`Moderate page load time: ${loadTimeSeconds.toFixed(2)}s`);
      recommendations.push('Consider optimizing page load time for better performance');
      score -= 10;
    } else if (this.loadTime < 500) {
      score += 5;
    }

    // 2. Real Page Size Analysis (Actual Measurement)
    const pageSizeKB = Math.round(this.pageSize / 1024);
    const pageSizeMB = (this.pageSize / (1024 * 1024)).toFixed(2);
    console.log('Real page size:', pageSizeKB, 'KB (', pageSizeMB, 'MB)');
    
    if (this.pageSize > 5000000) { // 5MB
      issues.push(`Large page size: ${pageSizeMB}MB`);
      recommendations.push('Reduce page size through optimization and compression');
      score -= 15;
    } else if (this.pageSize > 2000000) { // 2MB
      issues.push(`Moderate page size: ${pageSizeMB}MB`);
      recommendations.push('Consider reducing page size for better performance');
      score -= 10;
    } else if (this.pageSize < 500000) { // 500KB
      score += 5;
    }

    // 3. Real Image Analysis (Actual Detection)
    const imageAnalysis = this.analyzeImages();
    if (!imageAnalysis.optimized) {
      issues.push(imageAnalysis.issues.join(', '));
      recommendations.push('Optimize images using modern formats (WebP, AVIF) and proper sizing');
      score -= 15;
    } else {
      console.log('Image analysis:', imageAnalysis.details);
    }

    // 4. Real Resource Analysis (Actual Detection)
    const resourceAnalysis = this.analyzeResources();
    if (!resourceAnalysis.optimized) {
      issues.push(resourceAnalysis.issues.join(', '));
      recommendations.push('Optimize resources through minification, compression, and bundling');
      score -= 15;
    } else {
      console.log('Resource analysis:', resourceAnalysis.details);
    }

    // 5. Real Compression Analysis (Actual Detection)
    const compressionAnalysis = this.analyzeCompression();
    if (!compressionAnalysis.enabled) {
      issues.push('No compression detected');
      recommendations.push('Enable GZIP/Brotli compression to reduce file sizes');
      score -= 15;
    } else {
      console.log('Compression analysis:', compressionAnalysis.details);
    }

    // 6. Real Caching Analysis (Actual Detection)
    const cachingAnalysis = this.analyzeCaching();
    if (!cachingAnalysis.enabled) {
      issues.push('No caching headers detected');
      recommendations.push('Implement proper caching strategies for static resources');
      score -= 10;
    } else {
      console.log('Caching analysis:', cachingAnalysis.details);
    }

    // 7. Real CDN Analysis (Actual Detection)
    const cdnAnalysis = this.analyzeCDN();
    if (!cdnAnalysis.used) {
      issues.push('No CDN detected');
      recommendations.push('Consider using a CDN for better global performance');
      score -= 10;
    } else {
      console.log('CDN analysis:', cdnAnalysis.details);
    }

    // 8. Real Render-Blocking Analysis (Actual Detection)
    const renderBlockingAnalysis = this.analyzeRenderBlocking();
    if (renderBlockingAnalysis.count > 0) {
      issues.push(`${renderBlockingAnalysis.count} render-blocking resources detected`);
      recommendations.push('Optimize critical rendering path by deferring non-critical resources');
      score -= 10;
    } else {
      console.log('Render-blocking analysis:', renderBlockingAnalysis.details);
    }

    // 9. Real JavaScript Analysis (Actual Detection)
    const javascriptAnalysis = this.analyzeJavaScript();
    if (!javascriptAnalysis.optimized) {
      issues.push(javascriptAnalysis.issues.join(', '));
      recommendations.push('Optimize JavaScript loading and execution');
      score -= 10;
    } else {
      console.log('JavaScript analysis:', javascriptAnalysis.details);
    }

    // 10. Real CSS Analysis (Actual Detection)
    const cssAnalysis = this.analyzeCSS();
    if (!cssAnalysis.optimized) {
      issues.push(cssAnalysis.issues.join(', '));
      recommendations.push('Optimize CSS delivery and reduce unused styles');
      score -= 10;
    } else {
      console.log('CSS analysis:', cssAnalysis.details);
    }

    // 11. Real Font Analysis (Actual Detection)
    const fontAnalysis = this.analyzeFonts();
    if (!fontAnalysis.optimized) {
      issues.push(fontAnalysis.issues.join(', '));
      recommendations.push('Optimize font loading and use font-display: swap');
      score -= 10;
    } else {
      console.log('Font analysis:', fontAnalysis.details);
    }

    // 12. Real Third-Party Analysis (Actual Detection)
    const thirdPartyAnalysis = this.analyzeThirdPartyResources();
    if (thirdPartyAnalysis.hasExcessiveThirdParty) {
      issues.push(`${thirdPartyAnalysis.count} third-party resources detected`);
      recommendations.push('Reduce third-party resources and load them asynchronously');
      score -= 10;
    } else {
      console.log('Third-party analysis:', thirdPartyAnalysis.details);
    }

    // 13. Real HTTP/2 Analysis (Actual Detection)
    const http2Analysis = this.analyzeHTTP2();
    if (!http2Analysis.enabled) {
      issues.push('HTTP/2 not detected');
      recommendations.push('Upgrade to HTTP/2 for better multiplexing and performance');
      score -= 5;
    } else {
      console.log('HTTP/2 analysis:', http2Analysis.details);
    }

    // 14. Real Security Headers Analysis (Performance Impact)
    const securityHeadersAnalysis = this.analyzeSecurityHeaders();
    if (!securityHeadersAnalysis.optimized) {
      issues.push('Security headers may impact performance');
      recommendations.push('Optimize security headers for better performance');
      score -= 5;
    } else {
      console.log('Security headers analysis:', securityHeadersAnalysis.details);
    }

    // 15. Real Core Web Vitals Calculation (Based on Real Data)
    const coreWebVitals = this.calculateRealCoreWebVitals();
    
    // First Contentful Paint (FCP)
    if (coreWebVitals.fcp > 1800) {
      issues.push(`First Contentful Paint: ${coreWebVitals.fcp}ms (poor)`);
      score -= 10;
    } else if (coreWebVitals.fcp > 1000) {
      issues.push(`First Contentful Paint: ${coreWebVitals.fcp}ms (needs improvement)`);
      score -= 5;
    }

    // Largest Contentful Paint (LCP)
    if (coreWebVitals.lcp > 4000) {
      issues.push(`Largest Contentful Paint: ${coreWebVitals.lcp}ms (poor)`);
      score -= 10;
    } else if (coreWebVitals.lcp > 2500) {
      issues.push(`Largest Contentful Paint: ${coreWebVitals.lcp}ms (needs improvement)`);
      score -= 5;
    }

    // Cumulative Layout Shift (CLS)
    if (coreWebVitals.cls > 0.25) {
      issues.push(`Cumulative Layout Shift: ${coreWebVitals.cls.toFixed(3)} (poor)`);
      score -= 10;
    } else if (coreWebVitals.cls > 0.1) {
      issues.push(`Cumulative Layout Shift: ${coreWebVitals.cls.toFixed(3)} (needs improvement)`);
      score -= 5;
    }

    // First Input Delay (FID)
    if (coreWebVitals.fid > 300) {
      issues.push(`First Input Delay: ${coreWebVitals.fid}ms (poor)`);
      score -= 10;
    } else if (coreWebVitals.fid > 100) {
      issues.push(`First Input Delay: ${coreWebVitals.fid}ms (needs improvement)`);
      score -= 5;
    }

    // 16. Real Performance Budget Analysis
    const performanceBudget = this.analyzePerformanceBudget();
    if (!performanceBudget.withinBudget) {
      issues.push(`Performance budget exceeded: ${performanceBudget.details}`);
      recommendations.push('Implement performance budgets to maintain fast loading times');
      score -= 10;
    } else {
      console.log('Performance budget analysis:', performanceBudget.details);
    }

    // 17. Real Mobile Performance Analysis
    const mobileAnalysis = this.analyzeMobilePerformance();
    if (!mobileAnalysis.optimized) {
      issues.push(mobileAnalysis.issues.join(', '));
      recommendations.push('Optimize for mobile performance and reduce mobile-specific issues');
      score -= 10;
    } else {
      console.log('Mobile performance analysis:', mobileAnalysis.details);
    }

    // 18. Real Resource Loading Analysis
    const resourceLoadingAnalysis = this.analyzeResourceLoading();
    if (!resourceLoadingAnalysis.optimized) {
      issues.push(resourceLoadingAnalysis.issues.join(', '));
      recommendations.push('Optimize resource loading order and priorities');
      score -= 10;
    } else {
      console.log('Resource loading analysis:', resourceLoadingAnalysis.details);
    }

    // 19. Real Database Query Analysis (if applicable)
    const databaseAnalysis = this.analyzeDatabasePerformance();
    if (databaseAnalysis.hasIssues) {
      issues.push(databaseAnalysis.issues.join(', '));
      recommendations.push('Optimize database queries and implement caching');
      score -= 5;
    } else {
      console.log('Database analysis:', databaseAnalysis.details);
    }

    // 20. Real Server Response Analysis
    const serverAnalysis = this.analyzeServerPerformance();
    if (!serverAnalysis.optimized) {
      issues.push(serverAnalysis.issues.join(', '));
      recommendations.push('Optimize server response times and implement caching');
      score -= 10;
    } else {
      console.log('Server performance analysis:', serverAnalysis.details);
    }

    // 21. NEW: Real Network Analysis (Actual Detection)
    const networkAnalysis = this.analyzeNetworkPerformance();
    if (!networkAnalysis.optimized) {
      issues.push(networkAnalysis.issues.join(', '));
      recommendations.push('Optimize network requests and reduce round trips');
      score -= 10;
    } else {
      console.log('Network analysis:', networkAnalysis.details);
    }

    // 22. NEW: Real DOM Analysis (Actual Detection)
    const domAnalysis = this.analyzeDOMPerformance();
    if (!domAnalysis.optimized) {
      issues.push(domAnalysis.issues.join(', '));
      recommendations.push('Optimize DOM structure and reduce complexity');
      score -= 10;
    } else {
      console.log('DOM analysis:', domAnalysis.details);
    }

    // 23. NEW: Real Event Handler Analysis (Actual Detection)
    const eventHandlerAnalysis = this.analyzeEventHandlerPerformance();
    if (!eventHandlerAnalysis.optimized) {
      issues.push(eventHandlerAnalysis.issues.join(', '));
      recommendations.push('Optimize event handlers and reduce event listeners');
      score -= 10;
    } else {
      console.log('Event handler analysis:', eventHandlerAnalysis.details);
    }

    // 24. NEW: Real Animation Analysis (Actual Detection)
    const animationAnalysis = this.analyzeAnimationPerformance();
    if (!animationAnalysis.optimized) {
      issues.push(animationAnalysis.issues.join(', '));
      recommendations.push('Optimize animations and use hardware acceleration');
      score -= 10;
    } else {
      console.log('Animation analysis:', animationAnalysis.details);
    }

    // 25. NEW: Real Media Analysis (Actual Detection)
    const mediaAnalysis = this.analyzeMediaPerformance();
    if (!mediaAnalysis.optimized) {
      issues.push(mediaAnalysis.issues.join(', '));
      recommendations.push('Optimize media loading and use appropriate formats');
      score -= 10;
    } else {
      console.log('Media analysis:', mediaAnalysis.details);
    }

    // 26. NEW: Real API Performance Analysis (Actual Detection)
    const apiAnalysis = this.analyzeAPIPerformance();
    if (!apiAnalysis.optimized) {
      issues.push(apiAnalysis.issues.join(', '));
      recommendations.push('Optimize API calls and implement caching');
      score -= 10;
    } else {
      console.log('API performance analysis:', apiAnalysis.details);
    }

    // 27. NEW: Real Memory Usage Analysis (Actual Detection)
    const memoryAnalysis = this.analyzeMemoryPerformance();
    if (!memoryAnalysis.optimized) {
      issues.push(memoryAnalysis.issues.join(', '));
      recommendations.push('Optimize memory usage and reduce memory leaks');
      score -= 10;
    } else {
      console.log('Memory analysis:', memoryAnalysis.details);
    }

    // 28. NEW: Real Accessibility Performance Analysis (Actual Detection)
    const accessibilityPerformanceAnalysis = this.analyzeAccessibilityPerformance();
    if (!accessibilityPerformanceAnalysis.optimized) {
      issues.push(accessibilityPerformanceAnalysis.issues.join(', '));
      recommendations.push('Optimize accessibility features for better performance');
      score -= 5;
    } else {
      console.log('Accessibility performance analysis:', accessibilityPerformanceAnalysis.details);
    }

    // 29. NEW: Real SEO Performance Analysis (Actual Detection)
    const seoPerformanceAnalysis = this.analyzeSEOPerformance();
    if (!seoPerformanceAnalysis.optimized) {
      issues.push(seoPerformanceAnalysis.issues.join(', '));
      recommendations.push('Optimize SEO elements for better performance');
      score -= 5;
    } else {
      console.log('SEO performance analysis:', seoPerformanceAnalysis.details);
    }

    // 30. NEW: Real Progressive Web App Analysis (Actual Detection)
    const pwaAnalysis = this.analyzePWAPerformance();
    if (!pwaAnalysis.optimized) {
      issues.push(pwaAnalysis.issues.join(', '));
      recommendations.push('Implement PWA features for better performance');
      score -= 5;
    } else {
      console.log('PWA analysis:', pwaAnalysis.details);
    }

    console.log('Performance analysis completed. Score:', score, 'Issues:', issues.length);

    return {
      loadTime: this.loadTime,
      pageSize: this.pageSize,
      imageOptimization: imageAnalysis.optimized,
      minification: resourceAnalysis.optimized,
      compression: compressionAnalysis.enabled,
      caching: cachingAnalysis.enabled,
      cdnUsage: cdnAnalysis.used,
      renderBlockingResources: renderBlockingAnalysis.count,
      unusedCSS: cssAnalysis.unusedCSS,
      unusedJS: javascriptAnalysis.unusedJS,
      firstContentfulPaint: coreWebVitals.fcp,
      largestContentfulPaint: coreWebVitals.lcp,
      cumulativeLayoutShift: coreWebVitals.cls,
      firstInputDelay: coreWebVitals.fid,
      score: Math.max(0, score),
      issues,
      recommendations,
      performanceGrade: this.determinePerformanceGrade(score),
    };
  }

  private checkSEO() {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    // Check for meta title
    const hasMetaTitle = this.checkMetaTitle();
    if (!hasMetaTitle.valid) {
      issues.push(hasMetaTitle.issue || 'No meta title found');
      recommendations.push('Add a descriptive meta title (50-60 characters)');
      score -= 15;
    }

    // Check for meta description
    const hasMetaDescription = this.checkMetaDescription();
    if (!hasMetaDescription.valid) {
      issues.push(hasMetaDescription.issue || 'No meta description found');
      recommendations.push('Add a compelling meta description (150-160 characters)');
      score -= 15;
    }

    // Check for Open Graph
    const hasOpenGraph = this.checkOpenGraph();
    if (!hasOpenGraph.valid) {
      issues.push(hasOpenGraph.issues.join(', '));
      recommendations.push('Add Open Graph tags for better social media sharing');
      score -= 10;
    }

    // Check for Twitter Card
    const hasTwitterCard = this.checkTwitterCard();
    if (!hasTwitterCard.valid) {
      issues.push(hasTwitterCard.issues.join(', '));
      recommendations.push('Add Twitter Card tags for better Twitter sharing');
      score -= 10;
    }

    // Check for structured data
    const hasStructuredData = this.checkStructuredData();
    if (!hasStructuredData.valid) {
      issues.push(hasStructuredData.issues.join(', '));
      recommendations.push('Implement structured data (JSON-LD) for better search results');
      score -= 10;
    }

    // Check for sitemap
    const hasSitemap = this.checkSitemap();
    if (!hasSitemap.valid) {
      issues.push(hasSitemap.issues.join(', '));
      recommendations.push('Create and submit a sitemap to search engines');
      score -= 10;
    }

    // Check for robots.txt
    const hasRobotsTxt = this.checkRobotsTxt();
    if (!hasRobotsTxt.valid) {
      issues.push(hasRobotsTxt.issues.join(', '));
      recommendations.push('Create a robots.txt file to guide search engine crawlers');
      score -= 10;
    }

    // Check for canonical URL
    const hasCanonicalUrl = this.checkCanonicalUrl();
    if (!hasCanonicalUrl.valid) {
      issues.push(hasCanonicalUrl.issues.join(', '));
      recommendations.push('Add canonical URLs to prevent duplicate content issues');
      score -= 10;
    }

    // Check for internal linking
    const hasInternalLinking = this.checkInternalLinking();
    if (!hasInternalLinking.valid) {
      issues.push(hasInternalLinking.issues.join(', '));
      recommendations.push('Implement strategic internal linking for better SEO');
      score -= 10;
    }

    // Check for heading structure
    const headingStructure = this.checkHeadingStructure();
    if (!headingStructure.valid) {
      issues.push(headingStructure.issues.join(', '));
      recommendations.push('Improve heading structure for better content organization');
      score -= 10;
    }

    // Check for image optimization
    const imageSEO = this.checkImageSEO();
    if (!imageSEO.valid) {
      issues.push(imageSEO.issues.join(', '));
      recommendations.push('Optimize images with proper alt text and file names');
      score -= 10;
    }

    // Check for mobile optimization
    const hasMobileOptimization = this.checkMobileOptimization();
    if (!hasMobileOptimization) {
      issues.push('Mobile optimization not implemented');
      recommendations.push('Ensure responsive design and fast loading on mobile devices');
      score -= 10;
    }

    // Check for SSL
    const hasSSL = this.checkSSL();
    if (!hasSSL) {
      issues.push('SSL not implemented');
      recommendations.push('Ensure all resources are served over HTTPS');
      score -= 10;
    }

    return {
      hasMetaTitle: hasMetaTitle.valid,
      hasMetaDescription: hasMetaDescription.valid,
      hasOpenGraph: hasOpenGraph.valid,
      hasTwitterCard: hasTwitterCard.valid,
      hasStructuredData: hasStructuredData.valid,
      hasSitemap: hasSitemap.valid,
      hasRobotsTxt: hasRobotsTxt.valid,
      hasCanonicalUrl: hasCanonicalUrl.valid,
      hasInternalLinking: hasInternalLinking.valid,
      hasHeadingStructure: headingStructure.valid,
      hasImageOptimization: imageSEO.valid,
      hasMobileOptimization,
      hasPageSpeed: true, // Assuming a baseline for page speed
      hasSSL,
      score: Math.max(0, score),
      issues,
      recommendations,
      seoScore: score,
    };
  }

  private calculateOverall(results: any, options: ScanOptions) {
    const categories = ['gdpr', 'accessibility', 'security', 'performance', 'seo'];
    const enabledCategories = categories.filter(cat => options[cat as keyof ScanOptions] as boolean);
    
    if (enabledCategories.length === 0) {
      return {
        score: 0,
        grade: 'F' as const,
        totalIssues: 0,
        recommendations: ['No scan categories selected'],
        priorityIssues: [],
        complianceStatus: 'critical' as const
      };
    }

    let totalScore = 0;
    let totalIssues = 0;
    let allRecommendations: string[] = [];
    let priorityIssues: string[] = [];

    enabledCategories.forEach(category => {
      const result = results[category];
      if (result) {
        totalScore += result.score;
        totalIssues += result.issues.length;
        allRecommendations.push(...result.recommendations);
        
        // Add critical issues to priority list
        if (result.score < 50) {
          priorityIssues.push(`${category.toUpperCase()}: ${result.issues[0] || 'Critical issues found'}`);
        }
      }
    });

    const averageScore = Math.round(totalScore / enabledCategories.length);
    
    // Determine grade based on average score
    let grade: 'A' | 'B' | 'C' | 'D' | 'F';
    if (averageScore >= 90) grade = 'A';
    else if (averageScore >= 80) grade = 'B';
    else if (averageScore >= 70) grade = 'C';
    else if (averageScore >= 60) grade = 'D';
    else grade = 'F';

    // Determine compliance status
    let complianceStatus: 'excellent' | 'good' | 'fair' | 'poor' | 'critical';
    if (averageScore >= 90) complianceStatus = 'excellent';
    else if (averageScore >= 80) complianceStatus = 'good';
    else if (averageScore >= 70) complianceStatus = 'fair';
    else if (averageScore >= 50) complianceStatus = 'poor';
    else complianceStatus = 'critical';

    // Add general recommendations based on scan coverage
    if (enabledCategories.length < 3) {
      allRecommendations.push('Consider running a full scan to get comprehensive compliance insights');
    }

    if (priorityIssues.length === 0 && averageScore < 80) {
      priorityIssues.push('Review and address the identified issues to improve compliance score');
    }

    return {
      score: averageScore,
      grade,
      totalIssues,
      recommendations: allRecommendations.slice(0, 10), // Limit to top 10 recommendations
      priorityIssues: priorityIssues.slice(0, 5), // Limit to top 5 priority issues
      complianceStatus
    };
  }

  // Helper methods for GDPR checks
  private findCookieBanner(): Element | null {
    const selectors = [
      '[class*="cookie"]',
      '[class*="consent"]',
      '[id*="cookie"]',
      '[id*="consent"]',
      '[class*="gdpr"]',
      '[id*="gdpr"]',
      '[class*="banner"]',
      '[id*="banner"]',
      '[class*="notice"]',
      '[id*="notice"]',
      '[class*="popup"]',
      '[id*="popup"]',
      '[class*="modal"]',
      '[id*="modal"]',
      '[class*="toast"]',
      '[id*="toast"]',
    ];

    for (const selector of selectors) {
      const elements = this.dom.window.document.querySelectorAll(selector);
      for (const element of Array.from(elements)) {
        const text = element.textContent?.toLowerCase() || '';
        const html = element.innerHTML.toLowerCase();
        
        // Check for cookie-related keywords
        const cookieKeywords = ['cookie', 'consent', 'accept', 'gdpr', 'privacy', 'tracking', 'analytics'];
        const hasCookieKeywords = cookieKeywords.some(keyword => 
          text.includes(keyword) || html.includes(keyword)
        );
        
        // Check for action buttons
        const hasActionButtons = element.querySelectorAll('button, input[type="button"], input[type="submit"], a[href="#"]').length > 0;
        
        // Check if element is visible (simplified check)
        const style = this.dom.window.getComputedStyle(element);
        const isVisible = style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
        
        if (hasCookieKeywords && (hasActionButtons || isVisible)) {
          return element;
        }
      }
    }

    return null;
  }

  private findPrivacyPolicy(): boolean {
    // Check for privacy policy links
    const privacySelectors = [
      'a[href*="privacy"]',
      'a[href*="policy"]',
      'a[href*="privacy-policy"]',
      'a[href*="privacy_policy"]',
      'a[href*="privacy-policy.html"]',
      'a[href*="privacy-policy.php"]',
      'a[href*="privacy-policy.asp"]',
      'a[href*="privacy-policy.aspx"]',
    ];

    for (const selector of privacySelectors) {
      const links = this.dom.window.document.querySelectorAll(selector);
      if (links.length > 0) return true;
    }

    // Check for privacy policy text
    const textContent = this.html.toLowerCase();
    const privacyTexts = [
      'privacy policy',
      'privacy notice',
      'privacy statement',
      'data protection policy',
      'information privacy',
    ];

    return privacyTexts.some(text => textContent.includes(text));
  }

  private findTermsOfService(): boolean {
    // Check for terms links
    const termsSelectors = [
      'a[href*="terms"]',
      'a[href*="service"]',
      'a[href*="conditions"]',
      'a[href*="terms-of-service"]',
      'a[href*="terms_of_service"]',
      'a[href*="terms-and-conditions"]',
      'a[href*="terms_conditions"]',
    ];

    for (const selector of termsSelectors) {
      const links = this.dom.window.document.querySelectorAll(selector);
      if (links.length > 0) return true;
    }

    // Check for terms text
    const textContent = this.html.toLowerCase();
    const termsTexts = [
      'terms of service',
      'terms and conditions',
      'terms & conditions',
      'user agreement',
      'service agreement',
    ];

    return termsTexts.some(text => textContent.includes(text));
  }

  private findDataProcessingNotice(): boolean {
    const textContent = this.html.toLowerCase();
    const processingTexts = [
      'data processing',
      'personal data',
      'data protection',
      'information processing',
      'data collection',
      'data usage',
      'data handling',
      'data storage',
      'data retention',
      'data sharing',
      'data transfer',
      'data processing notice',
      'data processing agreement',
      'data processing policy',
    ];

    return processingTexts.some(text => textContent.includes(text));
  }

  private findCookiePolicy(): boolean {
    // Check for cookie policy links
    const cookieSelectors = [
      'a[href*="cookie"]',
      'a[href*="cookies"]',
      'a[href*="cookie-policy"]',
      'a[href*="cookie_policy"]',
      'a[href*="cookies-policy"]',
    ];

    for (const selector of cookieSelectors) {
      const links = this.dom.window.document.querySelectorAll(selector);
      if (links.length > 0) return true;
    }

    // Check for cookie policy text
    const textContent = this.html.toLowerCase();
    const cookieTexts = [
      'cookie policy',
      'cookie notice',
      'cookie statement',
      'cookies policy',
      'cookies notice',
      'cookie information',
      'cookie usage',
      'cookie settings',
    ];

    return cookieTexts.some(text => textContent.includes(text));
  }

  private findDataRetentionPolicy(): boolean {
    const textContent = this.html.toLowerCase();
    const retentionTexts = [
      'data retention',
      'retention policy',
      'data retention policy',
      'retention period',
      'data storage period',
      'how long we keep',
      'how long we store',
      'data retention period',
      'retention schedule',
    ];

    return retentionTexts.some(text => textContent.includes(text));
  }

  private findUserConsentMechanism(): boolean {
    // Check for consent forms and mechanisms
    const consentSelectors = [
      '[class*="consent"]',
      '[id*="consent"]',
      '[class*="opt-in"]',
      '[id*="opt-in"]',
      '[class*="opt-out"]',
      '[id*="opt-out"]',
      'input[type="checkbox"][name*="consent"]',
      'input[type="radio"][name*="consent"]',
      'button[class*="consent"]',
      'button[id*="consent"]',
    ];

    for (const selector of consentSelectors) {
      const elements = this.dom.window.document.querySelectorAll(selector);
      if (elements.length > 0) return true;
    }

    // Check for consent text
    const textContent = this.html.toLowerCase();
    const consentTexts = [
      'consent',
      'opt-in',
      'opt-out',
      'agree to',
      'accept terms',
      'i agree',
      'i accept',
      'consent to',
      'permission',
      'authorization',
    ];

    return consentTexts.some(text => textContent.includes(text));
  }

  private findDataPortability(): boolean {
    const textContent = this.html.toLowerCase();
    const portabilityTexts = [
      'data portability',
      'export data',
      'download data',
      'data export',
      'export my data',
      'download my data',
      'data download',
      'export information',
      'data access',
      'right to data portability',
    ];

    return portabilityTexts.some(text => textContent.includes(text));
  }

  private findRightToErasure(): boolean {
    const textContent = this.html.toLowerCase();
    const erasureTexts = [
      'right to erasure',
      'right to be forgotten',
      'delete data',
      'delete my data',
      'remove data',
      'data deletion',
      'forget me',
      'erase data',
      'data erasure',
      'delete account',
      'account deletion',
      'data removal',
    ];

    return erasureTexts.some(text => textContent.includes(text));
  }

  // Helper methods for GDPR checks
  private checkDataMinimization(): boolean {
    const forms = this.dom.window.document.querySelectorAll('form');
    const inputs = this.dom.window.document.querySelectorAll('input, select, textarea');
    const hasMinimizedData = Array.from(forms).some(form => {
      const formInputs = Array.from(form.querySelectorAll('input, select, textarea'));
      return formInputs.length <= 5; // Example: if a form has more than 5 inputs, it's not minimal
    });
    return !hasMinimizedData;
  }

  private checkPurposeLimitation(): boolean {
    const privacyPolicyText = this.html.toLowerCase();
    const purposeTexts = [
      'purpose of data collection',
      'data processing purpose',
      'data usage purpose',
      'data handling purpose',
      'data retention purpose',
      'data sharing purpose',
      'data transfer purpose',
    ];
    return purposeTexts.some(text => privacyPolicyText.includes(text));
  }

  private checkLawfulBasis(): boolean {
    const privacyPolicyText = this.html.toLowerCase();
    const lawfulBasisTexts = [
      'lawful basis for data processing',
      'legal basis for data processing',
      'basis for data processing',
      'data processing lawful basis',
      'data processing legal basis',
    ];
    return lawfulBasisTexts.some(text => privacyPolicyText.includes(text));
  }

  // Helper methods for accessibility checks
  private checkKeyboardNavigation(): boolean {
    const interactiveElements = this.dom.window.document.querySelectorAll('a, button, input, select, textarea, [tabindex]');
    const focusableElements = Array.from(interactiveElements).filter(el => {
      const element = el as HTMLElement;
      const tabIndex = element.getAttribute('tabindex');
      return tabIndex !== '-1' && element.style.display !== 'none' && element.style.visibility !== 'hidden';
    });
    
    return focusableElements.length > 0;
  }

  private checkScreenReaderSupport(): boolean {
    const ariaElements = this.dom.window.document.querySelectorAll('[aria-label], [aria-labelledby], [role], [aria-describedby]');
    const semanticElements = this.dom.window.document.querySelectorAll('nav, main, article, section, aside, header, footer, button, input, textarea, select');
    
    return ariaElements.length > 0 || semanticElements.length > 0;
  }

  private checkFocusIndicators(): boolean {
    // Check for CSS focus styles
    const styleSheets = this.dom.window.document.styleSheets;
    let hasFocusStyles = false;
    
    try {
      for (let i = 0; i < styleSheets.length; i++) {
        const rules = styleSheets[i].cssRules || styleSheets[i].rules;
        if (rules) {
          for (let j = 0; j < rules.length; j++) {
            const rule = rules[j] as CSSStyleRule;
            if (rule.selectorText && rule.selectorText.includes(':focus')) {
              hasFocusStyles = true;
              break;
            }
          }
        }
      }
    } catch (e) {
      // Cross-origin stylesheets will throw an error
    }
    
    return hasFocusStyles;
  }

  private checkSkipLinks(): boolean {
    const skipLinks = this.dom.window.document.querySelectorAll('a[href*="#"], a[href*="skip"], a[href*="main"], a[href*="content"]');
    const skipLinkTexts = Array.from(skipLinks).map(link => link.textContent?.toLowerCase() || '');
    
    const skipKeywords = ['skip', 'jump', 'main content', 'main navigation', 'skip to content', 'skip navigation'];
    return skipLinkTexts.some(text => skipKeywords.some(keyword => text.includes(keyword)));
  }

  private checkARIALabels(): boolean {
    const ariaElements = this.dom.window.document.querySelectorAll('[aria-label], [aria-labelledby], [aria-describedby]');
    return ariaElements.length > 0;
  }

  private checkSemanticHTML(): boolean {
    const semanticElements = this.dom.window.document.querySelectorAll('nav, main, article, section, aside, header, footer, figure, figcaption, time, mark, details, summary');
    return semanticElements.length > 0;
  }

  private checkContrastRatio(): boolean {
    // This is a simplified check - in a real implementation, you'd analyze CSS colors
    // For now, we'll assume good contrast if the site has proper styling
    const hasStyles = this.dom.window.document.querySelectorAll('link[rel="stylesheet"], style').length > 0;
    return hasStyles;
  }

  // Helper methods for security checks
  private checkSecurityHeaders() {
    const headers = this.responseHeaders || {};
    const issues: string[] = [];
    let optimized = true;

    // Check for X-Frame-Options
    const hasXFrameOptions = headers['x-frame-options'] || headers['X-Frame-Options'];
    if (!hasXFrameOptions) {
      issues.push('No X-Frame-Options header');
      optimized = false;
    }

    // Check for X-Content-Type-Options
    const hasXContentTypeOptions = headers['x-content-type-options'] || headers['X-Content-Type-Options'];
    if (!hasXContentTypeOptions) {
      issues.push('No X-Content-Type-Options header');
      optimized = false;
    }

    // Check for Referrer Policy
    const hasReferrerPolicy = headers['referrer-policy'] || headers['Referrer-Policy'];
    if (!hasReferrerPolicy) {
      issues.push('No Referrer Policy header');
      optimized = false;
    }

    // Check for Permissions Policy
    const hasPermissionsPolicy = headers['permissions-policy'] || headers['Permissions-Policy'];
    if (!hasPermissionsPolicy) {
      issues.push('No Permissions Policy header');
      optimized = false;
    }

    // Check for X-XSS-Protection
    const hasXSSProtection = headers['x-xss-protection'] || headers['X-XSS-Protection'];
    if (!hasXSSProtection) {
      issues.push('No X-XSS-Protection header');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        hasXFrameOptions: !!hasXFrameOptions,
        hasXContentTypeOptions: !!hasXContentTypeOptions,
        hasReferrerPolicy: !!hasReferrerPolicy,
        hasPermissionsPolicy: !!hasPermissionsPolicy,
        hasXSSProtection: !!hasXSSProtection,
        totalHeaders: [hasXFrameOptions, hasXContentTypeOptions, hasReferrerPolicy, hasPermissionsPolicy, hasXSSProtection].filter(Boolean).length
      }
    };
  }

  private checkCSP(): boolean {
    const cspMeta = this.dom.window.document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const cspHeader = this.responseHeaders?.['content-security-policy'] || this.responseHeaders?.['Content-Security-Policy'];
    return cspMeta !== null || !!cspHeader;
  }

  private checkHSTS(): boolean {
    return !!(this.responseHeaders?.['strict-transport-security'] || this.responseHeaders?.['Strict-Transport-Security']);
  }

  private checkXFrameOptions(): boolean {
    return !!(this.responseHeaders?.['x-frame-options'] || this.responseHeaders?.['X-Frame-Options']);
  }

  private checkXContentTypeOptions(): boolean {
    return !!(this.responseHeaders?.['x-content-type-options'] || this.responseHeaders?.['X-Content-Type-Options']);
  }

  private checkReferrerPolicy(): boolean {
    return !!(this.responseHeaders?.['referrer-policy'] || this.responseHeaders?.['Referrer-Policy']);
  }

  private checkPermissionsPolicy(): boolean {
    return !!(this.responseHeaders?.['permissions-policy'] || this.responseHeaders?.['Permissions-Policy']);
  }

  private checkSecureCookies(): boolean {
    // Check for Set-Cookie headers with secure flags
    const setCookieHeaders = this.responseHeaders?.['set-cookie'] || this.responseHeaders?.['Set-Cookie'];
    if (setCookieHeaders) {
      const cookies = Array.isArray(setCookieHeaders) ? setCookieHeaders : [setCookieHeaders];
      return cookies.some(cookie => cookie.toLowerCase().includes('secure') || cookie.toLowerCase().includes('httponly'));
    }
    return false;
  }

  private checkCSRFProtection(): boolean {
    // Check for CSRF tokens in forms
    const forms = this.dom.window.document.querySelectorAll('form');
    const hasCSRFTokens = Array.from(forms).some(form => {
      const inputs = form.querySelectorAll('input[type="hidden"]');
      return Array.from(inputs).some(input => {
        const name = input.getAttribute('name')?.toLowerCase() || '';
        const value = input.getAttribute('value') || '';
        return name.includes('csrf') || name.includes('token') || name.includes('nonce') || 
               value.length > 20; // Long values are likely tokens
      });
    });
    
    return hasCSRFTokens;
  }

  private checkInputValidation(): boolean {
    const forms = this.dom.window.document.querySelectorAll('form');
    const hasInputValidation = Array.from(forms).some(form => {
      const inputs = form.querySelectorAll('input, select, textarea');
      return Array.from(inputs).some(input => {
        const inputElement = input as HTMLInputElement;
        const name = inputElement.getAttribute('name')?.toLowerCase() || '';
        const type = inputElement.getAttribute('type')?.toLowerCase() || '';
        if (type === 'email' || type === 'tel' || type === 'number' || type === 'date') {
          return !inputElement.checkValidity();
        }
        return false;
      });
    });
    return !hasInputValidation;
  }

  private checkOutputEncoding(): boolean {
    const html = this.html.toLowerCase();
    const sensitivePatterns = [
      'password',
      'secret',
      'key',
      'token',
      'api_key',
      'private_key',
      'database_url',
      'connection_string',
      'aws_access_key',
      'aws_secret_key',
      'google_api_key',
      'facebook_app_secret',
      'twitter_api_secret',
      'github_token',
      'slack_token',
      'stripe_secret_key',
      'paypal_secret',
      'mongodb_uri',
      'redis_url',
      'jwt_secret',
    ];
    
    return !sensitivePatterns.some(pattern => html.includes(pattern));
  }

  private checkSessionManagement(): boolean {
    const cookies = this.responseHeaders?.['set-cookie'] || this.responseHeaders?.['Set-Cookie'];
    if (cookies) {
      const cookieArray = Array.isArray(cookies) ? cookies : [cookies];
      return cookieArray.every(cookie => {
        const parts = cookie.split(';');
        const secure = parts.some((part: string) => part.trim().toLowerCase().includes('secure'));
        const httponly = parts.some((part: string) => part.trim().toLowerCase().includes('httponly'));
        return secure && httponly;
      });
    }
    return false;
  }

  private checkErrorHandling(): boolean {
    const html = this.html.toLowerCase();
    const errorKeywords = ['error', 'exception', 'stack trace', 'debug', 'mysql_error', 'sql error'];
    return !errorKeywords.some(keyword => html.includes(keyword));
  }

  private checkOpenRedirects(): boolean {
    // Check for potential open redirect parameters
    const url = new URL(this.url);
    const redirectParams = ['redirect', 'url', 'next', 'target', 'return', 'goto', 'link', 'continue'];
    
    return !redirectParams.some(param => {
      const value = url.searchParams.get(param);
      return value && (value.startsWith('http://') || value.startsWith('https://'));
    });
  }

  private checkSensitiveInfoExposure(): boolean {
    const html = this.html.toLowerCase();
    const sensitivePatterns = [
      'password',
      'secret',
      'key',
      'token',
      'api_key',
      'private_key',
      'database_url',
      'connection_string',
      'aws_access_key',
      'aws_secret_key',
      'google_api_key',
      'facebook_app_secret',
      'twitter_api_secret',
      'github_token',
      'slack_token',
      'stripe_secret_key',
      'paypal_secret',
      'mongodb_uri',
      'redis_url',
      'jwt_secret',
    ];
    
    return !sensitivePatterns.some(pattern => html.includes(pattern));
  }

  // Helper methods for performance checks
  private checkImageOptimization() {
    const images = this.dom.window.document.querySelectorAll('img');
    const issues: string[] = [];
    let optimized = true;

    if (images.length > 0) {
      // Check for missing width/height attributes
      const imagesWithoutDimensions = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        return !imgElement.width || !imgElement.height;
      });
      
      if (imagesWithoutDimensions.length > 0) {
        issues.push(`${imagesWithoutDimensions.length} images missing width/height attributes`);
        optimized = false;
      }

      // Check for large images
      const largeImages = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        const src = imgElement.src;
        return src && (src.includes('large') || src.includes('original') || src.includes('full'));
      });
      
      if (largeImages.length > 0) {
        issues.push(`${largeImages.length} potentially oversized images detected`);
        optimized = false;
      }

      // Check for modern image formats
      const modernFormats = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        const src = imgElement.src;
        return src && (src.includes('.webp') || src.includes('.avif') || src.includes('.svg'));
      });
      
      if (modernFormats.length === 0 && images.length > 0) {
        issues.push('No modern image formats (WebP, AVIF) detected');
        optimized = false;
      }
    }

    return { optimized, issues };
  }

  private checkMinification() {
    const issues: string[] = [];
    let optimized = true;

    // Check for minified CSS
    const cssLinks = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]');
    const minifiedCSS = Array.from(cssLinks).filter(link => {
      const href = link.getAttribute('href') || '';
      return href.includes('.min.css') || href.includes('minified');
    });
    
    if (minifiedCSS.length === 0 && cssLinks.length > 0) {
      issues.push('CSS files not minified');
      optimized = false;
    }

    // Check for minified JS
    const scriptTags = this.dom.window.document.querySelectorAll('script[src]');
    const minifiedJS = Array.from(scriptTags).filter(script => {
      const src = script.getAttribute('src') || '';
      return src.includes('.min.js') || src.includes('minified');
    });
    
    if (minifiedJS.length === 0 && scriptTags.length > 0) {
      issues.push('JavaScript files not minified');
      optimized = false;
    }

    return { optimized, issues };
  }

  private checkCompression() {
    const contentEncoding = this.responseHeaders?.['content-encoding'] || this.responseHeaders?.['Content-Encoding'];
    const acceptEncoding = this.responseHeaders?.['accept-encoding'] || this.responseHeaders?.['Accept-Encoding'];
    
    return {
      enabled: !!(contentEncoding && (contentEncoding.includes('gzip') || contentEncoding.includes('br') || contentEncoding.includes('deflate'))),
      supported: !!(acceptEncoding && (acceptEncoding.includes('gzip') || acceptEncoding.includes('br') || acceptEncoding.includes('deflate'))),
      details: {
        contentEncoding,
        acceptEncoding,
        hasGzip: contentEncoding?.includes('gzip') || false,
        hasBrotli: contentEncoding?.includes('br') || false,
        hasDeflate: contentEncoding?.includes('deflate') || false
      }
    };
  }

  private checkCaching() {
    const cacheControl = this.responseHeaders?.['cache-control'] || this.responseHeaders?.['Cache-Control'];
    const expires = this.responseHeaders?.['expires'] || this.responseHeaders?.['Expires'];
    const etag = this.responseHeaders?.['etag'] || this.responseHeaders?.['ETag'];
    const lastModified = this.responseHeaders?.['last-modified'] || this.responseHeaders?.['Last-Modified'];
    
    return {
      enabled: !!(cacheControl || expires || etag || lastModified),
      hasCacheControl: !!cacheControl,
      hasExpires: !!expires,
      hasETag: !!etag,
      hasLastModified: !!lastModified
    };
  }

  private checkCDNUsage() {
    const cdnDomains = [
      'cdn.', 'static.', 'assets.', 'media.', 'img.', 'js.', 'css.',
      'cloudfront.net', 'cloudflare.com', 'fastly.com', 'akamai.com',
      'jsdelivr.net', 'unpkg.com', 'cdnjs.cloudflare.com'
    ];
    
    const url = this.url.toLowerCase();
    const used = cdnDomains.some(domain => url.includes(domain));
    
    return { used };
  }

  private checkRenderBlockingResources() {
    const renderBlocking = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]:not([media="print"]), script:not([async]):not([defer])');
    return { count: renderBlocking.length };
  }

  private checkUnusedResources() {
    // This is a simplified check - in a real implementation, you'd analyze actual usage
    const cssLinks = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]');
    const scriptTags = this.dom.window.document.querySelectorAll('script[src]');
    
    // Assume some resources might be unused if there are many
    const potentiallyUnused = Math.max(0, cssLinks.length + scriptTags.length - 5);
    
    return { unused: potentiallyUnused };
  }

  // Additional security vulnerability checks
  private checkCommonVulnerabilities() {
    const vulnerabilities: string[] = [];
    const recommendations: string[] = [];

    // Check for SQL injection patterns in forms
    const forms = this.dom.window.document.querySelectorAll('form');
    forms.forEach(form => {
      const inputs = form.querySelectorAll('input, textarea, select');
      inputs.forEach(input => {
        const name = input.getAttribute('name') || '';
        const id = input.getAttribute('id') || '';
        if (name.includes('sql') || name.includes('query') || id.includes('sql') || id.includes('query')) {
          vulnerabilities.push('Potential SQL injection vulnerability in form field');
          recommendations.push('Implement proper input validation and parameterized queries');
        }
      });
    });

    // Check for XSS vulnerabilities
    const scripts = this.dom.window.document.querySelectorAll('script');
    scripts.forEach(script => {
      const content = script.textContent || '';
      if (content.includes('innerHTML') || content.includes('outerHTML') || content.includes('document.write')) {
        vulnerabilities.push('Potential XSS vulnerability detected');
        recommendations.push('Avoid using innerHTML/outerHTML with user input, use textContent instead');
      }
    });

    // Check for exposed error messages
    const errorKeywords = ['error', 'exception', 'stack trace', 'debug', 'mysql_error', 'sql error'];
    const html = this.html.toLowerCase();
    errorKeywords.forEach(keyword => {
      if (html.includes(keyword)) {
        vulnerabilities.push('Error messages potentially exposed');
        recommendations.push('Disable detailed error messages in production');
      }
    });

    // Check for directory listing
    if (html.includes('index of') || html.includes('directory listing')) {
      vulnerabilities.push('Directory listing enabled');
      recommendations.push('Disable directory listing in web server configuration');
    }

    // Check for default credentials
    const defaultCreds = ['admin:admin', 'root:root', 'user:password', 'admin:password'];
    defaultCreds.forEach(creds => {
      if (html.includes(creds)) {
        vulnerabilities.push('Default credentials potentially exposed');
        recommendations.push('Change default credentials immediately');
      }
    });

    return { vulnerabilities, recommendations };
  }

  // Check for outdated software versions
  private checkSoftwareVersions() {
    const outdated: string[] = [];
    const recommendations: string[] = [];

    // Check for common outdated software signatures
    const versionPatterns = [
      { pattern: 'wordpress', version: '5.0', name: 'WordPress' },
      { pattern: 'php', version: '7.4', name: 'PHP' },
      { pattern: 'apache', version: '2.4', name: 'Apache' },
      { pattern: 'nginx', version: '1.18', name: 'Nginx' },
      { pattern: 'jquery', version: '3.6', name: 'jQuery' },
      { pattern: 'bootstrap', version: '5.0', name: 'Bootstrap' },
    ];

    const html = this.html.toLowerCase();
    versionPatterns.forEach(({ pattern, version, name }) => {
      if (html.includes(pattern)) {
        // This is a simplified check - in a real implementation, you'd extract actual versions
        outdated.push(`Potentially outdated ${name} version`);
        recommendations.push(`Update ${name} to the latest version`);
      }
    });

    return { outdated, recommendations };
  }

  // Check for privacy and data protection
  private checkPrivacyCompliance() {
    const issues: string[] = [];
    const recommendations: string[] = [];

    // Check for tracking scripts
    const trackingScripts = [
      'google-analytics.com',
      'googletagmanager.com',
      'facebook.net',
      'doubleclick.net',
      'hotjar.com',
      'mixpanel.com',
      'amplitude.com',
      'segment.com'
    ];

    const html = this.html.toLowerCase();
    trackingScripts.forEach(script => {
      if (html.includes(script)) {
        issues.push(`Third-party tracking script detected: ${script}`);
        recommendations.push('Ensure tracking scripts comply with privacy regulations and user consent');
      }
    });

    // Check for data collection forms
    const forms = this.dom.window.document.querySelectorAll('form');
    forms.forEach(form => {
      const inputs = form.querySelectorAll('input, textarea, select');
      const personalDataFields = Array.from(inputs).filter((input: Element) => {
        const name = input.getAttribute('name')?.toLowerCase() || '';
        const type = input.getAttribute('type')?.toLowerCase() || '';
        return name.includes('email') || name.includes('phone') || name.includes('address') || 
               name.includes('name') || name.includes('ssn') || name.includes('credit') ||
               type === 'email' || type === 'tel';
      });

      if (personalDataFields.length > 0) {
        issues.push('Personal data collection form detected');
        recommendations.push('Ensure data collection forms have proper privacy notices and consent mechanisms');
      }
    });

    return { issues, recommendations };
  }

  // Helper methods for SEO checks
  private checkMetaTitle() {
    const title = this.dom.window.document.querySelector('title');
    if (!title) {
      return { valid: false, issue: 'No title tag found' };
    }
    
    const titleText = title.textContent?.trim() || '';
    if (titleText.length === 0) {
      return { valid: false, issue: 'Empty title tag' };
    }
    
    if (titleText.length < 30) {
      return { valid: false, issue: 'Title too short (should be 50-60 characters)' };
    }
    
    if (titleText.length > 60) {
      return { valid: false, issue: 'Title too long (should be 50-60 characters)' };
    }
    
    return { valid: true };
  }

  private checkMetaDescription() {
    const metaDesc = this.dom.window.document.querySelector('meta[name="description"]');
    if (!metaDesc) {
      return { valid: false, issue: 'No meta description found' };
    }
    
    const content = metaDesc.getAttribute('content')?.trim() || '';
    if (content.length === 0) {
      return { valid: false, issue: 'Empty meta description' };
    }
    
    if (content.length < 120) {
      return { valid: false, issue: 'Meta description too short (should be 150-160 characters)' };
    }
    
    if (content.length > 160) {
      return { valid: false, issue: 'Meta description too long (should be 150-160 characters)' };
    }
    
    return { valid: true };
  }

  private checkOpenGraph() {
    const ogTags = this.dom.window.document.querySelectorAll('meta[property^="og:"]');
    const issues: string[] = [];
    
    if (ogTags.length === 0) {
      issues.push('No Open Graph tags found');
    } else {
      const requiredTags = ['og:title', 'og:description', 'og:image'];
      const foundTags = Array.from(ogTags).map(tag => tag.getAttribute('property'));
      
      requiredTags.forEach(tag => {
        if (!foundTags.includes(tag)) {
          issues.push(`Missing ${tag} tag`);
        }
      });
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkTwitterCard() {
    const twitterTags = this.dom.window.document.querySelectorAll('meta[name^="twitter:"]');
    const issues: string[] = [];
    
    if (twitterTags.length === 0) {
      issues.push('No Twitter Card tags found');
    } else {
      const requiredTags = ['twitter:card', 'twitter:title', 'twitter:description'];
      const foundTags = Array.from(twitterTags).map(tag => tag.getAttribute('name'));
      
      requiredTags.forEach(tag => {
        if (!foundTags.includes(tag)) {
          issues.push(`Missing ${tag} tag`);
        }
      });
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkStructuredData() {
    const structuredData = this.dom.window.document.querySelectorAll('script[type="application/ld+json"]');
    const issues: string[] = [];
    
    if (structuredData.length === 0) {
      issues.push('No structured data found');
    } else {
      // Check if structured data is valid JSON
      structuredData.forEach((script, index) => {
        try {
          const content = script.textContent || '';
          JSON.parse(content);
        } catch (e) {
          issues.push(`Invalid JSON in structured data ${index + 1}`);
        }
      });
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkSitemap() {
    const sitemapLink = this.dom.window.document.querySelector('link[rel="sitemap"]');
    const issues: string[] = [];
    
    if (!sitemapLink) {
      issues.push('No sitemap link found');
    }
    
    // Check for robots.txt reference to sitemap
    const robotsTxt = this.dom.window.document.querySelector('meta[name="robots"]');
    if (!robotsTxt) {
      issues.push('No robots meta tag found');
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkRobotsTxt() {
    // This would require checking robots.txt file - simplified for now
    const robotsMeta = this.dom.window.document.querySelector('meta[name="robots"]');
    const issues: string[] = [];
    
    if (!robotsMeta) {
      issues.push('No robots meta tag found');
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkCanonicalUrl() {
    const canonical = this.dom.window.document.querySelector('link[rel="canonical"]');
    const issues: string[] = [];
    
    if (!canonical) {
      issues.push('No canonical URL found');
    } else {
      const href = canonical.getAttribute('href');
      if (!href || href.trim().length === 0) {
        issues.push('Empty canonical URL');
      }
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkInternalLinking() {
    const internalLinks = this.dom.window.document.querySelectorAll('a[href^="/"], a[href^="' + this.url + '"]');
    const issues: string[] = [];
    
    if (internalLinks.length === 0) {
      issues.push('No internal links found');
    } else if (internalLinks.length < 3) {
      issues.push('Limited internal linking');
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkHeadingStructure() {
    const headings = this.dom.window.document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    const issues: string[] = [];
    
    if (headings.length === 0) {
      issues.push('No heading structure found');
    } else {
      const h1Count = this.dom.window.document.querySelectorAll('h1').length;
      if (h1Count === 0) {
        issues.push('No H1 heading found');
      } else if (h1Count > 1) {
        issues.push('Multiple H1 headings found (should be only one)');
      }
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkImageSEO() {
    const images = this.dom.window.document.querySelectorAll('img');
    const issues: string[] = [];
    
    if (images.length > 0) {
      const imagesWithoutAlt = Array.from(images).filter(img => {
        const alt = img.getAttribute('alt');
        return !alt || alt.trim().length === 0;
      });
      
      if (imagesWithoutAlt.length > 0) {
        issues.push(`${imagesWithoutAlt.length} images missing alt text`);
      }
      
      // Check for descriptive file names
      const imagesWithPoorNames = Array.from(images).filter(img => {
        const src = img.getAttribute('src') || '';
        const fileName = src.split('/').pop() || '';
        return fileName.includes('image') || fileName.includes('img') || fileName.includes('photo') || 
               fileName.length < 5 || fileName.includes('untitled');
      });
      
      if (imagesWithPoorNames.length > 0) {
        issues.push(`${imagesWithPoorNames.length} images with poor file names`);
      }
    }
    
    return { valid: issues.length === 0, issues };
  }

  private checkMobileOptimization(): boolean {
    const viewportMeta = this.dom.window.document.querySelector('meta[name="viewport"]');
    if (!viewportMeta) {
      return false;
    }
    const content = viewportMeta.getAttribute('content')?.toLowerCase() || '';
    return content.includes('width=device-width') && content.includes('initial-scale=1.0');
  }

  private checkSSL(): boolean {
    return this.url.startsWith('https://');
  }

  // Default result methods
  private getDefaultGDPR() {
    return {
      hasCookieBanner: false,
      hasPrivacyPolicy: false,
      hasTermsOfService: false,
      hasDataProcessingNotice: false,
      hasCookiePolicy: false,
      hasDataRetentionPolicy: false,
      hasUserConsentMechanism: false,
      hasDataPortability: false,
      hasRightToErasure: false,
      hasDataMinimization: false,
      hasPurposeLimitation: false,
      hasLawfulBasis: false,
      score: 0,
      issues: [],
      recommendations: [],
      complianceLevel: 'non-compliant',
    };
  }

  private getDefaultAccessibility() {
    return {
      hasAltText: false,
      hasProperHeadings: false,
      hasContrastRatio: false,
      hasKeyboardNavigation: false,
      hasScreenReaderSupport: false,
      hasFocusIndicators: false,
      hasSkipLinks: false,
      hasARIALabels: false,
      hasSemanticHTML: false,
      hasFormLabels: false,
      hasLanguageDeclaration: false,
      hasErrorHandling: false,
      score: 0,
      issues: [],
      recommendations: [],
      wcagLevel: 'non-compliant',
    };
  }

  private getDefaultSecurity() {
    return {
      hasHTTPS: false,
      hasSecurityHeaders: false,
      hasCSP: false,
      hasHSTS: false,
      hasXFrameOptions: false,
      hasXContentTypeOptions: false,
      hasReferrerPolicy: false,
      hasPermissionsPolicy: false,
      hasSecureCookies: false,
      hasCSRFProtection: false,
      hasInputValidation: false,
      hasOutputEncoding: false,
      hasSessionManagement: false,
      hasErrorHandling: false,
      score: 0,
      issues: [],
      recommendations: [],
      securityLevel: 'low',
    };
  }

  private getDefaultPerformance() {
    return {
      loadTime: 0,
      pageSize: 0,
      imageOptimization: false,
      minification: false,
      compression: false,
      caching: false,
      cdnUsage: false,
      renderBlockingResources: 0,
      unusedCSS: 0,
      unusedJS: 0,
      firstContentfulPaint: 0,
      largestContentfulPaint: 0,
      cumulativeLayoutShift: 0,
      firstInputDelay: 0,
      score: 0,
      issues: [],
      recommendations: [],
      performanceGrade: 'F',
    };
  }

  private getDefaultSEO() {
    return {
      hasMetaTitle: false,
      hasMetaDescription: false,
      hasOpenGraph: false,
      hasTwitterCard: false,
      hasStructuredData: false,
      hasSitemap: false,
      hasRobotsTxt: false,
      hasCanonicalUrl: false,
      hasInternalLinking: false,
      hasHeadingStructure: false,
      hasImageOptimization: false,
      hasMobileOptimization: false,
      hasPageSpeed: false,
      hasSSL: false,
      score: 0,
      issues: [],
      recommendations: [],
      seoScore: 0,
    };
  }

  private determineComplianceLevel(score: number): 'compliant' | 'partially-compliant' | 'non-compliant' {
    if (score >= 90) return 'compliant';
    if (score >= 70) return 'partially-compliant';
    return 'non-compliant';
  }

  private determineWCAGLevel(score: number): 'A' | 'AA' | 'AAA' | 'non-compliant' {
    if (score >= 90) return 'AAA';
    if (score >= 70) return 'AA';
    if (score >= 50) return 'A';
    return 'non-compliant';
  }

  private determineSecurityLevel(score: number): 'high' | 'medium' | 'low' | 'critical' {
    if (score >= 90) return 'high';
    if (score >= 70) return 'medium';
    if (score >= 50) return 'low';
    return 'critical';
  }

  private determinePerformanceGrade(score: number): 'A' | 'B' | 'C' | 'D' | 'F' {
    if (score >= 90) return 'A';
    if (score >= 70) return 'B';
    if (score >= 50) return 'C';
    if (score >= 30) return 'D';
    return 'F';
  }

  private checkLanguageDeclaration(): boolean {
    const html = this.dom.window.document.documentElement.getAttribute('lang');
    return !!html;
  }

  // Enhanced GDPR Analysis Methods
  private analyzeCookieBanner() {
    const selectors = [
      '[class*="cookie"]', '[id*="cookie"]', '[class*="consent"]', '[id*="consent"]',
      '[class*="gdpr"]', '[id*="gdpr"]', '[class*="banner"]', '[id*="banner"]',
      '[class*="notice"]', '[id*="notice"]', '[class*="popup"]', '[id*="popup"]',
      '[class*="modal"]', '[id*="modal"]', '[class*="toast"]', '[id*="toast"]',
      '[class*="privacy"]', '[id*="privacy"]', '[class*="accept"]', '[id*="accept"]',
      '[class*="reject"]', '[id*="reject"]', '[class*="decline"]', '[id*="decline"]',
    ];

    for (const selector of selectors) {
      const elements = this.dom.window.document.querySelectorAll(selector);
      for (const element of Array.from(elements)) {
        const text = element.textContent?.toLowerCase() || '';
        const html = element.innerHTML.toLowerCase();
        
        const cookieKeywords = ['cookie', 'consent', 'accept', 'gdpr', 'privacy', 'tracking', 'analytics', 'personal data'];
        const hasCookieKeywords = cookieKeywords.some(keyword => text.includes(keyword) || html.includes(keyword));
        
        const hasAcceptButton = element.querySelectorAll('button, input[type="button"], input[type="submit"], a[href="#"]').length > 0;
        const hasRejectButton = text.includes('reject') || text.includes('decline') || text.includes('no') || html.includes('reject') || html.includes('decline');
        
        const style = this.dom.window.getComputedStyle(element);
        const isVisible = style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
        
        if (hasCookieKeywords && (hasAcceptButton || isVisible)) {
          return {
            found: true,
            hasAcceptButton,
            hasRejectButton,
            details: {
              text: text.substring(0, 200),
              hasButtons: hasAcceptButton,
              hasRejectOption: hasRejectButton,
              isVisible
            }
          };
        }
      }
    }

    return { found: false, hasAcceptButton: false, hasRejectButton: false, details: null };
  }

  private analyzePrivacyPolicy() {
    // Check for privacy policy links
    const privacySelectors = [
      'a[href*="privacy"]', 'a[href*="policy"]', 'a[href*="privacy-policy"]', 'a[href*="privacy_policy"]',
      'a[href*="privacy-policy.html"]', 'a[href*="privacy-policy.php"]', 'a[href*="privacy-policy.asp"]',
      'a[href*="privacy-policy.aspx"]', 'a[href*="privacy-notice"]', 'a[href*="privacy_statement"]',
    ];

    for (const selector of privacySelectors) {
      const links = this.dom.window.document.querySelectorAll(selector);
      if (links.length > 0) {
        const link = links[0] as HTMLAnchorElement;
        const href = link.href;
        const text = link.textContent?.toLowerCase() || '';
        
        return {
          found: true,
          hasDataCollection: true, // Assume if privacy policy exists
          hasDataUsage: true,
          details: {
            link: href,
            linkText: text,
            foundIn: 'navigation'
          }
        };
      }
    }

    // Check for privacy policy text in content
    const textContent = this.html.toLowerCase();
    const privacyTexts = [
      'privacy policy', 'privacy notice', 'privacy statement', 'data protection policy',
      'information privacy', 'personal data policy', 'data privacy policy'
    ];

    const foundText = privacyTexts.find(text => textContent.includes(text));
    if (foundText) {
      return {
        found: true,
        hasDataCollection: textContent.includes('data collection') || textContent.includes('personal data'),
        hasDataUsage: textContent.includes('data usage') || textContent.includes('purpose') || textContent.includes('how we use'),
        details: {
          foundText,
          foundIn: 'content',
          hasDataCollectionInfo: textContent.includes('data collection') || textContent.includes('personal data'),
          hasDataUsageInfo: textContent.includes('data usage') || textContent.includes('purpose')
        }
      };
    }

    return { found: false, hasDataCollection: false, hasDataUsage: false, details: null };
  }

  private analyzeTermsOfService() {
    const termsSelectors = [
      'a[href*="terms"]', 'a[href*="service"]', 'a[href*="conditions"]', 'a[href*="terms-of-service"]',
      'a[href*="terms_of_service"]', 'a[href*="terms-and-conditions"]', 'a[href*="terms_conditions"]',
      'a[href*="user-agreement"]', 'a[href*="user_agreement"]', 'a[href*="service-agreement"]',
    ];

    for (const selector of termsSelectors) {
      const links = this.dom.window.document.querySelectorAll(selector);
      if (links.length > 0) {
        const link = links[0] as HTMLAnchorElement;
        return {
          found: true,
          details: {
            link: link.href,
            linkText: link.textContent?.toLowerCase() || '',
            foundIn: 'navigation'
          }
        };
      }
    }

    const textContent = this.html.toLowerCase();
    const termsTexts = [
      'terms of service', 'terms and conditions', 'terms & conditions', 'user agreement',
      'service agreement', 'terms of use', 'conditions of use'
    ];

    const foundText = termsTexts.find(text => textContent.includes(text));
    if (foundText) {
      return {
        found: true,
        details: {
          foundText,
          foundIn: 'content'
        }
      };
    }

    return { found: false, details: null };
  }

  private analyzeDataProcessingNotice() {
    const textContent = this.html.toLowerCase();
    const processingTexts = [
      'data processing', 'personal data', 'data protection', 'information processing',
      'data collection', 'data usage', 'data handling', 'data storage', 'data retention',
      'data sharing', 'data transfer', 'data processing notice', 'data processing agreement',
      'data processing policy', 'how we process', 'how we handle', 'how we collect'
    ];

    const foundTexts = processingTexts.filter(text => textContent.includes(text));
    
    return {
      found: foundTexts.length > 0,
      details: {
        foundTexts,
        hasProcessingInfo: foundTexts.length > 0,
        hasCollectionInfo: textContent.includes('data collection') || textContent.includes('personal data'),
        hasUsageInfo: textContent.includes('data usage') || textContent.includes('purpose')
      }
    };
  }

  private analyzeCookiePolicy() {
    const cookieSelectors = [
      'a[href*="cookie"]', 'a[href*="cookies"]', 'a[href*="cookie-policy"]', 'a[href*="cookie_policy"]',
      'a[href*="cookies-policy"]', 'a[href*="cookie-notice"]', 'a[href*="cookie_statement"]',
    ];

    for (const selector of cookieSelectors) {
      const links = this.dom.window.document.querySelectorAll(selector);
      if (links.length > 0) {
        const link = links[0] as HTMLAnchorElement;
        return {
          found: true,
          details: {
            link: link.href,
            linkText: link.textContent?.toLowerCase() || '',
            foundIn: 'navigation'
          }
        };
      }
    }

    const textContent = this.html.toLowerCase();
    const cookieTexts = [
      'cookie policy', 'cookie notice', 'cookie statement', 'cookies policy',
      'cookies notice', 'cookie information', 'cookie usage', 'cookie settings',
      'what cookies we use', 'how we use cookies'
    ];

    const foundText = cookieTexts.find(text => textContent.includes(text));
    if (foundText) {
      return {
        found: true,
        details: {
          foundText,
          foundIn: 'content',
          hasCookieTypes: textContent.includes('necessary') || textContent.includes('functional') || textContent.includes('analytics'),
          hasCookiePurposes: textContent.includes('purpose') || textContent.includes('why') || textContent.includes('how')
        }
      };
    }

    return { found: false, details: null };
  }

  private analyzeDataRetentionPolicy() {
    const textContent = this.html.toLowerCase();
    const retentionTexts = [
      'data retention', 'retention policy', 'data retention policy', 'retention period',
      'data storage period', 'how long we keep', 'how long we store', 'data retention period',
      'retention schedule', 'data retention schedule', 'how long', 'storage period',
      'keep data for', 'store data for', 'retain data for'
    ];

    const foundTexts = retentionTexts.filter(text => textContent.includes(text));
    
    return {
      found: foundTexts.length > 0,
      details: {
        foundTexts,
        hasTimeframes: textContent.includes('year') || textContent.includes('month') || textContent.includes('day') || textContent.includes('period'),
        hasSpecificPeriods: /\d+\s*(year|month|day|week)/.test(textContent)
      }
    };
  }

  private analyzeUserConsentMechanism() {
    const consentSelectors = [
      '[class*="consent"]', '[id*="consent"]', '[class*="opt-in"]', '[id*="opt-in"]',
      '[class*="opt-out"]', '[id*="opt-out"]', 'input[type="checkbox"][name*="consent"]',
      'input[type="radio"][name*="consent"]', 'button[class*="consent"]', 'button[id*="consent"]',
      '[class*="permission"]', '[id*="permission"]', '[class*="authorization"]', '[id*="authorization"]',
    ];

    for (const selector of consentSelectors) {
      const elements = this.dom.window.document.querySelectorAll(selector);
      if (elements.length > 0) {
        return {
          found: true,
          details: {
            foundIn: 'form elements',
            elementCount: elements.length,
            hasCheckboxes: elements.length > 0
          }
        };
      }
    }

    const textContent = this.html.toLowerCase();
    const consentTexts = [
      'consent', 'opt-in', 'opt-out', 'agree to', 'accept terms', 'i agree', 'i accept',
      'consent to', 'permission', 'authorization', 'give consent', 'withdraw consent',
      'consent management', 'consent preferences', 'consent settings'
    ];

    const foundTexts = consentTexts.filter(text => textContent.includes(text));
    
    return {
      found: foundTexts.length > 0,
      details: {
        foundTexts,
        hasConsentText: foundTexts.length > 0,
        hasGranularConsent: textContent.includes('granular') || textContent.includes('specific') || textContent.includes('different')
      }
    };
  }

  private analyzeDataPortability() {
    const textContent = this.html.toLowerCase();
    const portabilityTexts = [
      'data portability', 'export data', 'download data', 'data export', 'export my data',
      'download my data', 'data download', 'export information', 'data access',
      'right to data portability', 'data export functionality', 'download my information',
      'export personal data', 'data export tool', 'export functionality'
    ];

    const foundTexts = portabilityTexts.filter(text => textContent.includes(text));
    
    return {
      found: foundTexts.length > 0,
      details: {
        foundTexts,
        hasExportFunctionality: foundTexts.length > 0,
        hasDownloadOption: textContent.includes('download') || textContent.includes('export')
      }
    };
  }

  private analyzeRightToErasure() {
    const textContent = this.html.toLowerCase();
    const erasureTexts = [
      'right to erasure', 'right to be forgotten', 'delete data', 'delete my data',
      'remove data', 'data deletion', 'forget me', 'erase data', 'data erasure',
      'delete account', 'account deletion', 'data removal', 'request deletion',
      'delete personal data', 'remove personal data', 'data deletion request'
    ];

    const foundTexts = erasureTexts.filter(text => textContent.includes(text));
    
    return {
      found: foundTexts.length > 0,
      details: {
        foundTexts,
        hasDeletionFunctionality: foundTexts.length > 0,
        hasAccountDeletion: textContent.includes('delete account') || textContent.includes('account deletion')
      }
    };
  }

  private analyzeDataMinimization() {
    const forms = this.dom.window.document.querySelectorAll('form');
    const inputs = this.dom.window.document.querySelectorAll('input, select, textarea');
    const textContent = this.html.toLowerCase();
    
    // Check if forms have reasonable number of fields
    const hasReasonableFields = Array.from(forms).some(form => {
      const formInputs = Array.from(form.querySelectorAll('input, select, textarea'));
      return formInputs.length <= 10; // Reasonable number of fields
    });
    
    // Check for data minimization language
    const minimizationTexts = [
      'data minimization', 'minimal data', 'only necessary', 'required data',
      'essential data', 'minimal information', 'necessary information'
    ];
    
    const hasMinimizationLanguage = minimizationTexts.some(text => textContent.includes(text));
    
    return {
      compliant: hasReasonableFields || hasMinimizationLanguage,
      details: {
        formCount: forms.length,
        totalInputs: inputs.length,
        hasReasonableFields,
        hasMinimizationLanguage,
        averageFieldsPerForm: forms.length > 0 ? inputs.length / forms.length : 0
      }
    };
  }

  private analyzePurposeLimitation() {
    const textContent = this.html.toLowerCase();
    const purposeTexts = [
      'purpose of data collection', 'data processing purpose', 'data usage purpose',
      'data handling purpose', 'data retention purpose', 'data sharing purpose',
      'data transfer purpose', 'why we collect', 'how we use', 'purpose for',
      'data collection purpose', 'information purpose', 'personal data purpose'
    ];
    
    const foundTexts = purposeTexts.filter(text => textContent.includes(text));
    
    return {
      compliant: foundTexts.length > 0,
      details: {
        foundTexts,
        hasPurposeStatement: foundTexts.length > 0,
        hasSpecificPurposes: textContent.includes('specific') || textContent.includes('particular')
      }
    };
  }

  private analyzeLawfulBasis() {
    const textContent = this.html.toLowerCase();
    const lawfulBasisTexts = [
      'lawful basis for data processing', 'legal basis for data processing',
      'basis for data processing', 'data processing lawful basis', 'data processing legal basis',
      'consent', 'contract', 'legitimate interest', 'legal obligation', 'vital interest',
      'public task', 'legal basis', 'lawful basis', 'processing basis'
    ];
    
    const foundTexts = lawfulBasisTexts.filter(text => textContent.includes(text));
    
    return {
      compliant: foundTexts.length > 0,
      details: {
        foundTexts,
        hasLawfulBasis: foundTexts.length > 0,
        hasConsent: textContent.includes('consent'),
        hasContract: textContent.includes('contract'),
        hasLegitimateInterest: textContent.includes('legitimate interest')
      }
    };
  }

  private analyzeThirdPartyTracking() {
    const textContent = this.html.toLowerCase();
    const trackingScripts = [
      'google-analytics.com', 'googletagmanager.com', 'facebook.net', 'doubleclick.net',
      'hotjar.com', 'mixpanel.com', 'amplitude.com', 'segment.com', 'gtag', 'fbq',
      'google tag manager', 'facebook pixel', 'google analytics'
    ];
    
    const hasTracking = trackingScripts.some(script => textContent.includes(script));
    const hasConsent = textContent.includes('consent') || textContent.includes('opt-in') || textContent.includes('permission');
    
    return {
      hasTracking,
      hasConsent,
      details: {
        trackingScripts: trackingScripts.filter(script => textContent.includes(script)),
        hasConsentMechanism: hasConsent
      }
    };
  }

  private analyzeDataTransfer() {
    const textContent = this.html.toLowerCase();
    const transferTexts = [
      'international transfer', 'data transfer', 'cross-border', 'third country',
      'data sharing', 'international data', 'transfer safeguards', 'adequacy decision',
      'standard contractual clauses', 'binding corporate rules', 'transfer agreement'
    ];
    
    const hasInternationalTransfer = transferTexts.some(text => textContent.includes(text));
    const hasSafeguards = textContent.includes('safeguards') || textContent.includes('adequacy') || textContent.includes('contractual clauses');
    
    return {
      hasInternationalTransfer,
      hasSafeguards,
      details: {
        transferTexts: transferTexts.filter(text => textContent.includes(text)),
        hasSafeguards: hasSafeguards
      }
    };
  }

  private analyzeDataProtectionOfficer() {
    const textContent = this.html.toLowerCase();
    const dpoTexts = [
      'data protection officer', 'dpo', 'privacy officer', 'data protection contact',
      'privacy contact', 'data protection representative', 'gdpr contact'
    ];
    
    const foundTexts = dpoTexts.filter(text => textContent.includes(text));
    
    return {
      found: foundTexts.length > 0,
      details: {
        foundTexts,
        hasContactInfo: textContent.includes('@') || textContent.includes('email') || textContent.includes('contact')
      }
    };
  }

  private analyzeDataBreachNotification() {
    const textContent = this.html.toLowerCase();
    const breachTexts = [
      'data breach', 'breach notification', 'security incident', 'data security breach',
      'breach procedure', 'incident response', 'security breach', 'data incident'
    ];
    
    const foundTexts = breachTexts.filter(text => textContent.includes(text));
    
    return {
      found: foundTexts.length > 0,
      details: {
        foundTexts,
        hasNotificationProcedure: foundTexts.length > 0
      }
    };
  }

  private analyzeChildrenDataProtection() {
    const textContent = this.html.toLowerCase();
    const childrenTexts = [
      'children', 'child', 'under 13', 'under 16', 'minors', 'parental consent',
      'age verification', 'children\'s data', 'child data', 'young users'
    ];
    
    const hasChildrenData = childrenTexts.some(text => textContent.includes(text));
    const hasProtection = textContent.includes('parental consent') || textContent.includes('age verification') || textContent.includes('protection');
    
    return {
      hasChildrenData,
      hasProtection,
      details: {
        childrenTexts: childrenTexts.filter(text => textContent.includes(text)),
        hasProtectionMeasures: hasProtection
      }
    };
  }

  private analyzeAutomatedDecisionMaking() {
    const textContent = this.html.toLowerCase();
    const automatedTexts = [
      'automated decision', 'automated processing', 'algorithm', 'machine learning',
      'ai decision', 'automated profiling', 'automated assessment', 'algorithmic decision'
    ];
    
    const hasAutomatedDecisions = automatedTexts.some(text => textContent.includes(text));
    const hasSafeguards = textContent.includes('human review') || textContent.includes('manual review') || textContent.includes('appeal');
    
    return {
      hasAutomatedDecisions,
      hasSafeguards,
      details: {
        automatedTexts: automatedTexts.filter(text => textContent.includes(text)),
        hasSafeguards: hasSafeguards
      }
    };
  }

  private analyzeDataSubjectRights() {
    const textContent = this.html.toLowerCase();
    const rightsTexts = [
      'data subject rights', 'your rights', 'right to access', 'right to rectification',
      'right to erasure', 'right to object', 'right to portability', 'right to restriction',
      'data subject', 'your data rights', 'privacy rights', 'gdpr rights'
    ];
    
    const foundTexts = rightsTexts.filter(text => textContent.includes(text));
    
    return {
      found: foundTexts.length > 0,
      details: {
        foundTexts,
        hasRightsInformation: foundTexts.length > 0
      }
    };
  }

  private analyzePrivacyByDesign() {
    const textContent = this.html.toLowerCase();
    const privacyByDesignTexts = [
      'privacy by design', 'privacy by default', 'data protection by design',
      'privacy first', 'privacy-focused', 'privacy-centric', 'data minimization',
      'purpose limitation', 'storage limitation', 'accuracy', 'integrity',
      'confidentiality', 'accountability'
    ];
    
    const foundTexts = privacyByDesignTexts.filter(text => textContent.includes(text));
    
    return {
      compliant: foundTexts.length > 0,
      details: {
        foundTexts,
        hasPrivacyByDesign: foundTexts.length > 0
      }
    };
  }

  // Enhanced Performance Analysis Methods
  private analyzeImages() {
    const images = this.dom.window.document.querySelectorAll('img');
    const issues: string[] = [];
    let optimized = true;

    if (images.length > 0) {
      // Check for missing width/height attributes
      const imagesWithoutDimensions = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        return !imgElement.width || !imgElement.height;
      });
      
      if (imagesWithoutDimensions.length > 0) {
        issues.push(`${imagesWithoutDimensions.length} images missing width/height attributes`);
        optimized = false;
      }

      // Check for modern image formats
      const modernFormats = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        const src = imgElement.src;
        return src && (src.includes('.webp') || src.includes('.avif') || src.includes('.svg'));
      });
      
      if (modernFormats.length === 0 && images.length > 0) {
        issues.push('No modern image formats (WebP, AVIF) detected');
        optimized = false;
      }

      // Check for lazy loading
      const lazyLoadedImages = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        return imgElement.loading === 'lazy' || imgElement.getAttribute('data-src');
      });
      
      if (lazyLoadedImages.length === 0 && images.length > 5) {
        issues.push('No lazy loading implemented for images');
        optimized = false;
      }

      // Check for responsive images
      const responsiveImages = Array.from(images).filter(img => {
        const imgElement = img as HTMLImageElement;
        return imgElement.sizes || imgElement.srcset;
      });
      
      if (responsiveImages.length === 0 && images.length > 0) {
        issues.push('No responsive images detected');
        optimized = false;
      }
    }

    return {
      optimized,
      issues,
      details: {
        totalImages: images.length,
        imagesWithoutDimensions: images.length > 0 ? Array.from(images).filter(img => {
          const imgElement = img as HTMLImageElement;
          return !imgElement.width || !imgElement.height;
        }).length : 0,
        modernFormats: images.length > 0 ? Array.from(images).filter(img => {
          const imgElement = img as HTMLImageElement;
          const src = imgElement.src;
          return src && (src.includes('.webp') || src.includes('.avif') || src.includes('.svg'));
        }).length : 0,
        lazyLoaded: images.length > 0 ? Array.from(images).filter(img => {
          const imgElement = img as HTMLImageElement;
          return imgElement.loading === 'lazy' || imgElement.getAttribute('data-src');
        }).length : 0,
        responsive: images.length > 0 ? Array.from(images).filter(img => {
          const imgElement = img as HTMLImageElement;
          return imgElement.sizes || imgElement.srcset;
        }).length : 0
      }
    };
  }

  private analyzeResources() {
    const cssLinks = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]');
    const scriptTags = this.dom.window.document.querySelectorAll('script[src]');
    const issues: string[] = [];
    let optimized = true;

    // Check for minified resources
    const minifiedCSS = Array.from(cssLinks).filter(link => {
      const href = link.getAttribute('href') || '';
      return href.includes('.min.css') || href.includes('minified');
    });
    
    if (minifiedCSS.length === 0 && cssLinks.length > 0) {
      issues.push('CSS files not minified');
      optimized = false;
    }

    const minifiedJS = Array.from(scriptTags).filter(script => {
      const src = script.getAttribute('src') || '';
      return src.includes('.min.js') || src.includes('minified');
    });
    
    if (minifiedJS.length === 0 && scriptTags.length > 0) {
      issues.push('JavaScript files not minified');
      optimized = false;
    }

    // Check for resource bundling
    if (cssLinks.length > 3) {
      issues.push('Multiple CSS files detected - consider bundling');
      optimized = false;
    }

    if (scriptTags.length > 5) {
      issues.push('Multiple JavaScript files detected - consider bundling');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        cssFiles: cssLinks.length,
        jsFiles: scriptTags.length,
        minifiedCSS: minifiedCSS.length,
        minifiedJS: minifiedJS.length,
        totalResources: cssLinks.length + scriptTags.length
      }
    };
  }

  private analyzeCompression() {
    const contentEncoding = this.responseHeaders?.['content-encoding'] || this.responseHeaders?.['Content-Encoding'];
    const acceptEncoding = this.responseHeaders?.['accept-encoding'] || this.responseHeaders?.['Accept-Encoding'];
    
    return {
      enabled: !!(contentEncoding && (contentEncoding.includes('gzip') || contentEncoding.includes('br') || contentEncoding.includes('deflate'))),
      supported: !!(acceptEncoding && (acceptEncoding.includes('gzip') || acceptEncoding.includes('br') || acceptEncoding.includes('deflate'))),
      details: {
        contentEncoding,
        acceptEncoding,
        hasGzip: contentEncoding?.includes('gzip') || false,
        hasBrotli: contentEncoding?.includes('br') || false,
        hasDeflate: contentEncoding?.includes('deflate') || false
      }
    };
  }

  private analyzeCaching() {
    const cacheControl = this.responseHeaders?.['cache-control'] || this.responseHeaders?.['Cache-Control'];
    const expires = this.responseHeaders?.['expires'] || this.responseHeaders?.['Expires'];
    const etag = this.responseHeaders?.['etag'] || this.responseHeaders?.['ETag'];
    const lastModified = this.responseHeaders?.['last-modified'] || this.responseHeaders?.['Last-Modified'];
    
    return {
      enabled: !!(cacheControl || expires || etag || lastModified),
      hasCacheControl: !!cacheControl,
      hasExpires: !!expires,
      hasETag: !!etag,
      hasLastModified: !!lastModified,
      details: {
        cacheControl,
        expires,
        etag,
        lastModified,
        maxAge: cacheControl?.match(/max-age=(\d+)/)?.[1] || null
      }
    };
  }

  private analyzeCDN() {
    const cdnDomains = [
      'cdn.', 'static.', 'assets.', 'media.', 'img.', 'js.', 'css.',
      'cloudfront.net', 'cloudflare.com', 'fastly.com', 'akamai.com',
      'jsdelivr.net', 'unpkg.com', 'cdnjs.cloudflare.com'
    ];
    
    const url = this.url.toLowerCase();
    const used = cdnDomains.some(domain => url.includes(domain));
    
    return {
      used,
      details: {
        detectedCDN: cdnDomains.find(domain => url.includes(domain)) || null,
        url: this.url
      }
    };
  }

  private analyzeRenderBlocking() {
    const renderBlocking = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]:not([media="print"]), script:not([async]):not([defer])');
    return {
      count: renderBlocking.length,
      details: {
        cssFiles: this.dom.window.document.querySelectorAll('link[rel="stylesheet"]:not([media="print"])').length,
        jsFiles: this.dom.window.document.querySelectorAll('script:not([async]):not([defer])').length,
        totalBlocking: renderBlocking.length
      }
    };
  }

  private analyzeJavaScript() {
    const scripts = this.dom.window.document.querySelectorAll('script');
    const issues: string[] = [];
    let optimized = true;

    // Check for async/defer attributes
    const blockingScripts = Array.from(scripts).filter(script => {
      return !script.async && !script.defer && script.src;
    });
    
    if (blockingScripts.length > 0) {
      issues.push(`${blockingScripts.length} blocking JavaScript files detected`);
      optimized = false;
    }

    // Check for inline scripts
    const inlineScripts = Array.from(scripts).filter(script => !script.src);
    if (inlineScripts.length > 3) {
      issues.push(`${inlineScripts.length} inline scripts detected - consider externalizing`);
      optimized = false;
    }

    // Check for large scripts
    const largeScripts = Array.from(scripts).filter(script => {
      const src = script.getAttribute('src') || '';
      return src.includes('large') || src.includes('bundle') || src.includes('vendor');
    });
    
    if (largeScripts.length > 0) {
      issues.push(`${largeScripts.length} potentially large JavaScript files detected`);
      optimized = false;
    }

    return {
      optimized,
      issues,
      unusedJS: blockingScripts.length,
      details: {
        totalScripts: scripts.length,
        externalScripts: Array.from(scripts).filter(script => script.src).length,
        inlineScripts: inlineScripts.length,
        asyncScripts: Array.from(scripts).filter(script => script.async).length,
        deferScripts: Array.from(scripts).filter(script => script.defer).length,
        blockingScripts: blockingScripts.length
      }
    };
  }

  private analyzeCSS() {
    const cssLinks = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]');
    const issues: string[] = [];
    let optimized = true;

    // Check for unused CSS (simplified)
    if (cssLinks.length > 3) {
      issues.push(`${cssLinks.length} CSS files detected - consider bundling`);
      optimized = false;
    }

    // Check for large CSS files
    const largeCSS = Array.from(cssLinks).filter(link => {
      const href = link.getAttribute('href') || '';
      return href.includes('large') || href.includes('bundle') || href.includes('vendor');
    });
    
    if (largeCSS.length > 0) {
      issues.push(`${largeCSS.length} potentially large CSS files detected`);
      optimized = false;
    }

    // Check for critical CSS
    const criticalCSS = Array.from(cssLinks).filter(link => {
      const media = link.getAttribute('media') || '';
      return media === 'print' || media.includes('critical');
    });
    
    if (criticalCSS.length === 0 && cssLinks.length > 0) {
      issues.push('No critical CSS detected');
      optimized = false;
    }

    return {
      optimized,
      issues,
      unusedCSS: cssLinks.length > 3 ? cssLinks.length - 3 : 0,
      details: {
        totalCSS: cssLinks.length,
        largeCSS: largeCSS.length,
        criticalCSS: criticalCSS.length,
        printCSS: Array.from(cssLinks).filter(link => link.getAttribute('media') === 'print').length
      }
    };
  }

  private analyzeFonts() {
    const fontLinks = this.dom.window.document.querySelectorAll('link[rel="preload"][as="font"], link[rel="stylesheet"][href*="font"]');
    const issues: string[] = [];
    let optimized = true;

    // Check for font preloading
    const preloadedFonts = Array.from(fontLinks).filter(link => link.getAttribute('rel') === 'preload');
    if (preloadedFonts.length === 0 && fontLinks.length > 0) {
      issues.push('No font preloading detected');
      optimized = false;
    }

    // Check for font-display
    const fontDisplay = this.html.includes('font-display: swap') || this.html.includes('font-display:fallback');
    if (!fontDisplay && fontLinks.length > 0) {
      issues.push('No font-display: swap detected');
      optimized = false;
    }

    // Check for excessive fonts
    if (fontLinks.length > 3) {
      issues.push(`${fontLinks.length} font files detected - consider reducing`);
      optimized = false;
    }

    // Check for @import font declarations in CSS
    const hasImportFonts = this.html.includes('@import') && this.html.includes('font');
    if (hasImportFonts) {
      issues.push('Fonts loaded via @import - consider using link tags for better performance');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        totalFonts: fontLinks.length,
        preloadedFonts: preloadedFonts.length,
        hasFontDisplay: fontDisplay,
        hasImportFonts,
        fontFamilies: this.extractFontFamilies()
      }
    };
  }

  private analyzeThirdPartyResources() {
    const scripts = this.dom.window.document.querySelectorAll('script[src]');
    const links = this.dom.window.document.querySelectorAll('link[href]');
    const thirdPartyDomains = [
      'google-analytics.com', 'googletagmanager.com', 'facebook.net', 'doubleclick.net',
      'hotjar.com', 'mixpanel.com', 'amplitude.com', 'segment.com', 'stripe.com',
      'paypal.com', 'recaptcha.google.com', 'cdnjs.cloudflare.com', 'unpkg.com',
      'jsdelivr.net', 'code.jquery.com', 'cdn.jsdelivr.net'
    ];
    
    const thirdPartyScripts = Array.from(scripts).filter(script => {
      const src = script.getAttribute('src') || '';
      return thirdPartyDomains.some(domain => src.includes(domain));
    });
    
    const thirdPartyLinks = Array.from(links).filter(link => {
      const href = link.getAttribute('href') || '';
      return thirdPartyDomains.some(domain => href.includes(domain));
    });
    
    const totalThirdParty = thirdPartyScripts.length + thirdPartyLinks.length;
    
    return {
      hasExcessiveThirdParty: totalThirdParty > 5,
      count: totalThirdParty,
      details: {
        thirdPartyScripts: thirdPartyScripts.length,
        thirdPartyLinks: thirdPartyLinks.length,
        totalThirdParty,
        domains: thirdPartyDomains.filter(domain => 
          this.html.includes(domain)
        )
      }
    };
  }

  private analyzeHTTP2() {
    const server = this.responseHeaders?.['server'] || this.responseHeaders?.['Server'] || '';
    const protocol = this.url.startsWith('https://') ? 'https' : 'http';
    
    // HTTP/2 is typically used with HTTPS
    const hasHTTP2 = protocol === 'https' && (
      server.includes('nginx') || 
      server.includes('apache') || 
      server.includes('cloudflare') ||
      server.includes('fastly') ||
      server.includes('akamai')
    );
    
    return {
      enabled: hasHTTP2,
      details: {
        protocol,
        server,
        hasHTTPS: protocol === 'https',
        likelyHTTP2: hasHTTP2
      }
    };
  }

  private analyzeSecurityHeaders() {
    const headers = this.responseHeaders || {};
    const issues: string[] = [];
    let optimized = true;

    // Check for X-Frame-Options
    const hasXFrameOptions = headers['x-frame-options'] || headers['X-Frame-Options'];
    if (!hasXFrameOptions) {
      issues.push('No X-Frame-Options header');
      optimized = false;
    }

    // Check for X-Content-Type-Options
    const hasXContentTypeOptions = headers['x-content-type-options'] || headers['X-Content-Type-Options'];
    if (!hasXContentTypeOptions) {
      issues.push('No X-Content-Type-Options header');
      optimized = false;
    }

    // Check for Referrer Policy
    const hasReferrerPolicy = headers['referrer-policy'] || headers['Referrer-Policy'];
    if (!hasReferrerPolicy) {
      issues.push('No Referrer Policy header');
      optimized = false;
    }

    // Check for Permissions Policy
    const hasPermissionsPolicy = headers['permissions-policy'] || headers['Permissions-Policy'];
    if (!hasPermissionsPolicy) {
      issues.push('No Permissions Policy header');
      optimized = false;
    }

    // Check for X-XSS-Protection
    const hasXSSProtection = headers['x-xss-protection'] || headers['X-XSS-Protection'];
    if (!hasXSSProtection) {
      issues.push('No X-XSS-Protection header');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        hasXFrameOptions: !!hasXFrameOptions,
        hasXContentTypeOptions: !!hasXContentTypeOptions,
        hasReferrerPolicy: !!hasReferrerPolicy,
        hasPermissionsPolicy: !!hasPermissionsPolicy,
        hasXSSProtection: !!hasXSSProtection,
        totalHeaders: [hasXFrameOptions, hasXContentTypeOptions, hasReferrerPolicy, hasPermissionsPolicy, hasXSSProtection].filter(Boolean).length
      }
    };
  }

  private calculateRealCoreWebVitals() {
    // Calculate FCP based on real data
    const baseFCP = this.loadTime * 0.3;
    const resourcePenalty = this.dom.window.document.querySelectorAll('link[rel="stylesheet"], script[src]').length * 50;
    const sizePenalty = this.pageSize > 1000000 ? (this.pageSize - 1000000) / 100000 : 0;
    const fcp = Math.round(baseFCP + resourcePenalty + sizePenalty);
    
    // Calculate LCP based on FCP and images
    const images = this.dom.window.document.querySelectorAll('img');
    const imagePenalty = images.length * 100;
    const lcp = Math.round(fcp + imagePenalty + 500);
    
    // Calculate CLS based on layout stability
    const imagesWithoutDimensions = Array.from(images).filter(img => {
      const imgElement = img as HTMLImageElement;
      return !imgElement.width || !imgElement.height;
    });
    
    const baseCLS = 0.01;
    const dimensionPenalty = imagesWithoutDimensions.length * 0.02;
    const resourcePenaltyCLS = this.dom.window.document.querySelectorAll('link[rel="stylesheet"]').length * 0.005;
    const cls = Math.min(1.0, baseCLS + dimensionPenalty + resourcePenaltyCLS);
    
    // Calculate FID based on JavaScript
    const scripts = this.dom.window.document.querySelectorAll('script');
    const inlineScripts = Array.from(scripts).filter(script => !script.src);
    const externalScripts = Array.from(scripts).filter(script => script.src);
    
    const baseFID = 50;
    const inlinePenalty = inlineScripts.length * 20;
    const externalPenalty = externalScripts.length * 30;
    const fid = Math.round(baseFID + inlinePenalty + externalPenalty);
    
    return { fcp, lcp, cls, fid };
  }

  private analyzePerformanceBudget() {
    const budget = {
      pageSize: 2000000, // 2MB
      loadTime: 3000, // 3 seconds
      resources: 20, // 20 resources
      images: 10 // 10 images
    };
    
    const images = this.dom.window.document.querySelectorAll('img');
    const resources = this.dom.window.document.querySelectorAll('link[rel="stylesheet"], script[src]');
    
    const exceeded = [];
    if (this.pageSize > budget.pageSize) exceeded.push(`Page size (${Math.round(this.pageSize/1024)}KB > ${Math.round(budget.pageSize/1024)}KB)`);
    if (this.loadTime > budget.loadTime) exceeded.push(`Load time (${this.loadTime}ms > ${budget.loadTime}ms)`);
    if (resources.length > budget.resources) exceeded.push(`Resources (${resources.length} > ${budget.resources})`);
    if (images.length > budget.images) exceeded.push(`Images (${images.length} > ${budget.images})`);
    
    return {
      withinBudget: exceeded.length === 0,
      details: exceeded.join(', '),
      metrics: {
        pageSize: this.pageSize,
        loadTime: this.loadTime,
        resources: resources.length,
        images: images.length
      }
    };
  }

  private analyzeMobilePerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Check for viewport meta tag
    const viewport = this.dom.window.document.querySelector('meta[name="viewport"]');
    if (!viewport) {
      issues.push('No viewport meta tag found');
      optimized = false;
    }

    // Check for touch-friendly elements
    const touchElements = this.dom.window.document.querySelectorAll('button, a, input, select');
    const smallTouchElements = Array.from(touchElements).filter(el => {
      const element = el as HTMLElement;
      const style = this.dom.window.getComputedStyle(element);
      const width = parseInt(style.width) || 0;
      const height = parseInt(style.height) || 0;
      return width < 44 || height < 44; // Minimum touch target size
    });
    
    if (smallTouchElements.length > 0) {
      issues.push(`${smallTouchElements.length} elements may be too small for touch`);
      optimized = false;
    }

    // Check for mobile-specific optimizations
    const hasMobileOptimizations = this.html.includes('mobile') || this.html.includes('responsive') || this.html.includes('adaptive');
    if (!hasMobileOptimizations) {
      issues.push('No mobile-specific optimizations detected');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        hasViewport: !!viewport,
        touchElements: touchElements.length,
        smallTouchElements: smallTouchElements.length,
        hasMobileOptimizations
      }
    };
  }

  private analyzeResourceLoading() {
    const issues: string[] = [];
    let optimized = true;

    // Check for resource priorities
    const preloads = this.dom.window.document.querySelectorAll('link[rel="preload"]');
    const prefetches = this.dom.window.document.querySelectorAll('link[rel="prefetch"]');
    
    if (preloads.length === 0 && this.dom.window.document.querySelectorAll('link[rel="stylesheet"], script[src]').length > 5) {
      issues.push('No resource preloading detected');
      optimized = false;
    }

    // Check for critical resources
    const criticalResources = this.dom.window.document.querySelectorAll('link[rel="preload"], link[rel="dns-prefetch"], link[rel="preconnect"]');
    if (criticalResources.length === 0) {
      issues.push('No critical resource optimization detected');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        preloads: preloads.length,
        prefetches: prefetches.length,
        criticalResources: criticalResources.length,
        totalResources: this.dom.window.document.querySelectorAll('link[rel="stylesheet"], script[src]').length
      }
    };
  }

  private analyzeDatabasePerformance() {
    // This is a simplified check - in a real implementation, you'd analyze actual database queries
    const issues: string[] = [];
    let hasIssues = false;

    // Check for potential database-related issues in HTML
    const hasDatabaseIssues = this.html.includes('database error') || this.html.includes('sql error') || this.html.includes('query timeout');
    if (hasDatabaseIssues) {
      issues.push('Potential database performance issues detected');
      hasIssues = true;
    }

    return {
      hasIssues,
      issues,
      details: {
        hasDatabaseIssues,
        potentialOptimizations: !hasDatabaseIssues
      }
    };
  }

  private analyzeServerPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Check server response time
    if (this.loadTime > 2000) {
      issues.push('Slow server response time');
      optimized = false;
    }

    // Check for server-side caching
    const hasServerCaching = this.responseHeaders?.['x-cache'] || this.responseHeaders?.['cf-cache-status'] || this.responseHeaders?.['x-powered-by'];
    if (!hasServerCaching) {
      issues.push('No server-side caching detected');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        responseTime: this.loadTime,
        hasServerCaching: !!hasServerCaching,
        server: this.responseHeaders?.['server'] || this.responseHeaders?.['Server'] || 'Unknown'
      }
    };
  }

  private extractFontFamilies(): string[] {
    const fontFamilies: string[] = [];
    const styleSheets = this.dom.window.document.styleSheets;
    
    try {
      for (let i = 0; i < styleSheets.length; i++) {
        const rules = styleSheets[i].cssRules || styleSheets[i].rules;
        if (rules) {
          for (let j = 0; j < rules.length; j++) {
            const rule = rules[j] as CSSStyleRule;
            if (rule.style && rule.style.fontFamily) {
              const fontFamily = rule.style.fontFamily;
              if (!fontFamilies.includes(fontFamily)) {
                fontFamilies.push(fontFamily);
              }
            }
          }
        }
      }
    } catch (e) {
      // Cross-origin stylesheets will throw an error
    }
    
    return fontFamilies;
  }

  // Additional Comprehensive Performance Analysis Methods
  private analyzeNetworkPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze DNS lookups
    const externalDomains = this.extractExternalDomains();
    if (externalDomains.length > 10) {
      issues.push(`${externalDomains.length} external domains detected - consider reducing DNS lookups`);
      optimized = false;
    }

    // Analyze connection reuse
    const hasConnectionReuse = this.responseHeaders?.['connection'] === 'keep-alive' || 
                              this.responseHeaders?.['Connection'] === 'keep-alive';
    if (!hasConnectionReuse) {
      issues.push('No connection reuse detected');
      optimized = false;
    }

    // Analyze request optimization
    const totalRequests = this.dom.window.document.querySelectorAll('link[rel="stylesheet"], script[src], img[src]').length;
    if (totalRequests > 50) {
      issues.push(`${totalRequests} total requests detected - consider reducing`);
      optimized = false;
    }

    // Analyze protocol optimization
    const protocol = this.url.startsWith('https://') ? 'https' : 'http';
    if (protocol === 'http') {
      issues.push('HTTP protocol detected - upgrade to HTTPS for better performance');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        externalDomains: externalDomains.length,
        domains: externalDomains,
        hasConnectionReuse,
        totalRequests,
        protocol,
        hasHTTPS: protocol === 'https'
      }
    };
  }

  private analyzeDOMPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze DOM size
    const totalElements = this.dom.window.document.querySelectorAll('*').length;
    if (totalElements > 1500) {
      issues.push(`Large DOM tree: ${totalElements} elements detected`);
      optimized = false;
    }

    // Analyze DOM depth
    const maxDepth = this.calculateDOMDepth();
    if (maxDepth > 15) {
      issues.push(`Deep DOM structure: ${maxDepth} levels deep`);
      optimized = false;
    }

    // Analyze inline styles
    const elementsWithInlineStyles = this.dom.window.document.querySelectorAll('[style]').length;
    if (elementsWithInlineStyles > 20) {
      issues.push(`${elementsWithInlineStyles} elements with inline styles detected`);
      optimized = false;
    }

    // Analyze DOM manipulation
    const hasDOMManipulation = this.html.includes('innerHTML') || this.html.includes('outerHTML') || 
                              this.html.includes('appendChild') || this.html.includes('insertBefore');
    if (hasDOMManipulation) {
      issues.push('DOM manipulation detected - consider using virtual DOM');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        totalElements,
        maxDepth,
        elementsWithInlineStyles,
        hasDOMManipulation,
        domComplexity: totalElements > 1000 ? 'high' : totalElements > 500 ? 'medium' : 'low'
      }
    };
  }

  private analyzeEventHandlerPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze event listeners
    const eventKeywords = ['onclick', 'onload', 'onscroll', 'onresize', 'oninput', 'onchange', 'onsubmit'];
    const eventListeners = eventKeywords.filter(event => this.html.includes(event));
    
    if (eventListeners.length > 10) {
      issues.push(`${eventListeners.length} inline event handlers detected`);
      optimized = false;
    }

    // Analyze event delegation
    const hasEventDelegation = this.html.includes('addEventListener') || this.html.includes('removeEventListener');
    if (!hasEventDelegation && eventListeners.length > 0) {
      issues.push('No event delegation detected - consider using event delegation');
      optimized = false;
    }

    // Analyze scroll events
    const hasScrollEvents = this.html.includes('onscroll') || this.html.includes('scroll');
    if (hasScrollEvents) {
      issues.push('Scroll events detected - consider throttling or debouncing');
      optimized = false;
    }

    // Analyze resize events
    const hasResizeEvents = this.html.includes('onresize') || this.html.includes('resize');
    if (hasResizeEvents) {
      issues.push('Resize events detected - consider throttling');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        eventListeners: eventListeners.length,
        events: eventListeners,
        hasEventDelegation,
        hasScrollEvents,
        hasResizeEvents,
        totalEventHandlers: eventListeners.length
      }
    };
  }

  private analyzeAnimationPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze CSS animations
    const hasCSSAnimations = this.html.includes('animation') || this.html.includes('@keyframes') || 
                            this.html.includes('transition') || this.html.includes('transform');
    if (hasCSSAnimations) {
      // Check for hardware acceleration
      const hasHardwareAcceleration = this.html.includes('transform3d') || this.html.includes('translate3d') || 
                                     this.html.includes('will-change') || this.html.includes('backface-visibility');
      if (!hasHardwareAcceleration) {
        issues.push('CSS animations detected without hardware acceleration');
        optimized = false;
      }
    }

    // Analyze JavaScript animations
    const hasJSAnimations = this.html.includes('setInterval') || this.html.includes('setTimeout') || 
                           this.html.includes('requestAnimationFrame') || this.html.includes('animate');
    if (hasJSAnimations) {
      issues.push('JavaScript animations detected - consider using CSS animations');
      optimized = false;
    }

    // Analyze animation libraries
    const animationLibraries = ['jquery.animate', 'gsap', 'anime.js', 'velocity', 'mo.js', 'lottie'];
    const detectedLibraries = animationLibraries.filter(lib => this.html.includes(lib));
    if (detectedLibraries.length > 1) {
      issues.push(`Multiple animation libraries detected: ${detectedLibraries.join(', ')}`);
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        hasCSSAnimations,
        hasJSAnimations,
        hasHardwareAcceleration: this.html.includes('transform3d') || this.html.includes('translate3d') || 
                                this.html.includes('will-change') || this.html.includes('backface-visibility'),
        animationLibraries: detectedLibraries,
        totalLibraries: detectedLibraries.length
      }
    };
  }

  private analyzeMediaPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze video elements
    const videos = this.dom.window.document.querySelectorAll('video');
    if (videos.length > 0) {
      const videosWithoutPreload = Array.from(videos).filter(video => !video.preload);
      if (videosWithoutPreload.length > 0) {
        issues.push(`${videosWithoutPreload.length} videos without preload attribute`);
        optimized = false;
      }

      const videosWithoutPoster = Array.from(videos).filter(video => !video.poster);
      if (videosWithoutPoster.length > 0) {
        issues.push(`${videosWithoutPoster.length} videos without poster attribute`);
        optimized = false;
      }
    }

    // Analyze audio elements
    const audios = this.dom.window.document.querySelectorAll('audio');
    if (audios.length > 0) {
      const audiosWithoutPreload = Array.from(audios).filter(audio => !audio.preload);
      if (audiosWithoutPreload.length > 0) {
        issues.push(`${audiosWithoutPreload.length} audio elements without preload attribute`);
        optimized = false;
      }
    }

    // Analyze media formats
    const mediaFormats = this.extractMediaFormats();
    const modernFormats = mediaFormats.filter(format => ['webm', 'mp4', 'ogg', 'webp', 'avif'].includes(format));
    if (modernFormats.length === 0 && mediaFormats.length > 0) {
      issues.push('No modern media formats detected');
      optimized = false;
    }

    // Analyze media loading
    const hasLazyMedia = this.html.includes('loading="lazy"') || this.html.includes('data-src');
    if (!hasLazyMedia && (videos.length > 0 || audios.length > 0)) {
      issues.push('No lazy loading for media elements');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        totalVideos: videos.length,
        totalAudios: audios.length,
        videosWithoutPreload: videos.length > 0 ? Array.from(videos).filter(video => !video.preload).length : 0,
        videosWithoutPoster: videos.length > 0 ? Array.from(videos).filter(video => !video.poster).length : 0,
        audiosWithoutPreload: audios.length > 0 ? Array.from(audios).filter(audio => !audio.preload).length : 0,
        mediaFormats,
        modernFormats: modernFormats.length,
        hasLazyMedia
      }
    };
  }

  private analyzeAPIPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze API endpoints
    const apiEndpoints = this.extractAPIEndpoints();
    if (apiEndpoints.length > 10) {
      issues.push(`${apiEndpoints.length} API endpoints detected - consider consolidating`);
      optimized = false;
    }

    // Analyze API calls
    const apiCallPatterns = ['fetch(', 'XMLHttpRequest', 'axios', '$.ajax', 'api/', '/api/'];
    const apiCalls = apiCallPatterns.filter(pattern => this.html.includes(pattern));
    if (apiCalls.length > 5) {
      issues.push(`${apiCalls.length} API call patterns detected`);
      optimized = false;
    }

    // Analyze API caching
    const hasAPICaching = this.html.includes('cache') || this.html.includes('Cache-Control') || 
                         this.html.includes('ETag') || this.html.includes('Last-Modified');
    if (!hasAPICaching && apiCalls.length > 0) {
      issues.push('No API caching detected');
      optimized = false;
    }

    // Analyze API error handling
    const hasAPIErrorHandling = this.html.includes('catch') || this.html.includes('error') || 
                               this.html.includes('try') || this.html.includes('finally');
    if (!hasAPIErrorHandling && apiCalls.length > 0) {
      issues.push('No API error handling detected');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        apiEndpoints: apiEndpoints.length,
        hasAPIAuth: this.html.includes('api_key') || this.html.includes('bearer') ||
                   this.html.includes('oauth') || this.html.includes('jwt'),
        hasRateLimiting: this.html.includes('rate limit') || this.html.includes('throttle') ||
                        this.html.includes('quota') || this.html.includes('limit'),
        endpoints: apiEndpoints
      }
    };
  }

  private analyzeMemoryPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze memory leaks
    const memoryLeakPatterns = ['addEventListener', 'setInterval', 'setTimeout', 'global', 'window.'];
    const memoryLeakIndicators = memoryLeakPatterns.filter(pattern => this.html.includes(pattern));
    if (memoryLeakIndicators.length > 10) {
      issues.push(`${memoryLeakIndicators.length} potential memory leak patterns detected`);
      optimized = false;
    }

    // Analyze large objects
    const largeObjectPatterns = ['JSON.parse', 'JSON.stringify', 'localStorage', 'sessionStorage'];
    const largeObjectIndicators = largeObjectPatterns.filter(pattern => this.html.includes(pattern));
    if (largeObjectIndicators.length > 5) {
      issues.push(`${largeObjectIndicators.length} large object operations detected`);
      optimized = false;
    }

    // Analyze garbage collection
    const hasGarbageCollection = this.html.includes('delete') || this.html.includes('null') || 
                                this.html.includes('undefined') || this.html.includes('removeEventListener');
    if (!hasGarbageCollection && memoryLeakIndicators.length > 0) {
      issues.push('No garbage collection patterns detected');
      optimized = false;
    }

    // Analyze memory optimization
    const hasMemoryOptimization = this.html.includes('WeakMap') || this.html.includes('WeakSet') || 
                                 this.html.includes('Object.freeze') || this.html.includes('Object.seal');
    if (!hasMemoryOptimization) {
      issues.push('No memory optimization patterns detected');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        memoryLeakPatterns: memoryLeakIndicators.length,
        patterns: memoryLeakIndicators,
        largeObjectOperations: largeObjectIndicators.length,
        operations: largeObjectIndicators,
        hasGarbageCollection,
        hasMemoryOptimization,
        totalMemoryPatterns: memoryLeakIndicators.length + largeObjectIndicators.length
      }
    };
  }

  private analyzeAccessibilityPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze ARIA attributes - use a different approach since [aria-*] is not a valid selector
    const allElements = this.dom.window.document.querySelectorAll('*');
    const ariaElements = Array.from(allElements).filter(element => {
      const attributes = element.attributes;
      for (let i = 0; i < attributes.length; i++) {
        if (attributes[i].name.startsWith('aria-')) {
          return true;
        }
      }
      return false;
    });
    
    if (ariaElements.length > 50) {
      issues.push(`${ariaElements.length} ARIA attributes detected - consider reducing complexity`);
      optimized = false;
    }

    // Analyze focus management
    const focusElements = this.dom.window.document.querySelectorAll('[tabindex], button, a, input, select, textarea');
    const focusableElements = Array.from(focusElements).filter(el => {
      const element = el as HTMLElement;
      return element.tabIndex >= 0 || element.tagName.toLowerCase() === 'button' || 
             element.tagName.toLowerCase() === 'a' || element.tagName.toLowerCase() === 'input';
    });
    
    if (focusableElements.length > 100) {
      issues.push(`${focusableElements.length} focusable elements detected - consider reducing`);
      optimized = false;
    }

    // Analyze screen reader performance
    const screenReaderElements = this.dom.window.document.querySelectorAll('[role], [aria-label], [aria-labelledby]');
    if (screenReaderElements.length > 30) {
      issues.push(`${screenReaderElements.length} screen reader elements detected - consider optimizing`);
      optimized = false;
    }

    // Analyze keyboard navigation
    const hasKeyboardNavigation = this.html.includes('keydown') || this.html.includes('keyup') || 
                                 this.html.includes('keypress') || this.html.includes('tabindex');
    if (!hasKeyboardNavigation) {
      issues.push('No keyboard navigation detected');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        ariaElements: ariaElements.length,
        focusableElements: focusableElements.length,
        screenReaderElements: screenReaderElements.length,
        hasKeyboardNavigation,
        accessibilityComplexity: ariaElements.length > 30 ? 'high' : ariaElements.length > 15 ? 'medium' : 'low'
      }
    };
  }

  private analyzeSEOPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze meta tags
    const metaTags = this.dom.window.document.querySelectorAll('meta');
    if (metaTags.length > 20) {
      issues.push(`${metaTags.length} meta tags detected - consider reducing`);
      optimized = false;
    }

    // Analyze structured data
    const structuredData = this.dom.window.document.querySelectorAll('script[type="application/ld+json"]');
    if (structuredData.length === 0) {
      issues.push('No structured data detected');
      optimized = false;
    }

    // Analyze heading structure
    const headings = this.dom.window.document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    const h1Count = this.dom.window.document.querySelectorAll('h1').length;
    if (h1Count > 1) {
      issues.push(`${h1Count} H1 tags detected - should have only one`);
      optimized = false;
    }

    // Analyze internal links
    const internalLinks = this.dom.window.document.querySelectorAll('a[href^="/"], a[href^="' + this.url + '"]');
    if (internalLinks.length < 5) {
      issues.push('Few internal links detected');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        metaTags: metaTags.length,
        structuredData: structuredData.length,
        headings: headings.length,
        h1Count,
        internalLinks: internalLinks.length,
        seoScore: this.calculateSEOScore(metaTags.length, structuredData.length, h1Count, internalLinks.length)
      }
    };
  }

  private analyzePWAPerformance() {
    const issues: string[] = [];
    let optimized = true;

    // Analyze service worker
    const hasServiceWorker = this.html.includes('serviceWorker') || this.html.includes('sw.js') || 
                            this.html.includes('service-worker');
    if (!hasServiceWorker) {
      issues.push('No service worker detected');
      optimized = false;
    }

    // Analyze manifest
    const hasManifest = this.dom.window.document.querySelector('link[rel="manifest"]');
    if (!hasManifest) {
      issues.push('No web app manifest detected');
      optimized = false;
    }

    // Analyze offline support
    const hasOfflineSupport = this.html.includes('offline') || this.html.includes('cache') || 
                             this.html.includes('localStorage') || this.html.includes('sessionStorage');
    if (!hasOfflineSupport) {
      issues.push('No offline support detected');
      optimized = false;
    }

    // Analyze app-like features
    const hasAppFeatures = this.html.includes('install') || this.html.includes('beforeinstallprompt') || 
                          this.html.includes('standalone') || this.html.includes('fullscreen');
    if (!hasAppFeatures) {
      issues.push('No app-like features detected');
      optimized = false;
    }

    return {
      optimized,
      issues,
      details: {
        hasServiceWorker,
        hasManifest: !!hasManifest,
        hasOfflineSupport,
        hasAppFeatures,
        pwaScore: this.calculatePWAScore(hasServiceWorker, !!hasManifest, hasOfflineSupport, hasAppFeatures)
      }
    };
  }

  // Helper methods for the new analysis functions
  private extractExternalDomains(): string[] {
    const domains = new Set<string>();
    const url = new URL(this.url);
    const baseDomain = url.hostname;

    // Extract domains from all external resources
    const externalResources = this.dom.window.document.querySelectorAll('link[href], script[src], img[src], video[src], audio[src]');
    
    externalResources.forEach(resource => {
      const href = resource.getAttribute('href') || resource.getAttribute('src');
      if (href && href.startsWith('http')) {
        try {
          const resourceUrl = new URL(href);
          if (resourceUrl.hostname !== baseDomain) {
            domains.add(resourceUrl.hostname);
          }
        } catch (e) {
          // Invalid URL, skip
        }
      }
    });

    return Array.from(domains);
  }

  private calculateDOMDepth(): number {
    let maxDepth = 0;
    
    const calculateDepth = (element: Element, depth: number) => {
      maxDepth = Math.max(maxDepth, depth);
      const children = element.children;
      for (let i = 0; i < children.length; i++) {
        calculateDepth(children[i], depth + 1);
      }
    };

    calculateDepth(this.dom.window.document.body, 0);
    return maxDepth;
  }

  private extractMediaFormats(): string[] {
    const formats: string[] = [];
    const mediaElements = this.dom.window.document.querySelectorAll('video[src], audio[src], source[src]');
    
    mediaElements.forEach(element => {
      const src = element.getAttribute('src');
      if (src) {
        const extension = src.split('.').pop()?.toLowerCase();
        if (extension && !formats.includes(extension)) {
          formats.push(extension);
        }
      }
    });

    return formats;
  }

  private extractAPIEndpoints(): string[] {
    const endpoints: string[] = [];
    const apiPatterns = [
      /\/api\/[a-zA-Z0-9\/-]+/g,
      /\/v[0-9]+\/[a-zA-Z0-9\/-]+/g,
      /\/rest\/[a-zA-Z0-9\/-]+/g,
      /\/graphql/g
    ];

    apiPatterns.forEach(pattern => {
      const matches = this.html.match(pattern);
      if (matches) {
        matches.forEach(match => {
          if (!endpoints.includes(match)) {
            endpoints.push(match);
          }
        });
      }
    });

    return endpoints;
  }

  private calculateSEOScore(metaCount: number, structuredDataCount: number, h1Count: number, internalLinksCount: number): number {
    let score = 100;
    
    if (metaCount > 20) score -= 10;
    if (structuredDataCount === 0) score -= 20;
    if (h1Count > 1) score -= 15;
    if (internalLinksCount < 5) score -= 10;
    
    return Math.max(0, score);
  }

  private calculatePWAScore(hasServiceWorker: boolean, hasManifest: boolean, hasOfflineSupport: boolean, hasAppFeatures: boolean): number {
    let score = 0;
    
    if (hasServiceWorker) score += 25;
    if (hasManifest) score += 25;
    if (hasOfflineSupport) score += 25;
    if (hasAppFeatures) score += 25;
    
    return score;
  }

  // Comprehensive Security Analysis Methods
  private analyzeHTTPS() {
    const protocol = this.url.startsWith('https://') ? 'https' : 'http';
    const hasHTTPS = protocol === 'https';
    
    // Check for SSL/TLS configuration
    const hasSSL = this.responseHeaders?.['strict-transport-security'] || 
                   this.responseHeaders?.['Strict-Transport-Security'];
    
    // Check for secure redirects
    const hasSecureRedirects = this.html.includes('https://') && !this.html.includes('http://');
    
    return {
      enabled: hasHTTPS,
      details: {
        protocol,
        hasSSL,
        hasSecureRedirects,
        url: this.url,
        isSecure: hasHTTPS && hasSSL
      }
    };
  }

  private analyzeContentSecurityPolicy() {
    const cspMeta = this.dom.window.document.querySelector('meta[http-equiv="Content-Security-Policy"]');
    const cspHeader = this.responseHeaders?.['content-security-policy'] || this.responseHeaders?.['Content-Security-Policy'];
    
    const hasCSP = cspMeta !== null || !!cspHeader;
    
    // Analyze CSP strength
    let cspStrength = 'weak';
    if (hasCSP) {
      const cspContent = cspMeta?.getAttribute('content') || cspHeader || '';
      if (cspContent.includes("'unsafe-inline'") || cspContent.includes("'unsafe-eval'")) {
        cspStrength = 'weak';
      } else if (cspContent.includes('default-src') && cspContent.includes('script-src')) {
        cspStrength = 'strong';
      } else {
        cspStrength = 'medium';
      }
    }

    return {
      enabled: hasCSP,
      details: {
        hasMetaCSP: !!cspMeta,
        hasHeaderCSP: !!cspHeader,
        cspStrength,
        cspContent: cspMeta?.getAttribute('content') || cspHeader || null
      }
    };
  }

  private analyzeHSTS() {
    const hstsHeader = this.responseHeaders?.['strict-transport-security'] || this.responseHeaders?.['Strict-Transport-Security'];
    const hasHSTS = !!hstsHeader;
    
    let hstsStrength = 'weak';
    if (hasHSTS) {
      if (hstsHeader?.includes('max-age=31536000') && hstsHeader?.includes('includeSubDomains')) {
        hstsStrength = 'strong';
      } else if (hstsHeader?.includes('max-age=')) {
        hstsStrength = 'medium';
      }
    }

    return {
      enabled: hasHSTS,
      details: {
        hstsHeader,
        hstsStrength,
        hasMaxAge: hasHSTS && hstsHeader?.includes('max-age='),
        hasIncludeSubDomains: hasHSTS && hstsHeader?.includes('includeSubDomains'),
        hasPreload: hasHSTS && hstsHeader?.includes('preload')
      }
    };
  }

  private analyzeXSSProtection() {
    const issues: string[] = [];
    let isProtected = true;

    // Check for XSS protection headers
    const xssProtectionHeader = this.responseHeaders?.['x-xss-protection'] || this.responseHeaders?.['X-XSS-Protection'];
    if (!xssProtectionHeader) {
      issues.push('No X-XSS-Protection header');
      isProtected = false;
    }

    // Check for CSP
    const cspAnalysis = this.analyzeContentSecurityPolicy();
    if (!cspAnalysis.enabled) {
      issues.push('No Content Security Policy');
      isProtected = false;
    }

    // Check for unsafe inline scripts
    const hasUnsafeInline = this.html.includes('<script>') || this.html.includes('javascript:');
    if (hasUnsafeInline) {
      issues.push('Unsafe inline scripts detected');
      isProtected = false;
    }

    // Check for unvalidated user input in output
    const hasUnvalidatedOutput = this.html.includes('${') || this.html.includes('{{') || this.html.includes('<%=');
    if (hasUnvalidatedOutput) {
      issues.push('Potential unvalidated user input in output');
      isProtected = false;
    }

    return {
      protected: isProtected,
      issues,
      details: {
        hasXSSProtectionHeader: !!xssProtectionHeader,
        hasCSP: cspAnalysis.enabled,
        hasUnsafeInline,
        hasUnvalidatedOutput,
        xssProtectionLevel: xssProtectionHeader || 'none'
      }
    };
  }

  private analyzeCSRFProtection() {
    const issues: string[] = [];
    let isProtected = true;

    // Check for CSRF tokens in forms
    const forms = this.dom.window.document.querySelectorAll('form');
    const hasCSRFTokens = Array.from(forms).some(form => {
      const inputs = form.querySelectorAll('input[type="hidden"]');
      return Array.from(inputs).some(input => {
        const name = input.getAttribute('name')?.toLowerCase() || '';
        const value = input.getAttribute('value') || '';
        return name.includes('csrf') || name.includes('token') || name.includes('nonce') || 
               value.length > 20; // Long values are likely tokens
      });
    });

    if (!hasCSRFTokens && forms.length > 0) {
      issues.push('No CSRF tokens detected in forms');
      isProtected = false;
    }

    // Check for SameSite cookie attribute
    const setCookieHeaders = this.responseHeaders?.['set-cookie'] || this.responseHeaders?.['Set-Cookie'];
    const hasSameSite = setCookieHeaders && (Array.isArray(setCookieHeaders) ? 
      setCookieHeaders.some(cookie => cookie.toLowerCase().includes('samesite')) :
      setCookieHeaders.toLowerCase().includes('samesite'));

    if (!hasSameSite) {
      issues.push('No SameSite cookie attribute');
      isProtected = false;
    }

    return {
      protected: isProtected,
      issues,
      details: {
        hasCSRFTokens,
        hasSameSite,
        formCount: forms.length,
        csrfTokenCount: Array.from(forms).filter(form => {
          const inputs = form.querySelectorAll('input[type="hidden"]');
          return Array.from(inputs).some(input => {
            const name = input.getAttribute('name')?.toLowerCase() || '';
            return name.includes('csrf') || name.includes('token') || name.includes('nonce');
          });
        }).length
      }
    };
  }

  private analyzeInputValidation() {
    const issues: string[] = [];
    let validated = true;

    // Check for input validation attributes
    const inputs = this.dom.window.document.querySelectorAll('input, select, textarea');
    const inputsWithoutValidation = Array.from(inputs).filter(input => {
      const inputElement = input as HTMLInputElement;
      const type = inputElement.getAttribute('type')?.toLowerCase() || '';
      const required = inputElement.hasAttribute('required');
      const pattern = inputElement.getAttribute('pattern');
      const minLength = inputElement.getAttribute('minlength');
      const maxLength = inputElement.getAttribute('maxlength');
      
      return !required && !pattern && !minLength && !maxLength && 
             !['email', 'tel', 'number', 'date', 'url'].includes(type);
    });

    if (inputsWithoutValidation.length > 0) {
      issues.push(`${inputsWithoutValidation.length} inputs without validation`);
      validated = false;
    }

    // Check for client-side validation
    const hasClientValidation = this.html.includes('required') || this.html.includes('pattern') || 
                               this.html.includes('minlength') || this.html.includes('maxlength');
    if (!hasClientValidation && inputs.length > 0) {
      issues.push('No client-side validation detected');
      validated = false;
    }

    return {
      validated,
      issues,
      details: {
        totalInputs: inputs.length,
        inputsWithoutValidation: inputsWithoutValidation.length,
        hasClientValidation,
        validationTypes: {
          required: Array.from(inputs).filter(input => input.hasAttribute('required')).length,
          pattern: Array.from(inputs).filter(input => input.hasAttribute('pattern')).length,
          minLength: Array.from(inputs).filter(input => input.hasAttribute('minlength')).length,
          maxLength: Array.from(inputs).filter(input => input.hasAttribute('maxlength')).length
        }
      }
    };
  }

  private analyzeOutputEncoding() {
    const issues: string[] = [];
    let encoded = true;

    // Check for HTML encoding
    const hasHTMLEntities = this.html.includes('&amp;') || this.html.includes('&lt;') || 
                           this.html.includes('&gt;') || this.html.includes('&quot;') || 
                           this.html.includes('&#x27;') || this.html.includes('&#x2F;');
    
    if (!hasHTMLEntities) {
      issues.push('No HTML encoding detected');
      encoded = false;
    }

    // Check for unencoded special characters
    const hasUnencodedChars = this.html.includes('<script>') || this.html.includes('javascript:') ||
                             this.html.includes('onclick=') || this.html.includes('onload=');
    if (hasUnencodedChars) {
      issues.push('Unencoded special characters detected');
      encoded = false;
    }

    // Check for proper output encoding patterns
    const hasEncodingPatterns = this.html.includes('htmlspecialchars') || this.html.includes('htmlentities') ||
                               this.html.includes('escape') || this.html.includes('encodeURIComponent');
    if (!hasEncodingPatterns) {
      issues.push('No output encoding patterns detected');
      encoded = false;
    }

    return {
      encoded,
      issues,
      details: {
        hasHTMLEntities,
        hasUnencodedChars,
        hasEncodingPatterns,
        encodingMethods: {
          htmlspecialchars: this.html.includes('htmlspecialchars'),
          htmlentities: this.html.includes('htmlentities'),
          escape: this.html.includes('escape'),
          encodeURIComponent: this.html.includes('encodeURIComponent')
        }
      }
    };
  }

  private analyzeSessionManagement() {
    const issues: string[] = [];
    let secure = true;

    // Check for session cookies
    const setCookieHeaders = this.responseHeaders?.['set-cookie'] || this.responseHeaders?.['Set-Cookie'];
    const hasSessionCookies = setCookieHeaders && (Array.isArray(setCookieHeaders) ? 
      setCookieHeaders.some(cookie => cookie.toLowerCase().includes('session')) :
      setCookieHeaders.toLowerCase().includes('session'));

    if (!hasSessionCookies) {
      issues.push('No session cookies detected');
      secure = false;
    }

    // Check for secure session handling
    const hasSecureSession = this.html.includes('session') || this.html.includes('token') ||
                            this.html.includes('authentication') || this.html.includes('login');
    if (!hasSecureSession) {
      issues.push('No secure session handling detected');
      secure = false;
    }

    // Check for session timeout
    const hasSessionTimeout = this.html.includes('timeout') || this.html.includes('expire') ||
                             this.html.includes('max-age');
    if (!hasSessionTimeout) {
      issues.push('No session timeout detected');
      secure = false;
    }

    return {
      secure,
      issues,
      details: {
        hasSessionCookies,
        hasSecureSession,
        hasSessionTimeout,
        sessionMethods: {
          session: this.html.includes('session'),
          token: this.html.includes('token'),
          authentication: this.html.includes('authentication'),
          login: this.html.includes('login')
        }
      }
    };
  }

  private analyzeCookieSecurity() {
    const issues: string[] = [];
    let secure = true;

    // Check for secure cookie flags
    const setCookieHeaders = this.responseHeaders?.['set-cookie'] || this.responseHeaders?.['Set-Cookie'];
    if (setCookieHeaders) {
      const cookies = Array.isArray(setCookieHeaders) ? setCookieHeaders : [setCookieHeaders];
      const secureCookies = cookies.filter(cookie => 
        cookie.toLowerCase().includes('secure') && cookie.toLowerCase().includes('httponly')
      );

      if (secureCookies.length === 0) {
        issues.push('No secure cookies detected');
        secure = false;
      }

      // Check for SameSite attribute
      const hasSameSite = cookies.some(cookie => cookie.toLowerCase().includes('samesite'));
      if (!hasSameSite) {
        issues.push('No SameSite cookie attribute');
        secure = false;
      }
    } else {
      issues.push('No cookies detected');
      secure = false;
    }

    return {
      secure,
      issues,
      details: {
        totalCookies: setCookieHeaders ? (Array.isArray(setCookieHeaders) ? setCookieHeaders.length : 1) : 0,
        secureCookies: setCookieHeaders ? (Array.isArray(setCookieHeaders) ? 
          setCookieHeaders.filter(cookie => cookie.toLowerCase().includes('secure')).length : 
          (setCookieHeaders.toLowerCase().includes('secure') ? 1 : 0)) : 0,
        hasSameSite: setCookieHeaders ? (Array.isArray(setCookieHeaders) ? 
          setCookieHeaders.some(cookie => cookie.toLowerCase().includes('samesite')) :
          setCookieHeaders.toLowerCase().includes('samesite')) : false
      }
    };
  }

  private analyzeErrorHandling() {
    const issues: string[] = [];
    let secure = true;

    // Check for error handling patterns
    const hasErrorHandling = this.html.includes('try') || this.html.includes('catch') ||
                            this.html.includes('error') || this.html.includes('exception');
    if (!hasErrorHandling) {
      issues.push('No error handling patterns detected');
      secure = false;
    }

    // Check for generic error messages
    const hasGenericErrors = this.html.includes('error occurred') || this.html.includes('something went wrong') ||
                            this.html.includes('internal error') || this.html.includes('system error');
    if (!hasGenericErrors) {
      issues.push('No generic error messages detected');
      secure = false;
    }

    // Check for sensitive information in errors
    const hasSensitiveErrors = this.html.includes('sql error') || this.html.includes('database error') ||
                              this.html.includes('stack trace') || this.html.includes('debug');
    if (hasSensitiveErrors) {
      issues.push('Sensitive information in error messages');
      secure = false;
    }

    return {
      secure,
      issues,
      details: {
        hasErrorHandling,
        hasGenericErrors,
        hasSensitiveErrors,
        errorHandlingMethods: {
          tryCatch: this.html.includes('try') && this.html.includes('catch'),
          error: this.html.includes('error'),
          exception: this.html.includes('exception')
        }
      }
    };
  }

  private analyzeSensitiveInformation() {
    const issues: string[] = [];
    let exposed = false;

    // Check for sensitive patterns in HTML
    const sensitivePatterns = [
      'password', 'secret', 'key', 'token', 'api_key', 'private_key', 'database_url',
      'connection_string', 'aws_access_key', 'aws_secret_key', 'google_api_key',
      'facebook_app_secret', 'stripe_secret_key', 'paypal_secret', 'database_password',
      'admin_password', 'root_password', 'private_key', 'secret_key', 'access_token'
    ];

    const foundSensitiveInfo = sensitivePatterns.filter(pattern => 
      this.html.toLowerCase().includes(pattern.toLowerCase())
    );

    if (foundSensitiveInfo.length > 0) {
      issues.push(`Sensitive information patterns detected: ${foundSensitiveInfo.join(', ')}`);
      exposed = true;
    }

    // Check for hardcoded credentials
    const hasHardcodedCredentials = this.html.includes('admin:admin') || this.html.includes('root:root') ||
                                   this.html.includes('user:password') || this.html.includes('test:test');
    if (hasHardcodedCredentials) {
      issues.push('Hardcoded credentials detected');
      exposed = true;
    }

    // Check for database connection strings
    const hasDBConnections = this.html.includes('mysql://') || this.html.includes('postgresql://') ||
                            this.html.includes('mongodb://') || this.html.includes('redis://');
    if (hasDBConnections) {
      issues.push('Database connection strings detected');
      exposed = true;
    }

    return {
      exposed,
      issues,
      details: {
        sensitivePatternsFound: foundSensitiveInfo.length,
        patterns: foundSensitiveInfo,
        hasHardcodedCredentials,
        hasDBConnections,
        riskLevel: foundSensitiveInfo.length > 5 ? 'high' : foundSensitiveInfo.length > 2 ? 'medium' : 'low'
      }
    };
  }

  private analyzeOpenRedirects() {
    const issues: string[] = [];
    let vulnerable = false;

    // Check for redirect parameters
    const redirectParams = ['redirect', 'url', 'next', 'return', 'goto', 'target', 'destination'];
    const hasRedirectParams = redirectParams.some(param => 
      this.html.includes(`${param}=`) || this.html.includes(`?${param}`)
    );

    if (hasRedirectParams) {
      issues.push('Redirect parameters detected');
      vulnerable = true;
    }

    // Check for unvalidated redirect URLs
    const hasUnvalidatedRedirects = this.html.includes('window.location') || this.html.includes('location.href') ||
                                   this.html.includes('location.replace') || this.html.includes('location.assign');
    if (hasUnvalidatedRedirects) {
      issues.push('Unvalidated redirect URLs detected');
      vulnerable = true;
    }

    // Check for external redirects
    const hasExternalRedirects = this.html.includes('http://') || this.html.includes('https://') ||
                                this.html.includes('//') || this.html.includes('javascript:');
    if (hasExternalRedirects) {
      issues.push('External redirect URLs detected');
      vulnerable = true;
    }

    return {
      vulnerable,
      issues,
      details: {
        hasRedirectParams,
        hasUnvalidatedRedirects,
        hasExternalRedirects,
        redirectMethods: {
          windowLocation: this.html.includes('window.location'),
          locationHref: this.html.includes('location.href'),
          locationReplace: this.html.includes('location.replace'),
          locationAssign: this.html.includes('location.assign')
        }
      }
    };
  }

  private analyzeSQLInjection() {
    const issues: string[] = [];
    let vulnerable = false;

    // Check for SQL injection patterns
    const sqlPatterns = ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'DROP', 'CREATE', 'ALTER'];
    const hasSQLPatterns = sqlPatterns.some(pattern => 
      this.html.includes(pattern) && this.html.includes('WHERE')
    );

    if (hasSQLPatterns) {
      issues.push('SQL patterns detected in HTML');
      vulnerable = true;
    }

    // Check for unvalidated user input in SQL
    const hasUnvalidatedSQL = this.html.includes('${') || this.html.includes('{{') || 
                              this.html.includes('<%=') || this.html.includes('+');
    if (hasUnvalidatedSQL) {
      issues.push('Unvalidated user input in SQL detected');
      vulnerable = true;
    }

    // Check for database error messages
    const hasDBErrors = this.html.includes('sql error') || this.html.includes('mysql error') ||
                       this.html.includes('database error') || this.html.includes('ora-');
    if (hasDBErrors) {
      issues.push('Database error messages detected');
      vulnerable = true;
    }

    return {
      vulnerable,
      issues,
      details: {
        hasSQLPatterns,
        hasUnvalidatedSQL,
        hasDBErrors,
        sqlCommands: sqlPatterns.filter(pattern => this.html.includes(pattern)),
        riskLevel: hasSQLPatterns && hasUnvalidatedSQL ? 'high' : 'medium'
      }
    };
  }

  private analyzeClickjacking() {
    const issues: string[] = [];
    let vulnerable = false;

    // Check for X-Frame-Options header
    const hasXFrameOptions = this.responseHeaders?.['x-frame-options'] || this.responseHeaders?.['X-Frame-Options'];
    if (!hasXFrameOptions) {
      issues.push('No X-Frame-Options header');
      vulnerable = true;
    } else if (hasXFrameOptions !== 'DENY' && hasXFrameOptions !== 'SAMEORIGIN') {
      issues.push('Weak X-Frame-Options header');
      vulnerable = true;
    }

    // Check for CSP frame-ancestors
    const cspHeader = this.responseHeaders?.['content-security-policy'] || this.responseHeaders?.['Content-Security-Policy'];
    const hasFrameAncestors = cspHeader && cspHeader.includes('frame-ancestors');
    if (!hasFrameAncestors) {
      issues.push('No CSP frame-ancestors directive');
      vulnerable = true;
    }

    // Check for iframe usage
    const hasIframes = this.dom.window.document.querySelectorAll('iframe').length > 0;
    if (hasIframes) {
      issues.push('Iframes detected without proper protection');
      vulnerable = true;
    }

    return {
      vulnerable,
      issues,
      details: {
        hasXFrameOptions: !!hasXFrameOptions,
        xFrameOptionsValue: hasXFrameOptions,
        hasFrameAncestors,
        hasIframes,
        iframeCount: this.dom.window.document.querySelectorAll('iframe').length
      }
    };
  }

  private analyzeInformationDisclosure() {
    const issues: string[] = [];
    let disclosed = false;

    // Check for server information
    const server = this.responseHeaders?.['server'] || this.responseHeaders?.['Server'];
    if (server) {
      issues.push(`Server information disclosed: ${server}`);
      disclosed = true;
    }

    // Check for technology stack disclosure
    const hasTechDisclosure = this.html.includes('powered by') || this.html.includes('built with') ||
                             this.html.includes('framework') || this.html.includes('version');
    if (hasTechDisclosure) {
      issues.push('Technology stack information disclosed');
      disclosed = true;
    }

    // Check for directory listing
    const hasDirectoryListing = this.html.includes('index of') || this.html.includes('directory listing') ||
                               this.html.includes('parent directory');
    if (hasDirectoryListing) {
      issues.push('Directory listing detected');
      disclosed = true;
    }

    // Check for backup files
    const hasBackupFiles = this.html.includes('.bak') || this.html.includes('.backup') ||
                          this.html.includes('.old') || this.html.includes('.tmp');
    if (hasBackupFiles) {
      issues.push('Backup files detected');
      disclosed = true;
    }

    return {
      disclosed,
      issues,
      details: {
        server,
        hasTechDisclosure,
        hasDirectoryListing,
        hasBackupFiles,
        disclosureLevel: disclosed ? 'high' : 'low'
      }
    };
  }

  private analyzeAuthentication() {
    const issues: string[] = [];
    let secure = true;

    // Check for authentication forms
    const authForms = this.dom.window.document.querySelectorAll('form');
    const hasAuthForms = Array.from(authForms).some(form => {
      const inputs = form.querySelectorAll('input');
      return Array.from(inputs).some(input => {
        const type = input.getAttribute('type')?.toLowerCase();
        const name = input.getAttribute('name')?.toLowerCase();
        return type === 'password' || name?.includes('password') || name?.includes('username');
      });
    });

    if (!hasAuthForms) {
      issues.push('No authentication forms detected');
      secure = false;
    }

    // Check for secure authentication
    const hasSecureAuth = this.html.includes('https://') || this.html.includes('ssl') ||
                         this.html.includes('tls') || this.html.includes('encryption');
    if (!hasSecureAuth) {
      issues.push('No secure authentication detected');
      secure = false;
    }

    // Check for multi-factor authentication
    const hasMFA = this.html.includes('2fa') || this.html.includes('two-factor') ||
                   this.html.includes('mfa') || this.html.includes('otp');
    if (!hasMFA) {
      issues.push('No multi-factor authentication detected');
      secure = false;
    }

    return {
      secure,
      issues,
      details: {
        hasAuthForms,
        hasSecureAuth,
        hasMFA,
        authMethods: {
          password: this.html.includes('password'),
          username: this.html.includes('username'),
          login: this.html.includes('login'),
          signin: this.html.includes('signin')
        }
      }
    };
  }

  private analyzeAuthorization() {
    const issues: string[] = [];
    let secure = true;

    // Check for role-based access control
    const hasRBAC = this.html.includes('role') || this.html.includes('permission') ||
                    this.html.includes('authorization') || this.html.includes('access control');
    if (!hasRBAC) {
      issues.push('No role-based access control detected');
      secure = false;
    }

    // Check for authorization checks
    const hasAuthChecks = this.html.includes('isAuthenticated') || this.html.includes('hasRole') ||
                         this.html.includes('canAccess') || this.html.includes('authorize');
    if (!hasAuthChecks) {
      issues.push('No authorization checks detected');
      secure = false;
    }

    // Check for admin access controls
    const hasAdminControls = this.html.includes('admin') || this.html.includes('administrator') ||
                            this.html.includes('superuser') || this.html.includes('root');
    if (!hasAdminControls) {
      issues.push('No admin access controls detected');
      secure = false;
    }

    return {
      secure,
      issues,
      details: {
        hasRBAC,
        hasAuthChecks,
        hasAdminControls,
        authorizationMethods: {
          role: this.html.includes('role'),
          permission: this.html.includes('permission'),
          authorization: this.html.includes('authorization'),
          accessControl: this.html.includes('access control')
        }
      }
    };
  }

  private analyzeDataEncryption() {
    const issues: string[] = [];
    let encrypted = true;

    // Check for encryption patterns
    const hasEncryption = this.html.includes('encrypt') || this.html.includes('hash') ||
                         this.html.includes('sha') || this.html.includes('md5') ||
                         this.html.includes('bcrypt') || this.html.includes('aes');
    if (!hasEncryption) {
      issues.push('No encryption patterns detected');
      encrypted = false;
    }

    // Check for secure transmission
    const hasSecureTransmission = this.url.startsWith('https://') || this.html.includes('ssl') ||
                                 this.html.includes('tls') || this.html.includes('secure');
    if (!hasSecureTransmission) {
      issues.push('No secure transmission detected');
      encrypted = false;
    }

    // Check for data protection
    const hasDataProtection = this.html.includes('privacy') || this.html.includes('gdpr') ||
                             this.html.includes('data protection') || this.html.includes('compliance');
    if (!hasDataProtection) {
      issues.push('No data protection measures detected');
      encrypted = false;
    }

    return {
      encrypted,
      issues,
      details: {
        hasEncryption,
        hasSecureTransmission,
        hasDataProtection,
        encryptionMethods: {
          hash: this.html.includes('hash'),
          sha: this.html.includes('sha'),
          md5: this.html.includes('md5'),
          bcrypt: this.html.includes('bcrypt'),
          aes: this.html.includes('aes')
        }
      }
    };
  }

  private analyzeThirdPartySecurity() {
    const issues: string[] = [];
    let secure = true;

    // Check for third-party scripts
    const thirdPartyDomains = [
      'googleapis.com', 'gstatic.com', 'facebook.net', 'doubleclick.net',
      'googletagmanager.com', 'google-analytics.com', 'hotjar.com', 'mixpanel.com'
    ];

    const thirdPartyScripts = this.dom.window.document.querySelectorAll('script[src]');
    const externalScripts = Array.from(thirdPartyScripts).filter(script => {
      const src = script.getAttribute('src') || '';
      return thirdPartyDomains.some(domain => src.includes(domain));
    });

    if (externalScripts.length > 5) {
      issues.push(`${externalScripts.length} third-party scripts detected`);
      secure = false;
    }

    // Check for SRI (Subresource Integrity)
    const hasSRI = Array.from(thirdPartyScripts).some(script => script.hasAttribute('integrity'));
    if (!hasSRI && externalScripts.length > 0) {
      issues.push('No Subresource Integrity (SRI) detected');
      secure = false;
    }

    return {
      secure,
      issues,
      details: {
        thirdPartyScripts: externalScripts.length,
        hasSRI,
        domains: thirdPartyDomains.filter(domain => this.html.includes(domain)),
        totalScripts: thirdPartyScripts.length
      }
    };
  }

  private analyzeAPISecurity() {
    const issues: string[] = [];
    let secure = true;

    // Check for API endpoints
    const apiEndpoints = this.extractAPIEndpoints();
    if (apiEndpoints.length > 0) {
      // Check for API authentication
      const hasAPIAuth = this.html.includes('api_key') || this.html.includes('bearer') ||
                        this.html.includes('oauth') || this.html.includes('jwt');
      if (!hasAPIAuth) {
        issues.push('No API authentication detected');
        secure = false;
      }

      // Check for rate limiting
      const hasRateLimiting = this.html.includes('rate limit') || this.html.includes('throttle') ||
                             this.html.includes('quota') || this.html.includes('limit');
      if (!hasRateLimiting) {
        issues.push('No rate limiting detected');
        secure = false;
      }
    }

    return {
      secure,
      issues,
      details: {
        apiEndpoints: apiEndpoints.length,
        hasAPIAuth: this.html.includes('api_key') || this.html.includes('bearer') ||
                   this.html.includes('oauth') || this.html.includes('jwt'),
        hasRateLimiting: this.html.includes('rate limit') || this.html.includes('throttle') ||
                        this.html.includes('quota') || this.html.includes('limit'),
        endpoints: apiEndpoints
      }
    };
  }

  private analyzeFileUploadSecurity() {
    const issues: string[] = [];
    let secure = true;

    // Check for file upload forms
    const fileUploads = this.dom.window.document.querySelectorAll('input[type="file"]');
    if (fileUploads.length > 0) {
      // Check for file type restrictions
      const hasFileTypeRestrictions = Array.from(fileUploads).some(input => {
        const accept = input.getAttribute('accept');
        return accept && accept.length > 0;
      });
      if (!hasFileTypeRestrictions) {
        issues.push('No file type restrictions detected');
        secure = false;
      }

      // Check for file size limits
      const hasFileSizeLimits = this.html.includes('maxsize') || this.html.includes('max-size') ||
                               this.html.includes('file size') || this.html.includes('upload limit');
      if (!hasFileSizeLimits) {
        issues.push('No file size limits detected');
        secure = false;
      }
    }

    return {
      secure,
      issues,
      details: {
        fileUploads: fileUploads.length,
        hasFileTypeRestrictions: Array.from(fileUploads).some(input => {
          const accept = input.getAttribute('accept');
          return accept && accept.length > 0;
        }),
        hasFileSizeLimits: this.html.includes('maxsize') || this.html.includes('max-size') ||
                          this.html.includes('file size') || this.html.includes('upload limit')
      }
    };
  }

  private analyzeBusinessLogic() {
    const issues: string[] = [];
    let secure = true;

    // Check for business logic validation
    const hasBusinessValidation = this.html.includes('validate') || this.html.includes('verification') ||
                                 this.html.includes('check') || this.html.includes('confirm');
    if (!hasBusinessValidation) {
      issues.push('No business logic validation detected');
      secure = false;
    }

    // Check for workflow controls
    const hasWorkflowControls = this.html.includes('workflow') || this.html.includes('process') ||
                               this.html.includes('step') || this.html.includes('stage');
    if (!hasWorkflowControls) {
      issues.push('No workflow controls detected');
      secure = false;
    }

    return {
      secure,
      issues,
      details: {
        hasBusinessValidation,
        hasWorkflowControls,
        businessLogicMethods: {
          validate: this.html.includes('validate'),
          verification: this.html.includes('verification'),
          check: this.html.includes('check'),
          confirm: this.html.includes('confirm')
        }
      }
    };
  }

  private analyzeSecurityMisconfiguration() {
    const issues: string[] = [];
    let secure = true;

    // Check for default configurations
    const hasDefaultConfig = this.html.includes('default') || this.html.includes('admin') ||
                            this.html.includes('test') || this.html.includes('demo');
    if (hasDefaultConfig) {
      issues.push('Default configurations detected');
      secure = false;
    }

    // Check for debug mode
    const hasDebugMode = this.html.includes('debug') || this.html.includes('development') ||
                        this.html.includes('test') || this.html.includes('dev');
    if (hasDebugMode) {
      issues.push('Debug mode detected');
      secure = false;
    }

    // Check for verbose error messages
    const hasVerboseErrors = this.html.includes('stack trace') || this.html.includes('error details') ||
                            this.html.includes('exception') || this.html.includes('debug info');
    if (hasVerboseErrors) {
      issues.push('Verbose error messages detected');
      secure = false;
    }

    return {
      secure,
      issues,
      details: {
        hasDefaultConfig,
        hasDebugMode,
        hasVerboseErrors,
        misconfigurationLevel: hasDebugMode && hasVerboseErrors ? 'high' : 'medium'
      }
    };
  }

  private analyzeVulnerableComponents() {
    const issues: string[] = [];
    let vulnerable = false;

    // Check for known vulnerable components
    const vulnerableComponents = [
      'jquery', 'bootstrap', 'angular', 'react', 'vue', 'wordpress', 'drupal',
      'joomla', 'magento', 'shopify', 'woocommerce', 'phpmyadmin', 'cpanel'
    ];

    const detectedComponents = vulnerableComponents.filter(component => 
      this.html.toLowerCase().includes(component.toLowerCase())
    );

    if (detectedComponents.length > 0) {
      issues.push(`Known components detected: ${detectedComponents.join(', ')}`);
      vulnerable = true;
    }

    // Check for outdated version indicators
    const hasVersionInfo = this.html.includes('version') || this.html.includes('v.') ||
                          this.html.includes('ver.') || this.html.includes('build');
    if (hasVersionInfo) {
      issues.push('Version information disclosed');
      vulnerable = true;
    }

    return {
      vulnerable,
      issues,
      details: {
        detectedComponents,
        hasVersionInfo,
        componentCount: detectedComponents.length,
        riskLevel: detectedComponents.length > 3 ? 'high' : 'medium'
      }
    };
  }
} 